[{"content":"Redisson 可重入锁原理详解 1. 为什么需要可重入锁？ 在日常开发中，锁 是保证线程安全的重要手段。但有时候，一个线程在持有锁时，会调用另一个也需要同一把锁的方法，这时问题就来了：\n如果锁 不可重入，线程在第二次尝试加锁时会失败，因为锁已经存在，它相当于 把自己卡死了。 如果锁 可重入，同一个线程可以多次获取这把锁，直到最后释放时才真正解锁。 所以，可重入锁的意义在于：避免同一线程因为方法嵌套调用而死锁。\n2. 普通分布式锁的问题 最简单的分布式锁通常用 Redis 的 SETNX 实现：\n1 SET key value NX EX 30 NX 表示如果 key 不存在才设置，保证原子性。 EX 30 设置过期时间，防止死锁。 问题出在哪里？ 当一个线程已经持有锁时，如果在方法嵌套中再次尝试获取锁：\nRedis 发现 key 已存在，直接返回失败。 虽然是 同一个线程 想再次获取锁，但因为锁实现里只区分 \u0026ldquo;有锁 / 无锁\u0026rdquo;，并不会识别线程。 结果就是：自己把自己锁死了。 3. Redisson 的改进（可重入实现） Redisson 在 value 的存储上做了改进，它并不是简单的字符串，而是一个 Hash 结构：\n1 2 3 lockKey -\u0026gt; { threadId : reentrantCount } threadId：唯一标识某个 JVM 里的某个线程（一般是 UUID:threadId）。 reentrantCount：记录这个线程持有锁的次数。 这样就可以支持 可重入 了。\n4. 执行流程举例 假设我们有两个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void methodA() { lock.lock(); try { methodB(); } finally { lock.unlock(); } } public void methodB() { lock.lock(); try { // 执行逻辑 } finally { lock.unlock(); } } 4.1 第一次加锁（methodA） Redis 里还没有 lockKey。 Redisson 会写入： 1 lockKey -\u0026gt; { \u0026#34;UUID:thread-1\u0026#34; : 1 } 表示线程 thread-1 第一次获取锁，重入次数 = 1。 4.2 第二次加锁（methodB） Redis 发现 lockKey 已存在，但 owner 是 同一个线程。 允许重入，计数 +1： 1 lockKey -\u0026gt; { \u0026#34;UUID:thread-1\u0026#34; : 2 } 4.3 methodB 执行完释放锁 调用 unlock()，计数 -1： 1 lockKey -\u0026gt; { \u0026#34;UUID:thread-1\u0026#34; : 1 } 锁仍然由当前线程持有。 4.4 methodA 执行完释放锁 再次调用 unlock()，计数 -1 → 变成 0。 Redisson 删除 lockKey： 1 lockKey 删除 此时锁才真正释放，其他线程才有机会获取。 5. 通俗解释 用通俗的话再描述一次：\n假如一个线程调用多个方法时，第一个方法用了锁去调用第二个方法，第二个方法再次调用这个线程的锁就会失败。因为虽然锁的 key 一样，但是第二次获取锁的时候会发现锁已经存在了，就获取失败。\nRedisson 在这个基础上做了改进：它在锁的 value 里加上了一个 重入次数，并利用 Redis Hash 结构来存储。\nHash 结构里有两个值：\nfield：当前线程的标识（UUID + threadId） value：重入次数 执行过程是这样的：\n方法一第一次获取锁：重入次数 +1，变成 1 方法一调用方法二，方法二又要用锁：重入次数再 +1，变成 2 方法二执行完释放锁：重入次数 -1，变回 1 方法一执行完释放锁：重入次数 -1，变回 0，锁才真正释放 这样就避免了同一个线程因为嵌套调用而死锁。\n6. 核心实现原理 6.1 加锁流程 1 2 3 4 5 6 7 8 9 10 11 12 -- 加锁脚本 if (redis.call(\u0026#39;exists\u0026#39;, KEYS[1]) == 0) then redis.call(\u0026#39;hset\u0026#39;, KEYS[1], ARGV[2], 1); redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(\u0026#39;hexists\u0026#39;, KEYS[1], ARGV[2]) == 1) then redis.call(\u0026#39;hincrby\u0026#39;, KEYS[1], ARGV[2], 1); redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[1]); return nil; end; return redis.call(\u0026#39;pttl\u0026#39;, KEYS[1]); 6.2 释放锁流程 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 释放锁脚本 if (redis.call(\u0026#39;hexists\u0026#39;, KEYS[1], ARGV[3]) == 0) then return nil; end; local counter = redis.call(\u0026#39;hincrby\u0026#39;, KEYS[1], ARGV[3], -1); if (counter \u0026gt; 0) then redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[2]); return 0; else redis.call(\u0026#39;del\u0026#39;, KEYS[1]); redis.call(\u0026#39;publish\u0026#39;, KEYS[2], ARGV[1]); return 1; end; 7. 关键特性 7.1 线程安全 使用 Lua 脚本保证原子性 避免竞态条件 7.2 自动续期 通过 pexpire 自动续期 防止业务执行时间过长导致锁过期 7.3 公平性 支持公平锁和非公平锁 通过队列机制保证获取锁的顺序 7.4 可重入性 同一线程可多次获取锁 通过重入计数器实现 8. 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 获取可重入锁 RLock lock = redisson.getLock(\u0026#34;myLock\u0026#34;); try { // 尝试加锁，最多等待100秒，上锁以后10秒自动解锁 boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS); if (res) { try { // 业务逻辑 doSomething(); } finally { lock.unlock(); } } } catch (InterruptedException e) { e.printStackTrace(); } 9. 总结升华 普通分布式锁只关心 \u0026ldquo;有锁 / 无锁\u0026rdquo;，不关心是谁加的锁，导致 同一线程重入时也会失败。\nRedisson 通过在 Redis 的 Hash 结构 中记录 \u0026ldquo;线程标识 + 重入计数\u0026rdquo;，让锁具备了 可重入能力。\n意义：可重入锁避免了一个线程在嵌套调用中把自己卡死，同时对外仍然保持分布式锁的特性。\n一句话总结： Redisson 的可重入锁，本质上就是用 Redis Hash 存储线程 ID 和重入次数，直到重入次数归零才真正释放锁。\n10. 扩展阅读 Redisson 官方文档 Redis 分布式锁最佳实践 Java 并发编程实战 本文档详细介绍了 Redisson 可重入锁的实现原理，帮助开发者深入理解分布式锁的核心机制。\n","date":"2025-09-14T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/redisson-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/","title":"Redisson 可重入锁原理详解"},{"content":"深入理解 Redis + Lua 在秒杀系统中的应用 在高并发场景下，尤其是秒杀系统，如何保证库存扣减的正确性和用户限购的准确性，是一个非常经典的问题。\n本文将通过一个完整的案例，详细讲解 Redis + Lua 脚本 在秒杀活动中的使用方式。\n一、背景介绍 在秒杀场景中，如果单纯依赖后端数据库进行库存扣减与用户校验，往往会产生以下问题：\n高并发下数据库压力过大：大量用户同时下单，数据库容易被打爆。 超卖问题：多个线程并发操作时，可能会出现库存被扣成负数的情况。 限购逻辑失效：如果并发控制不好，同一用户可能绕过限购限制。 为了解决这些问题，我们通常会 将秒杀的核心逻辑放到 Redis 里，利用 Redis 的高性能与 Lua 脚本的原子性，来保证数据一致性。\n二、Redis Key 设计 在这个秒杀系统中，我们为每个活动设计了两个关键的 Redis Key：\n1. 库存 Key 1 seckill:stock:{activityId} 作用：存放某个活动的剩余库存数量。\n示例：\n1 SET seckill:stock:1001 50 表示活动 1001 还有 50 件商品。\n2. 参与用户 Key 1 seckill:participants:{activityId} 作用：存放某个活动所有用户的购买记录（哈希表）。\n示例：\n1 2 HSET seckill:participants:1001 12345 1 HSET seckill:participants:1001 67890 2 表示：\n用户 12345 已经购买 1 件 用户 67890 已经购买 2 件 三、Java 代码调用 Lua 脚本 在后端中，调用 Lua 脚本的方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 String stockKey = seckillPrefix + \u0026#34;stock:\u0026#34; + activityId; String participantsKey = seckillPrefix + \u0026#34;participants:\u0026#34; + activityId; DefaultRedisScript\u0026lt;List\u0026gt; script = new DefaultRedisScript\u0026lt;\u0026gt;(); script.setScriptSource(new ResourceScriptSource(new ClassPathResource(\u0026#34;seckill_participate.lua\u0026#34;))); script.setResultType(List.class); List\u0026lt;String\u0026gt; keys = Arrays.asList(stockKey, participantsKey); List\u0026lt;Object\u0026gt; args = Arrays.asList( userId.toString(), quantity.toString(), activity.getPerUserLimit().toString() ); List result = redisTemplate.execute(script, keys, args.toArray()); 参数传递说明 这里需要重点理解的有两部分：\nkeys → 传递给 Lua 的 Redis Key，脚本里用 KEYS[] 访问：\nKEYS[1] = \u0026quot;seckill:stock:1001\u0026quot; （这个活动的库存） KEYS[2] = \u0026quot;seckill:participants:1001\u0026quot; （记录了这个活动所有用户的购买记录） args → 附加参数，脚本里用 ARGV[] 访问：\nARGV[1] = userId （当前用户 ID） ARGV[2] = quantity （本次购买数量） ARGV[3] = perUserLimit （每人限购数量） 四、Lua 脚本逻辑详解 Lua 脚本具有原子性，在 Redis 中执行时不会被打断，非常适合秒杀场景。\n典型的 seckill_participate.lua 脚本如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- 获取参数 local stock = tonumber(redis.call(\u0026#34;GET\u0026#34;, KEYS[1])) local userId = ARGV[1] local quantity = tonumber(ARGV[2]) local perUserLimit = tonumber(ARGV[3]) -- 查询用户已购买数量 local userBought = tonumber(redis.call(\u0026#34;HGET\u0026#34;, KEYS[2], userId) or \u0026#34;0\u0026#34;) -- 1. 校验是否超过个人限购 if userBought + quantity \u0026gt; perUserLimit then return {0, \u0026#34;超过个人限购\u0026#34;} end -- 2. 校验库存是否足够 if stock \u0026lt; quantity then return {0, \u0026#34;库存不足\u0026#34;} end -- 3. 扣减库存 redis.call(\u0026#34;DECRBY\u0026#34;, KEYS[1], quantity) -- 4. 更新用户购买数量 redis.call(\u0026#34;HINCRBY\u0026#34;, KEYS[2], userId, quantity) -- 5. 返回成功 return {1, \u0026#34;成功\u0026#34;} 脚本执行流程详解 让我们逐步分析这个脚本的执行过程：\n1. 参数接收 1 2 3 local userId = ARGV[1] -- 接收用户ID local quantity = tonumber(ARGV[2]) -- 接收购买数量 local perUserLimit = tonumber(ARGV[3]) -- 接收限购数量 后端通过 redisTemplate.execute(...) 传入这些 ARGV 参数给 Lua 脚本，脚本接收每个参数。\n2. 查询用户购买记录 1 local userBought = tonumber(redis.call(\u0026#34;HGET\u0026#34;, KEYS[2], userId) or \u0026#34;0\u0026#34;) 这段代码的作用：查询当前 userId 的购买记录。\n原理：因为传入了 participantsKey（这个活动的用户购买记录）和 userId（这个用户），就可以根据 userId 在 participantsKey 里面查出对应的用户购买记录。\n3. 限购校验 1 2 3 if userBought + quantity \u0026gt; perUserLimit then return {0, \u0026#34;超过个人限购\u0026#34;} end 判断逻辑：用户目前已购买数 + 新购买数 quantity 是否大于最大购买量 perUserLimit。\n如果是，返回 {0, \u0026quot;超过个人限购\u0026quot;} 如果不是，继续下一步 4. 库存校验 1 2 3 if stock \u0026lt; quantity then return {0, \u0026#34;库存不足\u0026#34;} end 检查库存是否足够，如果不够，则返回 {0, \u0026quot;库存不足\u0026quot;}。\n5. 执行购买操作 1 2 3 4 5 -- 扣减库存 redis.call(\u0026#34;DECRBY\u0026#34;, KEYS[1], quantity) -- 记录用户购买数量 redis.call(\u0026#34;HINCRBY\u0026#34;, KEYS[2], userId, quantity) 如果库存足够，则：\n扣减库存：DECRBY 命令将库存减少 quantity 数量 记录用户购买数量：HINCRBY 命令将用户的购买记录增加 quantity 数量 6. 返回成功 1 return {1, \u0026#34;成功\u0026#34;} 最后返回 {1, \u0026quot;成功\u0026quot;}，表示购买成功。\n五、执行流程示例 我们以用户 12345 参与活动 1001 为例，假设初始库存为 10，限购为 3：\n第一次购买（买 2 件） 输入参数：\nKEYS[1] = seckill:stock:1001 KEYS[2] = seckill:participants:1001 ARGV[1] = \u0026quot;12345\u0026quot; ARGV[2] = \u0026quot;2\u0026quot; ARGV[3] = \u0026quot;3\u0026quot; 脚本执行：\nuserBought = 0（没买过） stock = 10，足够 扣减库存：DECRBY seckill:stock:1001 2 → 库存变 8 更新购买记录：HINCRBY seckill:participants:1001 12345 2 → 用户买了 2 件 返回 {1, \u0026quot;成功\u0026quot;} 第二次购买（再买 2 件） 输入参数：\nARGV[1] = \u0026quot;12345\u0026quot; ARGV[2] = \u0026quot;2\u0026quot; ARGV[3] = \u0026quot;3\u0026quot; 脚本执行：\nuserBought = 2（上次买了 2 件） 本次要买 2 件，总数 = 4 \u0026gt; 限购 3 返回 {0, \u0026quot;超过个人限购\u0026quot;} 六、核心优势 通过 Redis Key 设计 + Lua 脚本原子执行，我们实现了以下目标：\n1. 防止超卖 库存扣减和用户购买记录更新在同一个脚本里完成，保证了原子性。\n2. 限购控制 利用哈希表存储用户购买记录，结合 Lua 脚本校验，避免了用户绕过限购。\n3. 高并发性能 逻辑全部在 Redis 内部执行，不依赖数据库事务，性能极高。\n4. 数据一致性 Lua 脚本的原子性保证了所有操作要么全部成功，要么全部失败。\n七、实际应用场景 这种方式是很多电商平台在秒杀场景中的标准做法，也是分布式系统里常见的\u0026quot;数据库削峰\u0026quot;与\u0026quot;Redis 限流\u0026quot;的结合应用。\n适用场景 秒杀活动 限时抢购 限量商品销售 优惠券发放 积分兑换 技术特点 高性能：Redis 内存操作，响应速度快 原子性：Lua 脚本保证操作原子性 可扩展：支持分布式部署 可靠性：避免超卖和重复购买 八、延伸思考 1. 退款退货支持 如果要支持退款退货，需要在 Lua 脚本里增加库存回滚逻辑：\n1 2 3 4 -- 退款时回滚库存 redis.call(\u0026#34;INCRBY\u0026#34;, KEYS[1], quantity) -- 减少用户购买记录 redis.call(\u0026#34;HINCRBY\u0026#34;, KEYS[2], userId, -quantity) 2. 分片存储优化 如果活动商品数量非常大，可以考虑分片存储库存，进一步提高并发性能：\n1 2 -- 根据用户ID进行分片 local shardKey = \u0026#34;seckill:stock:\u0026#34; .. activityId .. \u0026#34;:\u0026#34; .. (userId % 10) 3. 异步处理 在真实生产环境中，还需要配合消息队列（MQ）和异步下单，以保证后续数据库写入的可靠性。\n4. 监控和告警 监控 Redis 性能指标 设置库存告警阈值 记录用户购买行为日志 九、总结 Redis + Lua 脚本在秒杀系统中的应用，通过以下方式解决了高并发场景下的核心问题：\n利用 Redis 的高性能：将核心逻辑从数据库转移到内存 保证操作的原子性：Lua 脚本确保所有操作要么全部成功，要么全部失败 实现精确的限购控制：通过哈希表记录用户购买历史 避免超卖问题：库存扣减和用户记录更新在同一脚本中完成 这种方案不仅适用于秒杀系统，在需要高并发、强一致性的场景中都有广泛应用价值。\n以上就是关于秒杀系统中 Redis + Lua 脚本的完整应用解析。通过深入理解这些核心概念，你就能在实际项目中灵活运用这些技术，构建出高性能、高可靠的分布式系统。\n","date":"2025-09-14T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-redis--lua-%E5%9C%A8%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","title":"深入理解 Redis + Lua 在秒杀系统中的应用"},{"content":"基于 Session 的短信登录完整解析 在现代 Web 应用中，短信验证码登录 是一种非常常见的无密码认证方式。它的好处是简单、安全，用户只需要输入手机号和验证码即可登录，而不用记复杂的密码。\n很多初学者在实现时会有疑惑：验证码存哪？怎么比对？登录状态如何保持？ 这篇文章将通过推导的方式，逐步解释清楚，并给出完整的代码示例。\n一、为什么需要 Session 要理解短信登录，必须先搞清楚 Session 的概念。\nHTTP 协议的一个最大特点是：无状态。\n这意味着每一次请求，服务器都不会记得你是谁。\n但是在实际应用里，我们需要：\n登录之后，保持登录状态 购物车内容能够一直保存 验证码发送后，能够正确地校验 这时候就需要 Session。\n1.1 Session 的类比 你可以把 Session 想象成服务器给用户开的一间小储物柜：\n当用户第一次访问时，服务器（tomcat）分配一个储物柜（Session），并生成一个唯一编号（Session ID） 服务器把这个编号写在一张小纸条上（Cookie），交给浏览器（客户端）保存 以后浏览器每次访问时，都会带上这张小纸条 服务器根据纸条上的编号，就能找到对应的储物柜，从里面取出属于该用户的数据 1.2 Session vs Cookie 特性 Cookie（小纸条） Session（储物柜） 存储位置 浏览器端 服务器端 安全性 较低（容易被篡改） 较高（由服务器维护） 容量 4KB 左右 取决于服务器内存 生命周期 可设置长时间保存 默认随浏览器关闭或超时清除 二、短信登录的推导过程 现在我们把 Session 的原理放到 短信验证码登录 的场景中，来一步步推导。\n2.1 用户提交手机号 用户在前端页面输入手机号 前端把手机号发送给后端 2.2 服务器生成验证码 后端生成一个 6 位随机数（例如 123456） 把这个验证码保存到 Session 储物柜 里 同时调用短信服务商的 API，把验证码发送到用户手机 此时，Session 中保存的是： key = \u0026ldquo;SMS_CODE_手机号\u0026rdquo; value = \u0026ldquo;123456\u0026rdquo;\n2.3 用户输入验证码登录 用户收到验证码，在页面输入 浏览器在发起请求时，会自动带上 Session ID 的小纸条（Cookie） 后端根据 Session ID 找到储物柜，从中取出验证码 比对用户输入的验证码与 Session 中保存的验证码 一致 ✅ → 登录成功 不一致 ❌ → 登录失败 三、代码实现示例（Spring Boot） 接下来用 Java + Spring Boot 来实现一个最简化的 基于 Session 的短信登录。\n3.1 发送验证码接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @RestController @RequestMapping(\u0026#34;/auth\u0026#34;) public class SmsLoginController { @PostMapping(\u0026#34;/sendCode\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; sendCode(@RequestParam String phone, HttpSession session) { // 生成 6 位验证码 String code = String.valueOf((int)((Math.random() * 9 + 1) * 100000)); // 模拟发送短信（真实情况需接入短信服务商 API） System.out.println(\u0026#34;向手机号 \u0026#34; + phone + \u0026#34; 发送验证码：\u0026#34; + code); // 保存到 session session.setAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone, code); session.setAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone, System.currentTimeMillis()); return ResponseEntity.ok(\u0026#34;验证码已发送\u0026#34;); } } 说明： 验证码保存在 Session 中，不存前端 建议同时保存验证码生成时间，方便后续判断是否过期\n3.2 验证登录接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @PostMapping(\u0026#34;/login\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; login(@RequestParam String phone, @RequestParam String code, HttpSession session) { String sessionCode = (String) session.getAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone); Long codeTime = (Long) session.getAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone); if (sessionCode == null) { return ResponseEntity.status(400).body(\u0026#34;验证码未发送或已过期\u0026#34;); } // 验证是否过期（5分钟有效） if (System.currentTimeMillis() - codeTime \u0026gt; 5 * 60 * 1000) { session.removeAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone); session.removeAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone); return ResponseEntity.status(400).body(\u0026#34;验证码已过期\u0026#34;); } if (!sessionCode.equals(code)) { return ResponseEntity.status(400).body(\u0026#34;验证码错误\u0026#34;); } // 登录成功，写入用户登录状态 session.setAttribute(\u0026#34;LOGIN_USER\u0026#34;, phone); // 清理验证码 session.removeAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone); session.removeAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone); return ResponseEntity.ok(\u0026#34;登录成功\u0026#34;); } 说明： 核心逻辑在 后端比对，前端只负责收集输入 验证码过期机制必须有，防止重复使用\n3.3 获取当前登录用户接口 1 2 3 4 5 6 7 8 @GetMapping(\u0026#34;/me\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; getUser(HttpSession session) { String phone = (String) session.getAttribute(\u0026#34;LOGIN_USER\u0026#34;); if (phone == null) { return ResponseEntity.status(401).body(\u0026#34;未登录\u0026#34;); } return ResponseEntity.ok(\u0026#34;当前登录用户：\u0026#34; + phone); } 四、关键点总结 1.Session 是储物柜，Cookie 是储物柜的取件凭证证 验证码存放在 Session（服务器端），不存浏览器 浏览器只保留 Session ID（Cookie） 2.比对逻辑必须在后端完成 前端只负责收集和提交手机号、验证码 服务器根据 Session 找到验证码并比对，决定是否登录 3.安全性措施 验证码要有过期时间（一般 5 分钟） 验证码要有发送频率限制，防止被恶意刷 五、流程回顾 让我们回顾整个短信登录的过程： 1.用户输入手机号 2.服务器生成验证码，存到 Session，并通过短信发送 3.用户收到验证码，输入到前端页面 4.浏览器请求时带上 Cookie（Session ID） 5.服务器用 Session ID 找到储物柜，取出验证码进行比对 一致 → 登录成功； 不一致/过期 → 登录失败 6.扩展思考 在实际生产环境中，Session 可能存放在 Redis 里，以便支持分布式部署。\n另外，也可以替代 Session，用 JWT（JSON Web Token） 实现无状态的登录。 但核心思想是一致的：\n验证码必须在后端保存和比对 前端只负责展示和输入 7.结语 通过上面的推导，我们把“短信登录”这个常见需求，完整地拆解成了 业务流程 + Session 原理 + 实现代码。\n如果你刚开始学习后端开发，希望你能从这篇文章中真正理解：\n为什么要用 Session 短信验证码应该存放在哪里 验证逻辑为什么要在后端 这样，不管是做一个小 demo，还是将来应对生产级的项目，你都能举一反三。\n","date":"2025-08-26T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/%E5%9F%BA%E4%BA%8E-session-%E7%9A%84%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E5%AE%8C%E6%95%B4%E8%A7%A3%E6%9E%90/","title":"基于 Session 的短信登录完整解析"},{"content":"秒杀活动功能完善指南 - 第一部分 目录 项目概述 数据库设计 后端核心功能实现 项目概述 功能目标 实现高并发的秒杀活动系统 防止超卖和重复参与 支持分布式部署 提供用户友好的界面 技术栈 后端: Spring Boot + MyBatis + Redis + Redisson 前端: Vue.js + Element UI 数据库: MySQL 缓存: Redis 分布式锁: Redisson 数据库设计 1. 秒杀参与记录表 1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TABLE seckill_participant ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;主键ID\u0026#39;, activity_id BIGINT NOT NULL COMMENT \u0026#39;秒杀活动ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, quantity INT NOT NULL COMMENT \u0026#39;参与数量\u0026#39;, status TINYINT(1) DEFAULT 0 COMMENT \u0026#39;状态：0-待处理，1-成功，2-失败\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (id), UNIQUE KEY uk_user_activity (user_id, activity_id), KEY idx_activity_id (activity_id), KEY idx_user_id (user_id) ) COMMENT=\u0026#39;秒杀参与记录表\u0026#39;; 2. 秒杀订单表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE seckill_order ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;主键ID\u0026#39;, activity_id BIGINT NOT NULL COMMENT \u0026#39;秒杀活动ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, dish_id BIGINT NOT NULL COMMENT \u0026#39;商品ID\u0026#39;, quantity INT NOT NULL COMMENT \u0026#39;购买数量\u0026#39;, seckill_price DECIMAL(10,2) NOT NULL COMMENT \u0026#39;秒杀价格\u0026#39;, total_amount DECIMAL(10,2) NOT NULL COMMENT \u0026#39;总金额\u0026#39;, status TINYINT(1) DEFAULT 0 COMMENT \u0026#39;订单状态：0-待支付，1-已支付，2-已取消\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (id), KEY idx_activity_id (activity_id), KEY idx_user_id (user_id) ) COMMENT=\u0026#39;秒杀订单表\u0026#39;; 3. 库存扣减记录表 1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TABLE seckill_stock_log ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;主键ID\u0026#39;, activity_id BIGINT NOT NULL COMMENT \u0026#39;秒杀活动ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, quantity INT NOT NULL COMMENT \u0026#39;扣减数量\u0026#39;, before_stock INT NOT NULL COMMENT \u0026#39;扣减前库存\u0026#39;, after_stock INT NOT NULL COMMENT \u0026#39;扣减后库存\u0026#39;, status TINYINT(1) DEFAULT 1 COMMENT \u0026#39;状态：1-成功，0-失败\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, PRIMARY KEY (id), KEY idx_activity_id (activity_id), KEY idx_user_id (user_id) ) COMMENT=\u0026#39;库存扣减记录表\u0026#39;; 后端核心功能实现 1. 创建实体类 1.1 秒杀参与记录实体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 文件路径: sky-pojo/src/main/java/com/sky/entity/SeckillParticipant.java package com.sky.entity; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.time.LocalDateTime; @Data @Builder @NoArgsConstructor @AllArgsConstructor public class SeckillParticipant implements Serializable { private static final long serialVersionUID = 1L; private Long id; private Long activityId; private Long userId; private Integer quantity; private Integer status; private LocalDateTime createTime; private LocalDateTime updateTime; } 1.2 秒杀订单实体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 文件路径: sky-pojo/src/main/java/com/sky/entity/SeckillOrder.java package com.sky.entity; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.math.BigDecimal; import java.time.LocalDateTime; @Data @Builder @NoArgsConstructor @AllArgsConstructor public class SeckillOrder implements Serializable { private static final long serialVersionUID = 1L; private Long id; private Long activityId; private Long userId; private Long dishId; private Integer quantity; private BigDecimal seckillPrice; private BigDecimal totalAmount; private Integer status; private LocalDateTime createTime; private LocalDateTime updateTime; } 2. 创建DTO类 2.1 秒杀参与DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 文件路径: sky-pojo/src/main/java/com/sky/dto/SeckillParticipateDTO.java package com.sky.dto; import lombok.Data; import java.io.Serializable; @Data public class SeckillParticipateDTO implements Serializable { private static final long serialVersionUID = 1L; private Long activityId; private Long userId; private Integer quantity; } 3. 创建Mapper接口 3.1 秒杀参与记录Mapper 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 文件路径: sky-server/src/main/java/com/sky/mapper/SeckillParticipantMapper.java package com.sky.mapper; import com.sky.entity.SeckillParticipant; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; @Mapper public interface SeckillParticipantMapper { void insert(SeckillParticipant participant); SeckillParticipant getByUserAndActivity(@Param(\u0026#34;userId\u0026#34;) Long userId, @Param(\u0026#34;activityId\u0026#34;) Long activityId); void updateStatus(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;status\u0026#34;) Integer status); } 3.2 秒杀订单Mapper 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 文件路径: sky-server/src/main/java/com/sky/mapper/SeckillOrderMapper.java package com.sky.mapper; import com.sky.entity.SeckillOrder; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; @Mapper public interface SeckillOrderMapper { void insert(SeckillOrder order); SeckillOrder getById(@Param(\u0026#34;id\u0026#34;) Long id); void updateStatus(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;status\u0026#34;) Integer status); } 4. 创建Mapper XML文件 4.1 秒杀参与记录Mapper XML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!-- 文件路径: sky-server/src/main/resources/mapper/SeckillParticipantMapper.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.SeckillParticipantMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; INSERT INTO seckill_participant (activity_id, user_id, quantity, status, create_time, update_time) VALUES (#{activityId}, #{userId}, #{quantity}, #{status}, #{createTime}, #{updateTime}) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;getByUserAndActivity\u0026#34; resultType=\u0026#34;com.sky.entity.SeckillParticipant\u0026#34;\u0026gt; SELECT * FROM seckill_participant WHERE user_id = #{userId} AND activity_id = #{activityId} \u0026lt;/select\u0026gt; \u0026lt;update id=\u0026#34;updateStatus\u0026#34;\u0026gt; UPDATE seckill_participant SET status = #{status}, update_time = NOW() WHERE id = #{id} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; 4.2 秒杀订单Mapper XML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!-- 文件路径: sky-server/src/main/resources/mapper/SeckillOrderMapper.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.SeckillOrderMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; INSERT INTO seckill_order (activity_id, user_id, dish_id, quantity, seckill_price, total_amount, status, create_time, update_time) VALUES (#{activityId}, #{userId}, #{dishId}, #{quantity}, #{seckillPrice}, #{totalAmount}, #{status}, #{createTime}, #{updateTime}) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;getById\u0026#34; resultType=\u0026#34;com.sky.entity.SeckillOrder\u0026#34;\u0026gt; SELECT * FROM seckill_order WHERE id = #{id} \u0026lt;/select\u0026gt; \u0026lt;update id=\u0026#34;updateStatus\u0026#34;\u0026gt; UPDATE seckill_order SET status = #{status}, update_time = NOW() WHERE id = #{id} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; 5. 创建Lua脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 -- 文件路径: sky-server/src/main/resources/seckill_participate.lua -- 秒杀参与Lua脚本 -- KEYS[1] = seckill:stock:{activityId} -- KEYS[2] = seckill:participants:{activityId} -- ARGV[1] = userId -- ARGV[2] = quantity -- ARGV[3] = perUserLimit -- 检查用户是否已参与 local isParticipated = redis.call(\u0026#39;SISMEMBER\u0026#39;, KEYS[2], ARGV[1]) if isParticipated == 1 then return {0, \u0026#39;用户已参与该活动\u0026#39;} end -- 检查库存是否充足 local stock = redis.call(\u0026#39;GET\u0026#39;, KEYS[1]) if not stock then return {0, \u0026#39;活动不存在\u0026#39;} end stock = tonumber(stock) local quantity = tonumber(ARGV[2]) local perUserLimit = tonumber(ARGV[3]) if stock \u0026lt; quantity then return {0, \u0026#39;库存不足\u0026#39;} end if quantity \u0026gt; perUserLimit then return {0, \u0026#39;超过限购数量\u0026#39;} end -- 扣减库存 local newStock = redis.call(\u0026#39;DECRBY\u0026#39;, KEYS[1], quantity) if newStock \u0026lt; 0 then -- 回滚库存 redis.call(\u0026#39;INCRBY\u0026#39;, KEYS[1], quantity) return {0, \u0026#39;库存不足\u0026#39;} end -- 记录用户参与 redis.call(\u0026#39;SADD\u0026#39;, KEYS[2], ARGV[1]) -- 设置过期时间（活动结束后清理） redis.call(\u0026#39;EXPIRE\u0026#39;, KEYS[2], 86400) return {1, \u0026#39;参与成功\u0026#39;, newStock} 6. 增强SeckillActivityService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 // 在 SeckillActivityServiceImpl.java 中添加以下方法 @Autowired private RedisTemplate redisTemplate; @Autowired private RedissonClient redissonClient; @Autowired private SeckillParticipantMapper seckillParticipantMapper; @Autowired private SeckillOrderMapper seckillOrderMapper; @Value(\u0026#34;${sky.redis.seckill.prefix:seckill:}\u0026#34;) private String seckillPrefix; /** * 参与秒杀活动 */ @Override public String participateSeckill(Long activityId, Long userId, Integer quantity) { // 1. 获取活动信息 SeckillActivity activity = getById(activityId); if (activity == null) { return \u0026#34;活动不存在\u0026#34;; } // 2. 检查活动状态 if (activity.getStatus() != 1) { return \u0026#34;活动已禁用\u0026#34;; } LocalDateTime now = LocalDateTime.now(); if (now.isBefore(activity.getStartTime())) { return \u0026#34;活动未开始\u0026#34;; } if (now.isAfter(activity.getEndTime())) { return \u0026#34;活动已结束\u0026#34;; } // 3. 使用分布式锁防止重复参与 String lockKey = seckillPrefix + \u0026#34;lock:\u0026#34; + activityId; RLock lock = redissonClient.getLock(lockKey); try { if (lock.tryLock(10, 30, TimeUnit.SECONDS)) { // 4. 执行Lua脚本 String stockKey = seckillPrefix + \u0026#34;stock:\u0026#34; + activityId; String participantsKey = seckillPrefix + \u0026#34;participants:\u0026#34; + activityId; DefaultRedisScript\u0026lt;List\u0026gt; script = new DefaultRedisScript\u0026lt;\u0026gt;(); script.setScriptSource(new ResourceScriptSource(new ClassPathResource(\u0026#34;seckill_participate.lua\u0026#34;))); script.setResultType(List.class); List\u0026lt;String\u0026gt; keys = Arrays.asList(stockKey, participantsKey); List\u0026lt;Object\u0026gt; args = Arrays.asList(userId.toString(), quantity.toString(), activity.getPerUserLimit().toString()); List result = redisTemplate.execute(script, keys, args.toArray()); if (result != null \u0026amp;\u0026amp; result.size() \u0026gt; 0) { Integer success = (Integer) result.get(0); if (success == 1) { // 5. 记录参与记录 SeckillParticipant participant = SeckillParticipant.builder() .activityId(activityId) .userId(userId) .quantity(quantity) .status(1) .createTime(now) .updateTime(now) .build(); seckillParticipantMapper.insert(participant); // 6. 异步处理订单 processSeckillOrderAsync(activity, userId, quantity); return \u0026#34;参与成功\u0026#34;; } else { return (String) result.get(1); } } return \u0026#34;参与失败\u0026#34;; } else { return \u0026#34;系统繁忙，请稍后重试\u0026#34;; } } catch (Exception e) { log.error(\u0026#34;参与秒杀活动异常\u0026#34;, e); return \u0026#34;参与失败，请重试\u0026#34;; } finally { if (lock.isHeldByCurrentThread()) { lock.unlock(); } } } /** * 异步处理秒杀订单 */ @Async public void processSeckillOrderAsync(SeckillActivity activity, Long userId, Integer quantity) { try { // 创建秒杀订单 SeckillOrder order = SeckillOrder.builder() .activityId(activity.getId()) .userId(userId) .dishId(activity.getDishId()) .quantity(quantity) .seckillPrice(activity.getSeckillPrice()) .totalAmount(activity.getSeckillPrice().multiply(new BigDecimal(quantity))) .status(0) .createTime(LocalDateTime.now()) .updateTime(LocalDateTime.now()) .build(); seckillOrderMapper.insert(order); // 更新数据库库存 updateDatabaseStock(activity.getId(), quantity); log.info(\u0026#34;秒杀订单创建成功：orderId={}, userId={}, activityId={}\u0026#34;, order.getId(), userId, activity.getId()); } catch (Exception e) { log.error(\u0026#34;处理秒杀订单异常\u0026#34;, e); } } /** * 更新数据库库存 */ @Async public void updateDatabaseStock(Long activityId, Integer quantity) { try { seckillActivityMapper.reduceStock(activityId, quantity); seckillActivityMapper.increaseSoldCount(activityId, quantity); } catch (Exception e) { log.error(\u0026#34;更新数据库库存异常\u0026#34;, e); } } 7. 创建用户端控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 文件路径: sky-server/src/main/java/com/sky/controller/user/SeckillActivityController.java package com.sky.controller.user; import com.sky.entity.SeckillActivity; import com.sky.result.Result; import com.sky.service.SeckillActivityService; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(\u0026#34;/user/seckill/activity\u0026#34;) @Api(tags = \u0026#34;用户端秒杀活动\u0026#34;) @Slf4j public class SeckillActivityController { @Autowired private SeckillActivityService seckillActivityService; @GetMapping(\u0026#34;/current\u0026#34;) @ApiOperation(\u0026#34;获取当前进行中的秒杀活动\u0026#34;) public Result\u0026lt;List\u0026lt;SeckillActivity\u0026gt;\u0026gt; getCurrentActivities() { log.info(\u0026#34;获取当前进行中的秒杀活动\u0026#34;); List\u0026lt;SeckillActivity\u0026gt; activities = seckillActivityService.getCurrentActivities(); return Result.success(activities); } @GetMapping(\u0026#34;/{id}\u0026#34;) @ApiOperation(\u0026#34;根据id查询秒杀活动详情\u0026#34;) public Result\u0026lt;SeckillActivity\u0026gt; getById(@PathVariable Long id) { log.info(\u0026#34;根据id查询秒杀活动详情：{}\u0026#34;, id); SeckillActivity seckillActivity = seckillActivityService.getById(id); return Result.success(seckillActivity); } @PostMapping(\u0026#34;/participate/{id}\u0026#34;) @ApiOperation(\u0026#34;参与秒杀活动\u0026#34;) public Result\u0026lt;String\u0026gt; participateSeckill(@PathVariable Long id, @RequestParam Integer quantity) { log.info(\u0026#34;用户参与秒杀活动：id={}, quantity={}\u0026#34;, id, quantity); // 这里需要从JWT中获取用户ID，暂时使用固定值 Long userId = 1L; // 实际项目中从JWT中获取 String result = seckillActivityService.participateSeckill(id, userId, quantity); return Result.success(result); } } 总结 第一部分涵盖了秒杀活动功能的核心后端实现，包括：\n数据库设计 - 完整的表结构和索引设计 实体类创建 - 秒杀参与记录和订单实体 数据访问层 - Mapper接口和XML配置 核心业务逻辑 - 分布式锁、Redis缓存、Lua脚本 API接口 - 用户端控制器 这些是构建高并发秒杀系统的基础，下一部分将介绍前端界面开发和微信小程序集成。\n继续阅读：秒杀活动功能完善指南 - 第二部分\n","date":"2025-01-12T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84%E6%8C%87%E5%8D%97-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/","title":"秒杀活动功能完善指南 - 第一部分"},{"content":"秒杀活动功能完善指南 - 第二部分 目录 前端界面开发 微信小程序集成 测试和优化 GitHub Pages 部署指南 前端界面开发 1. 创建秒杀活动API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 文件路径: src/api/seckill.js import request from \u0026#39;@/utils/request\u0026#39; export const seckillApi = { // 获取当前进行中的秒杀活动 getCurrentActivities() { return request({ url: \u0026#39;/user/seckill/activity/current\u0026#39;, method: \u0026#39;get\u0026#39; }) }, // 获取秒杀活动详情 getActivityDetail(id) { return request({ url: `/user/seckill/activity/${id}`, method: \u0026#39;get\u0026#39; }) }, // 参与秒杀活动 participateSeckill(id, quantity) { return request({ url: `/user/seckill/activity/participate/${id}`, method: \u0026#39;post\u0026#39;, params: { quantity } }) } } 2. 创建秒杀活动页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 \u0026lt;!-- 文件路径: src/views/seckill/index.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;seckill-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;seckill-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;限时秒杀\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;抢购火爆商品，限时特价\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;seckill-content\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;activity in activities\u0026#34; :key=\u0026#34;activity.id\u0026#34; class=\u0026#34;seckill-item\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-info\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;activity.dishImage\u0026#34; :alt=\u0026#34;activity.dishName\u0026#34; class=\u0026#34;product-image\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-details\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{ activity.dishName }}\u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;product-desc\u0026#34;\u0026gt;{{ activity.description }}\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;price-info\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;original-price\u0026#34;\u0026gt;¥{{ activity.originalPrice }}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;seckill-price\u0026#34;\u0026gt;¥{{ activity.seckillPrice }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;seckill-info\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;stock-info\u0026#34;\u0026gt; \u0026lt;span\u0026gt;库存：{{ activity.stock - activity.soldCount }}/{{ activity.stock }}\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;progress-bar\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress\u0026#34; :style=\u0026#34;{ width: getStockPercent(activity) + \u0026#39;%\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;time-info\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;getActivityStatus(activity) === \u0026#39;not-started\u0026#39;\u0026#34; class=\u0026#34;countdown\u0026#34;\u0026gt; \u0026lt;span\u0026gt;距离开始：\u0026lt;/span\u0026gt; \u0026lt;countdown :end-time=\u0026#34;activity.startTime\u0026#34; @finish=\u0026#34;onCountdownFinish\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;getActivityStatus(activity) === \u0026#39;ended\u0026#39;\u0026#34; class=\u0026#34;ended\u0026#34;\u0026gt; 活动已结束 \u0026lt;/div\u0026gt; \u0026lt;div v-else class=\u0026#34;countdown\u0026#34;\u0026gt; \u0026lt;span\u0026gt;距离结束：\u0026lt;/span\u0026gt; \u0026lt;countdown :end-time=\u0026#34;activity.endTime\u0026#34; @finish=\u0026#34;onCountdownFinish\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;action-area\u0026#34;\u0026gt; \u0026lt;el-button v-if=\u0026#34;getActivityStatus(activity) === \u0026#39;active\u0026#39;\u0026#34; type=\u0026#34;danger\u0026#34; size=\u0026#34;large\u0026#34; :disabled=\u0026#34;!canParticipate(activity)\u0026#34; @click=\u0026#34;participateSeckill(activity)\u0026#34; \u0026gt; 立即抢购 \u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else disabled size=\u0026#34;large\u0026#34;\u0026gt; {{ getButtonText(activity) }} \u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { seckillApi } from \u0026#39;@/api/seckill\u0026#39; import Countdown from \u0026#39;@/components/Countdown\u0026#39; export default { name: \u0026#39;SeckillActivity\u0026#39;, components: { Countdown }, data() { return { activities: [], loading: false } }, created() { this.getCurrentActivities() }, methods: { async getCurrentActivities() { this.loading = true try { const response = await seckillApi.getCurrentActivities() if (response.data.code === 1) { this.activities = response.data.data } } catch (error) { console.error(\u0026#39;获取秒杀活动失败\u0026#39;, error) } finally { this.loading = false } }, async participateSeckill(activity) { try { const response = await seckillApi.participateSeckill(activity.id, 1) if (response.data.code === 1) { this.$message.success(response.data.data) this.getCurrentActivities() // 刷新列表 } else { this.$message.error(response.data.msg) } } catch (error) { console.error(\u0026#39;参与秒杀失败\u0026#39;, error) this.$message.error(\u0026#39;参与失败，请重试\u0026#39;) } }, getActivityStatus(activity) { const now = new Date() const startTime = new Date(activity.startTime) const endTime = new Date(activity.endTime) if (now \u0026lt; startTime) return \u0026#39;not-started\u0026#39; if (now \u0026gt; endTime) return \u0026#39;ended\u0026#39; return \u0026#39;active\u0026#39; }, getStockPercent(activity) { return ((activity.stock - activity.soldCount) / activity.stock) * 100 }, canParticipate(activity) { return activity.stock \u0026gt; activity.soldCount \u0026amp;\u0026amp; activity.status === 1 }, getButtonText(activity) { const status = this.getActivityStatus(activity) switch (status) { case \u0026#39;not-started\u0026#39;: return \u0026#39;未开始\u0026#39; case \u0026#39;ended\u0026#39;: return \u0026#39;已结束\u0026#39; default: return \u0026#39;立即抢购\u0026#39; } }, onCountdownFinish() { this.getCurrentActivities() } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .seckill-container { padding: 20px; } .seckill-header { text-align: center; margin-bottom: 30px; } .seckill-header h2 { color: #f56c6c; font-size: 28px; margin-bottom: 10px; } .seckill-content { display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px; } .seckill-item { border: 1px solid #e4e7ed; border-radius: 8px; padding: 20px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } .product-info { display: flex; margin-bottom: 15px; } .product-image { width: 80px; height: 80px; object-fit: cover; border-radius: 4px; margin-right: 15px; } .product-details h3 { margin: 0 0 8px 0; font-size: 16px; color: #303133; } .product-desc { color: #909399; font-size: 12px; margin: 0 0 10px 0; } .price-info { display: flex; align-items: center; gap: 10px; } .original-price { text-decoration: line-through; color: #909399; font-size: 14px; } .seckill-price { color: #f56c6c; font-size: 18px; font-weight: bold; } .seckill-info { border-top: 1px solid #f0f0f0; padding-top: 15px; } .stock-info { margin-bottom: 10px; } .progress-bar { width: 100%; height: 6px; background: #f0f0f0; border-radius: 3px; overflow: hidden; margin-top: 5px; } .progress { height: 100%; background: linear-gradient(90deg, #f56c6c, #ff9a9a); transition: width 0.3s ease; } .time-info { margin-bottom: 15px; text-align: center; } .countdown { color: #f56c6c; font-weight: bold; } .ended { color: #909399; } .action-area { text-align: center; } .action-area .el-button { width: 100%; } \u0026lt;/style\u0026gt; 3. 创建倒计时组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 \u0026lt;!-- 文件路径: src/components/Countdown.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;span class=\u0026#34;countdown\u0026#34;\u0026gt; {{ formattedTime }} \u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;Countdown\u0026#39;, props: { endTime: { type: String, required: true } }, data() { return { timeLeft: 0, timer: null } }, computed: { formattedTime() { const hours = Math.floor(this.timeLeft / 3600) const minutes = Math.floor((this.timeLeft % 3600) / 60) const seconds = this.timeLeft % 60 return `${hours.toString().padStart(2, \u0026#39;0\u0026#39;)}:${minutes.toString().padStart(2, \u0026#39;0\u0026#39;)}:${seconds.toString().padStart(2, \u0026#39;0\u0026#39;)}` } }, mounted() { this.startCountdown() }, beforeDestroy() { this.clearTimer() }, methods: { startCountdown() { this.updateTimeLeft() this.timer = setInterval(() =\u0026gt; { this.updateTimeLeft() }, 1000) }, updateTimeLeft() { const now = new Date().getTime() const end = new Date(this.endTime).getTime() this.timeLeft = Math.max(0, Math.floor((end - now) / 1000)) if (this.timeLeft \u0026lt;= 0) { this.clearTimer() this.$emit(\u0026#39;finish\u0026#39;) } }, clearTimer() { if (this.timer) { clearInterval(this.timer) this.timer = null } } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .countdown { font-family: \u0026#39;Courier New\u0026#39;, monospace; font-weight: bold; color: #f56c6c; } \u0026lt;/style\u0026gt; 微信小程序集成 1. 创建秒杀活动页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 \u0026lt;!-- 文件路径: pages/seckill/index.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;seckill-container\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;seckill-header\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;title\u0026#34;\u0026gt;限时秒杀\u0026lt;/text\u0026gt; \u0026lt;text class=\u0026#34;subtitle\u0026#34;\u0026gt;抢购火爆商品，限时特价\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;seckill-list\u0026#34;\u0026gt; \u0026lt;view v-for=\u0026#34;activity in activities\u0026#34; :key=\u0026#34;activity.id\u0026#34; class=\u0026#34;seckill-item\u0026#34;\u0026gt; \u0026lt;image :src=\u0026#34;activity.dishImage\u0026#34; class=\u0026#34;product-image\u0026#34; /\u0026gt; \u0026lt;view class=\u0026#34;product-info\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;product-name\u0026#34;\u0026gt;{{ activity.dishName }}\u0026lt;/text\u0026gt; \u0026lt;text class=\u0026#34;product-desc\u0026#34;\u0026gt;{{ activity.description }}\u0026lt;/text\u0026gt; \u0026lt;view class=\u0026#34;price-info\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;original-price\u0026#34;\u0026gt;¥{{ activity.originalPrice }}\u0026lt;/text\u0026gt; \u0026lt;text class=\u0026#34;seckill-price\u0026#34;\u0026gt;¥{{ activity.seckillPrice }}\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;seckill-action\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;stock-info\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;stock-text\u0026#34;\u0026gt;库存：{{ activity.stock - activity.soldCount }}/{{ activity.stock }}\u0026lt;/text\u0026gt; \u0026lt;view class=\u0026#34;progress-bar\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;progress\u0026#34; :style=\u0026#34;{ width: getStockPercent(activity) + \u0026#39;%\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;time-info\u0026#34;\u0026gt; \u0026lt;text v-if=\u0026#34;getActivityStatus(activity) === \u0026#39;not-started\u0026#39;\u0026#34; class=\u0026#34;countdown\u0026#34;\u0026gt; 距离开始：{{ getCountdown(activity.startTime) }} \u0026lt;/text\u0026gt; \u0026lt;text v-else-if=\u0026#34;getActivityStatus(activity) === \u0026#39;ended\u0026#39;\u0026#34; class=\u0026#34;ended\u0026#34;\u0026gt; 活动已结束 \u0026lt;/text\u0026gt; \u0026lt;text v-else class=\u0026#34;countdown\u0026#34;\u0026gt; 距离结束：{{ getCountdown(activity.endTime) }} \u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;button v-if=\u0026#34;getActivityStatus(activity) === \u0026#39;active\u0026#39;\u0026#34; class=\u0026#34;seckill-btn\u0026#34; :disabled=\u0026#34;!canParticipate(activity)\u0026#34; @click=\u0026#34;participateSeckill(activity)\u0026#34; \u0026gt; 立即抢购 \u0026lt;/button\u0026gt; \u0026lt;button v-else class=\u0026#34;seckill-btn disabled\u0026#34;\u0026gt; {{ getButtonText(activity) }} \u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { activities: [], loading: false } }, onLoad() { this.getCurrentActivities() }, methods: { async getCurrentActivities() { this.loading = true try { const response = await uni.request({ url: \u0026#39;http://localhost:8080/user/seckill/activity/current\u0026#39;, method: \u0026#39;GET\u0026#39; }) if (response.data.code === 1) { this.activities = response.data.data } } catch (error) { console.error(\u0026#39;获取秒杀活动失败\u0026#39;, error) uni.showToast({ title: \u0026#39;获取活动失败\u0026#39;, icon: \u0026#39;none\u0026#39; }) } finally { this.loading = false } }, async participateSeckill(activity) { try { const response = await uni.request({ url: `http://localhost:8080/user/seckill/activity/participate/${activity.id}`, method: \u0026#39;POST\u0026#39;, data: { quantity: 1 } }) if (response.data.code === 1) { uni.showToast({ title: response.data.data, icon: \u0026#39;success\u0026#39; }) this.getCurrentActivities() } else { uni.showToast({ title: response.data.msg, icon: \u0026#39;none\u0026#39; }) } } catch (error) { console.error(\u0026#39;参与秒杀失败\u0026#39;, error) uni.showToast({ title: \u0026#39;参与失败，请重试\u0026#39;, icon: \u0026#39;none\u0026#39; }) } }, getActivityStatus(activity) { const now = new Date() const startTime = new Date(activity.startTime) const endTime = new Date(activity.endTime) if (now \u0026lt; startTime) return \u0026#39;not-started\u0026#39; if (now \u0026gt; endTime) return \u0026#39;ended\u0026#39; return \u0026#39;active\u0026#39; }, getStockPercent(activity) { return ((activity.stock - activity.soldCount) / activity.stock) * 100 }, canParticipate(activity) { return activity.stock \u0026gt; activity.soldCount \u0026amp;\u0026amp; activity.status === 1 }, getButtonText(activity) { const status = this.getActivityStatus(activity) switch (status) { case \u0026#39;not-started\u0026#39;: return \u0026#39;未开始\u0026#39; case \u0026#39;ended\u0026#39;: return \u0026#39;已结束\u0026#39; default: return \u0026#39;立即抢购\u0026#39; } }, getCountdown(endTime) { const now = new Date().getTime() const end = new Date(endTime).getTime() const timeLeft = Math.max(0, end - now) const hours = Math.floor(timeLeft / (1000 * 60 * 60)) const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60)) const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000) return `${hours.toString().padStart(2, \u0026#39;0\u0026#39;)}:${minutes.toString().padStart(2, \u0026#39;0\u0026#39;)}:${seconds.toString().padStart(2, \u0026#39;0\u0026#39;)}` } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .seckill-container { padding: 20rpx; background: #f5f5f5; min-height: 100vh; } .seckill-header { text-align: center; margin-bottom: 30rpx; padding: 30rpx; background: #fff; border-radius: 10rpx; } .title { font-size: 36rpx; color: #f56c6c; font-weight: bold; display: block; margin-bottom: 10rpx; } .subtitle { font-size: 24rpx; color: #909399; } .seckill-item { background: #fff; border-radius: 10rpx; margin-bottom: 20rpx; padding: 20rpx; display: flex; align-items: center; } .product-image { width: 120rpx; height: 120rpx; border-radius: 8rpx; margin-right: 20rpx; } .product-info { flex: 1; } .product-name { font-size: 28rpx; color: #303133; font-weight: bold; display: block; margin-bottom: 10rpx; } .product-desc { font-size: 22rpx; color: #909399; display: block; margin-bottom: 15rpx; } .price-info { display: flex; align-items: center; } .original-price { text-decoration: line-through; color: #909399; font-size: 24rpx; margin-right: 15rpx; } .seckill-price { color: #f56c6c; font-size: 32rpx; font-weight: bold; } .seckill-action { width: 200rpx; text-align: center; } .stock-info { margin-bottom: 15rpx; } .stock-text { font-size: 20rpx; color: #606266; display: block; margin-bottom: 8rpx; } .progress-bar { width: 100%; height: 6rpx; background: #f0f0f0; border-radius: 3rpx; overflow: hidden; } .progress { height: 100%; background: linear-gradient(90deg, #f56c6c, #ff9a9a); transition: width 0.3s ease; } .time-info { margin-bottom: 15rpx; } .countdown { font-size: 20rpx; color: #f56c6c; font-weight: bold; } .ended { font-size: 20rpx; color: #909399; } .seckill-btn { width: 100%; height: 60rpx; background: #f56c6c; color: #fff; border: none; border-radius: 30rpx; font-size: 24rpx; font-weight: bold; } .seckill-btn.disabled { background: #c0c4cc; color: #fff; } \u0026lt;/style\u0026gt; 测试和优化 1. 功能测试 1.1 单元测试 测试秒杀参与逻辑 测试库存扣减 测试并发控制 1.2 集成测试 测试前后端接口 测试数据库操作 测试Redis缓存 1.3 压力测试 模拟高并发场景 测试系统性能 验证防超卖机制 2. 性能优化 2.1 缓存优化 合理设置缓存过期时间 使用缓存预热 避免缓存穿透 2.2 数据库优化 添加必要索引 优化SQL查询 使用连接池 2.3 系统优化 使用异步处理 合理设置线程池 监控系统资源 3. 监控告警 3.1 业务监控 秒杀参与成功率 库存变化趋势 用户参与行为 3.2 系统监控 Redis性能指标 数据库连接数 服务器资源使用 GitHub Pages 部署指南 1. 准备工作 1.1 创建GitHub仓库 1 2 # 在GitHub上创建一个新的仓库，命名为 yin123-ybh.github.io # 或者使用现有的仓库 1.2 克隆仓库到本地 1 2 git clone https://github.com/yin123-ybh/yin123-ybh.github.io.git cd yin123-ybh.github.io 2. 创建博客文章 2.1 创建文章目录结构 1 2 mkdir -p _posts/2024 mkdir -p assets/images 2.2 创建文章文件 1 2 3 4 5 # 将第一部分文章复制到_posts目录 cp \u0026#34;/Users/yin/Downloads/秒杀活动功能完善指南-第一部分.md\u0026#34; \u0026#34;_posts/2024/2024-01-15-秒杀活动功能完善指南-第一部分.md\u0026#34; # 将第二部分文章复制到_posts目录 cp \u0026#34;/Users/yin/Downloads/秒杀活动功能完善指南-第二部分.md\u0026#34; \u0026#34;_posts/2024/2024-01-15-秒杀活动功能完善指南-第二部分.md\u0026#34; 2.3 添加Jekyll Front Matter 在每个Markdown文件开头添加：\n1 2 3 4 5 6 7 8 --- layout: post title: \u0026#34;秒杀活动功能完善指南 - 第一部分\u0026#34; date: 2024-01-15 10:00:00 +0800 categories: [技术, 后端开发, 秒杀系统] tags: [Spring Boot, Redis, 分布式锁, 高并发] author: yin123-ybh --- 3. 配置Jekyll 3.1 创建_config.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 文件路径: _config.yml title: \u0026#34;Yin123的技术博客\u0026#34; description: \u0026#34;分享技术心得，记录成长历程\u0026#34; author: \u0026#34;yin123-ybh\u0026#34; email: \u0026#34;your-email@example.com\u0026#34; # 网站设置 url: \u0026#34;https://yin123-ybh.github.io\u0026#34; baseurl: \u0026#34;\u0026#34; # 构建设置 markdown: kramdown highlighter: rouge theme: minima # 插件 plugins: - jekyll-feed - jekyll-sitemap - jekyll-seo-tag # 分页 paginate: 5 paginate_path: \u0026#34;/page:num/\u0026#34; # 社交链接 github_username: yin123-ybh twitter_username: your_twitter 3.2 创建index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- 文件路径: index.html --\u0026gt; --- layout: default --- \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;page-heading\u0026#34;\u0026gt;最新文章\u0026lt;/h1\u0026gt; \u0026lt;ul class=\u0026#34;post-list\u0026#34;\u0026gt; {% for post in site.posts %} \u0026lt;li\u0026gt; \u0026lt;span class=\u0026#34;post-meta\u0026#34;\u0026gt;{{ post.date | date: \u0026#34;%Y-%m-%d\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;h2\u0026gt; \u0026lt;a class=\u0026#34;post-link\u0026#34; href=\u0026#34;{{ post.url | relative_url }}\u0026#34;\u0026gt;{{ post.title }}\u0026lt;/a\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{ post.excerpt | strip_html | truncate: 200 }}\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 4. 部署到GitHub Pages 4.1 提交代码 1 2 3 git add . git commit -m \u0026#34;添加秒杀活动功能完善指南\u0026#34; git push origin main 4.2 启用GitHub Pages 进入GitHub仓库设置页面 找到\u0026quot;Pages\u0026quot;选项 选择\u0026quot;Deploy from a branch\u0026quot; 选择\u0026quot;main\u0026quot;分支 选择\u0026quot;/ (root)\u0026ldquo;文件夹 点击\u0026quot;Save\u0026rdquo; 4.3 访问博客 等待几分钟后，访问：https://yin123-ybh.github.io\n5. 自定义主题（可选） 5.1 使用Jekyll主题 1 2 3 4 5 # 添加主题到Gemfile echo \u0026#34;gem \u0026#39;minima\u0026#39;\u0026#34; \u0026gt;\u0026gt; Gemfile # 或者使用其他主题 echo \u0026#34;gem \u0026#39;jekyll-theme-clean-blog\u0026#39;\u0026#34; \u0026gt;\u0026gt; Gemfile 5.2 自定义样式 创建_sass/custom.scss文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 自定义样式 .post-content { h1, h2, h3, h4, h5, h6 { color: #2c3e50; margin-top: 2em; margin-bottom: 1em; } code { background-color: #f8f9fa; padding: 2px 4px; border-radius: 3px; } pre { background-color: #f8f9fa; padding: 1em; border-radius: 5px; overflow-x: auto; } } 6. 自动化部署 6.1 使用GitHub Actions 创建.github/workflows/jekyll.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 name: Jekyll site CI on: push: branches: [ main ] pull_request: branches: [ main ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Ruby uses: actions/setup-ruby@v1 with: ruby-version: \u0026#39;2.7\u0026#39; - name: Install dependencies run: | gem install bundler bundle install - name: Build site run: bundle exec jekyll build - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./_site 总结 第二部分涵盖了秒杀活动功能的完整实现，包括：\n前端界面开发 - Vue.js管理界面和用户界面 微信小程序集成 - 移动端秒杀功能 测试和优化 - 功能测试和性能优化 GitHub Pages部署 - 完整的博客部署指南 通过这两部分指南，你可以：\n掌握高并发秒杀系统的核心技术 学会前后端分离开发 了解微信小程序开发 搭建个人技术博客 按照指南逐步实现，你就能构建出一个完整的秒杀活动系统，并将技术心得分享到博客上！\n返回阅读：秒杀活动功能完善指南 - 第一部分\n","date":"2025-01-12T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84%E6%8C%87%E5%8D%97-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/","title":"秒杀活动功能完善指南 - 第二部分"}]