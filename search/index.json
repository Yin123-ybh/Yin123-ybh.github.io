[{"content":"Redisson 可重入锁原理详解 1. 为什么需要可重入锁？ 在日常开发中，锁 是保证线程安全的重要手段。但有时候，一个线程在持有锁时，会调用另一个也需要同一把锁的方法，这时问题就来了：\n如果锁 不可重入，线程在第二次尝试加锁时会失败，因为锁已经存在，它相当于 把自己卡死了。 如果锁 可重入，同一个线程可以多次获取这把锁，直到最后释放时才真正解锁。 所以，可重入锁的意义在于：避免同一线程因为方法嵌套调用而死锁。\n2. 普通分布式锁的问题 最简单的分布式锁通常用 Redis 的 SETNX 实现：\n1 SET key value NX EX 30 NX 表示如果 key 不存在才设置，保证原子性。 EX 30 设置过期时间，防止死锁。 问题出在哪里？ 当一个线程已经持有锁时，如果在方法嵌套中再次尝试获取锁：\nRedis 发现 key 已存在，直接返回失败。 虽然是 同一个线程 想再次获取锁，但因为锁实现里只区分 \u0026ldquo;有锁 / 无锁\u0026rdquo;，并不会识别线程。 结果就是：自己把自己锁死了。 3. Redisson 的改进（可重入实现） Redisson 在 value 的存储上做了改进，它并不是简单的字符串，而是一个 Hash 结构：\n1 2 3 lockKey -\u0026gt; { threadId : reentrantCount } threadId：唯一标识某个 JVM 里的某个线程（一般是 UUID:threadId）。 reentrantCount：记录这个线程持有锁的次数。 这样就可以支持 可重入 了。\n4. 执行流程举例 假设我们有两个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void methodA() { lock.lock(); try { methodB(); } finally { lock.unlock(); } } public void methodB() { lock.lock(); try { // 执行逻辑 } finally { lock.unlock(); } } 4.1 第一次加锁（methodA） Redis 里还没有 lockKey。 Redisson 会写入： 1 lockKey -\u0026gt; { \u0026#34;UUID:thread-1\u0026#34; : 1 } 表示线程 thread-1 第一次获取锁，重入次数 = 1。 4.2 第二次加锁（methodB） Redis 发现 lockKey 已存在，但 owner 是 同一个线程。 允许重入，计数 +1： 1 lockKey -\u0026gt; { \u0026#34;UUID:thread-1\u0026#34; : 2 } 4.3 methodB 执行完释放锁 调用 unlock()，计数 -1： 1 lockKey -\u0026gt; { \u0026#34;UUID:thread-1\u0026#34; : 1 } 锁仍然由当前线程持有。 4.4 methodA 执行完释放锁 再次调用 unlock()，计数 -1 → 变成 0。 Redisson 删除 lockKey： 1 lockKey 删除 此时锁才真正释放，其他线程才有机会获取。 5. 通俗解释 用通俗的话再描述一次：\n假如一个线程调用多个方法时，第一个方法用了锁去调用第二个方法，第二个方法再次调用这个线程的锁就会失败。因为虽然锁的 key 一样，但是第二次获取锁的时候会发现锁已经存在了，就获取失败。\nRedisson 在这个基础上做了改进：它在锁的 value 里加上了一个 重入次数，并利用 Redis Hash 结构来存储。\nHash 结构里有两个值：\nfield：当前线程的标识（UUID + threadId） value：重入次数 执行过程是这样的：\n方法一第一次获取锁：重入次数 +1，变成 1 方法一调用方法二，方法二又要用锁：重入次数再 +1，变成 2 方法二执行完释放锁：重入次数 -1，变回 1 方法一执行完释放锁：重入次数 -1，变回 0，锁才真正释放 这样就避免了同一个线程因为嵌套调用而死锁。\n6. 核心实现原理 6.1 加锁流程 1 2 3 4 5 6 7 8 9 10 11 12 -- 加锁脚本 if (redis.call(\u0026#39;exists\u0026#39;, KEYS[1]) == 0) then redis.call(\u0026#39;hset\u0026#39;, KEYS[1], ARGV[2], 1); redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(\u0026#39;hexists\u0026#39;, KEYS[1], ARGV[2]) == 1) then redis.call(\u0026#39;hincrby\u0026#39;, KEYS[1], ARGV[2], 1); redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[1]); return nil; end; return redis.call(\u0026#39;pttl\u0026#39;, KEYS[1]); 6.2 释放锁流程 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 释放锁脚本 if (redis.call(\u0026#39;hexists\u0026#39;, KEYS[1], ARGV[3]) == 0) then return nil; end; local counter = redis.call(\u0026#39;hincrby\u0026#39;, KEYS[1], ARGV[3], -1); if (counter \u0026gt; 0) then redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[2]); return 0; else redis.call(\u0026#39;del\u0026#39;, KEYS[1]); redis.call(\u0026#39;publish\u0026#39;, KEYS[2], ARGV[1]); return 1; end; 7. 关键特性 7.1 线程安全 使用 Lua 脚本保证原子性 避免竞态条件 7.2 自动续期 通过 pexpire 自动续期 防止业务执行时间过长导致锁过期 7.3 公平性 支持公平锁和非公平锁 通过队列机制保证获取锁的顺序 7.4 可重入性 同一线程可多次获取锁 通过重入计数器实现 8. 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 获取可重入锁 RLock lock = redisson.getLock(\u0026#34;myLock\u0026#34;); try { // 尝试加锁，最多等待100秒，上锁以后10秒自动解锁 boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS); if (res) { try { // 业务逻辑 doSomething(); } finally { lock.unlock(); } } } catch (InterruptedException e) { e.printStackTrace(); } 9. 总结升华 普通分布式锁只关心 \u0026ldquo;有锁 / 无锁\u0026rdquo;，不关心是谁加的锁，导致 同一线程重入时也会失败。\nRedisson 通过在 Redis 的 Hash 结构 中记录 \u0026ldquo;线程标识 + 重入计数\u0026rdquo;，让锁具备了 可重入能力。\n意义：可重入锁避免了一个线程在嵌套调用中把自己卡死，同时对外仍然保持分布式锁的特性。\n一句话总结： Redisson 的可重入锁，本质上就是用 Redis Hash 存储线程 ID 和重入次数，直到重入次数归零才真正释放锁。\n10. 扩展阅读 Redisson 官方文档 Redis 分布式锁最佳实践 Java 并发编程实战 本文档详细介绍了 Redisson 可重入锁的实现原理，帮助开发者深入理解分布式锁的核心机制。\n","date":"2025-09-14T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/redisson-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/","title":"Redisson 可重入锁原理详解"},{"content":"深入理解 Redis + Lua 在秒杀系统中的应用 在高并发场景下，尤其是秒杀系统，如何保证库存扣减的正确性和用户限购的准确性，是一个非常经典的问题。\n本文将通过一个完整的案例，详细讲解 Redis + Lua 脚本 在秒杀活动中的使用方式。\n一、背景介绍 在秒杀场景中，如果单纯依赖后端数据库进行库存扣减与用户校验，往往会产生以下问题：\n高并发下数据库压力过大：大量用户同时下单，数据库容易被打爆。 超卖问题：多个线程并发操作时，可能会出现库存被扣成负数的情况。 限购逻辑失效：如果并发控制不好，同一用户可能绕过限购限制。 为了解决这些问题，我们通常会 将秒杀的核心逻辑放到 Redis 里，利用 Redis 的高性能与 Lua 脚本的原子性，来保证数据一致性。\n二、Redis Key 设计 在这个秒杀系统中，我们为每个活动设计了两个关键的 Redis Key：\n1. 库存 Key 1 seckill:stock:{activityId} 作用：存放某个活动的剩余库存数量。\n示例：\n1 SET seckill:stock:1001 50 表示活动 1001 还有 50 件商品。\n2. 参与用户 Key 1 seckill:participants:{activityId} 作用：存放某个活动所有用户的购买记录（哈希表）。\n示例：\n1 2 HSET seckill:participants:1001 12345 1 HSET seckill:participants:1001 67890 2 表示：\n用户 12345 已经购买 1 件 用户 67890 已经购买 2 件 三、Java 代码调用 Lua 脚本 在后端中，调用 Lua 脚本的方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 String stockKey = seckillPrefix + \u0026#34;stock:\u0026#34; + activityId; String participantsKey = seckillPrefix + \u0026#34;participants:\u0026#34; + activityId; DefaultRedisScript\u0026lt;List\u0026gt; script = new DefaultRedisScript\u0026lt;\u0026gt;(); script.setScriptSource(new ResourceScriptSource(new ClassPathResource(\u0026#34;seckill_participate.lua\u0026#34;))); script.setResultType(List.class); List\u0026lt;String\u0026gt; keys = Arrays.asList(stockKey, participantsKey); List\u0026lt;Object\u0026gt; args = Arrays.asList( userId.toString(), quantity.toString(), activity.getPerUserLimit().toString() ); List result = redisTemplate.execute(script, keys, args.toArray()); 参数传递说明 这里需要重点理解的有两部分：\nkeys → 传递给 Lua 的 Redis Key，脚本里用 KEYS[] 访问：\nKEYS[1] = \u0026quot;seckill:stock:1001\u0026quot; （这个活动的库存） KEYS[2] = \u0026quot;seckill:participants:1001\u0026quot; （记录了这个活动所有用户的购买记录） args → 附加参数，脚本里用 ARGV[] 访问：\nARGV[1] = userId （当前用户 ID） ARGV[2] = quantity （本次购买数量） ARGV[3] = perUserLimit （每人限购数量） 四、Lua 脚本逻辑详解 Lua 脚本具有原子性，在 Redis 中执行时不会被打断，非常适合秒杀场景。\n典型的 seckill_participate.lua 脚本如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- 获取参数 local stock = tonumber(redis.call(\u0026#34;GET\u0026#34;, KEYS[1])) local userId = ARGV[1] local quantity = tonumber(ARGV[2]) local perUserLimit = tonumber(ARGV[3]) -- 查询用户已购买数量 local userBought = tonumber(redis.call(\u0026#34;HGET\u0026#34;, KEYS[2], userId) or \u0026#34;0\u0026#34;) -- 1. 校验是否超过个人限购 if userBought + quantity \u0026gt; perUserLimit then return {0, \u0026#34;超过个人限购\u0026#34;} end -- 2. 校验库存是否足够 if stock \u0026lt; quantity then return {0, \u0026#34;库存不足\u0026#34;} end -- 3. 扣减库存 redis.call(\u0026#34;DECRBY\u0026#34;, KEYS[1], quantity) -- 4. 更新用户购买数量 redis.call(\u0026#34;HINCRBY\u0026#34;, KEYS[2], userId, quantity) -- 5. 返回成功 return {1, \u0026#34;成功\u0026#34;} 脚本执行流程详解 让我们逐步分析这个脚本的执行过程：\n1. 参数接收 1 2 3 local userId = ARGV[1] -- 接收用户ID local quantity = tonumber(ARGV[2]) -- 接收购买数量 local perUserLimit = tonumber(ARGV[3]) -- 接收限购数量 后端通过 redisTemplate.execute(...) 传入这些 ARGV 参数给 Lua 脚本，脚本接收每个参数。\n2. 查询用户购买记录 1 local userBought = tonumber(redis.call(\u0026#34;HGET\u0026#34;, KEYS[2], userId) or \u0026#34;0\u0026#34;) 这段代码的作用：查询当前 userId 的购买记录。\n原理：因为传入了 participantsKey（这个活动的用户购买记录）和 userId（这个用户），就可以根据 userId 在 participantsKey 里面查出对应的用户购买记录。\n3. 限购校验 1 2 3 if userBought + quantity \u0026gt; perUserLimit then return {0, \u0026#34;超过个人限购\u0026#34;} end 判断逻辑：用户目前已购买数 + 新购买数 quantity 是否大于最大购买量 perUserLimit。\n如果是，返回 {0, \u0026quot;超过个人限购\u0026quot;} 如果不是，继续下一步 4. 库存校验 1 2 3 if stock \u0026lt; quantity then return {0, \u0026#34;库存不足\u0026#34;} end 检查库存是否足够，如果不够，则返回 {0, \u0026quot;库存不足\u0026quot;}。\n5. 执行购买操作 1 2 3 4 5 -- 扣减库存 redis.call(\u0026#34;DECRBY\u0026#34;, KEYS[1], quantity) -- 记录用户购买数量 redis.call(\u0026#34;HINCRBY\u0026#34;, KEYS[2], userId, quantity) 如果库存足够，则：\n扣减库存：DECRBY 命令将库存减少 quantity 数量 记录用户购买数量：HINCRBY 命令将用户的购买记录增加 quantity 数量 6. 返回成功 1 return {1, \u0026#34;成功\u0026#34;} 最后返回 {1, \u0026quot;成功\u0026quot;}，表示购买成功。\n五、执行流程示例 我们以用户 12345 参与活动 1001 为例，假设初始库存为 10，限购为 3：\n第一次购买（买 2 件） 输入参数：\nKEYS[1] = seckill:stock:1001 KEYS[2] = seckill:participants:1001 ARGV[1] = \u0026quot;12345\u0026quot; ARGV[2] = \u0026quot;2\u0026quot; ARGV[3] = \u0026quot;3\u0026quot; 脚本执行：\nuserBought = 0（没买过） stock = 10，足够 扣减库存：DECRBY seckill:stock:1001 2 → 库存变 8 更新购买记录：HINCRBY seckill:participants:1001 12345 2 → 用户买了 2 件 返回 {1, \u0026quot;成功\u0026quot;} 第二次购买（再买 2 件） 输入参数：\nARGV[1] = \u0026quot;12345\u0026quot; ARGV[2] = \u0026quot;2\u0026quot; ARGV[3] = \u0026quot;3\u0026quot; 脚本执行：\nuserBought = 2（上次买了 2 件） 本次要买 2 件，总数 = 4 \u0026gt; 限购 3 返回 {0, \u0026quot;超过个人限购\u0026quot;} 六、核心优势 通过 Redis Key 设计 + Lua 脚本原子执行，我们实现了以下目标：\n1. 防止超卖 库存扣减和用户购买记录更新在同一个脚本里完成，保证了原子性。\n2. 限购控制 利用哈希表存储用户购买记录，结合 Lua 脚本校验，避免了用户绕过限购。\n3. 高并发性能 逻辑全部在 Redis 内部执行，不依赖数据库事务，性能极高。\n4. 数据一致性 Lua 脚本的原子性保证了所有操作要么全部成功，要么全部失败。\n七、实际应用场景 这种方式是很多电商平台在秒杀场景中的标准做法，也是分布式系统里常见的\u0026quot;数据库削峰\u0026quot;与\u0026quot;Redis 限流\u0026quot;的结合应用。\n适用场景 秒杀活动 限时抢购 限量商品销售 优惠券发放 积分兑换 技术特点 高性能：Redis 内存操作，响应速度快 原子性：Lua 脚本保证操作原子性 可扩展：支持分布式部署 可靠性：避免超卖和重复购买 八、延伸思考 1. 退款退货支持 如果要支持退款退货，需要在 Lua 脚本里增加库存回滚逻辑：\n1 2 3 4 -- 退款时回滚库存 redis.call(\u0026#34;INCRBY\u0026#34;, KEYS[1], quantity) -- 减少用户购买记录 redis.call(\u0026#34;HINCRBY\u0026#34;, KEYS[2], userId, -quantity) 2. 分片存储优化 如果活动商品数量非常大，可以考虑分片存储库存，进一步提高并发性能：\n1 2 -- 根据用户ID进行分片 local shardKey = \u0026#34;seckill:stock:\u0026#34; .. activityId .. \u0026#34;:\u0026#34; .. (userId % 10) 3. 异步处理 在真实生产环境中，还需要配合消息队列（MQ）和异步下单，以保证后续数据库写入的可靠性。 详情可前往此处了解https://yin123-ybh.github.io/p/异步秒杀系统深度解析含redis预扣库存与消息队列实现/\n4. 监控和告警 监控 Redis 性能指标 设置库存告警阈值 记录用户购买行为日志 九、总结 Redis + Lua 脚本在秒杀系统中的应用，通过以下方式解决了高并发场景下的核心问题：\n利用 Redis 的高性能：将核心逻辑从数据库转移到内存 保证操作的原子性：Lua 脚本确保所有操作要么全部成功，要么全部失败 实现精确的限购控制：通过哈希表记录用户购买历史 避免超卖问题：库存扣减和用户记录更新在同一脚本中完成 这种方案不仅适用于秒杀系统，在需要高并发、强一致性的场景中都有广泛应用价值。\n以上就是关于秒杀系统中 Redis + Lua 脚本的完整应用解析。通过深入理解这些核心概念，你就能在实际项目中灵活运用这些技术，构建出高性能、高可靠的分布式系统。\n","date":"2025-09-14T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-redis--lua-%E5%9C%A8%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","title":"深入理解 Redis + Lua 在秒杀系统中的应用"},{"content":"异步秒杀系统深度解析（含Redis预扣库存与消息队列实现） 秒杀系统是电商高并发场景的典型应用，短时间内大量用户同时抢购有限商品，如何保证库存不超卖、系统高可用、响应快速，是技术设计的核心问题。本文将结合异步秒杀思路、Redis库存预扣、消息队列、前后端解耦等技术点，深入讲解秒杀系统的设计与实现，并用类比和流程解析，帮助你理解高并发处理背后的原理。\n1️⃣ 秒杀场景问题分析 秒杀场景主要有以下特点：\n高并发：短时间内成千上万用户抢购同一商品 库存有限：商品数量有限，必须严格控制 系统压力大：数据库和应用服务可能成为性能瓶颈 常见问题： 超卖：库存被多次扣减，卖出超过实际数量 数据库压力大：大量请求直接打到数据库，容易导致宕机 网络延迟和响应慢：用户体验差 并发事务冲突：普通锁或事务可能成为性能瓶颈 问题代码示例（错误实现） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // ❌ 错误实现：直接操作数据库，容易超卖 @RestController public class SeckillController { @Autowired private ProductService productService; @Autowired private OrderService orderService; @PostMapping(\u0026#34;/seckill\u0026#34;) public Result seckill(@RequestParam Long productId, @RequestParam Long userId) { // 1. 查询库存 Product product = productService.getById(productId); if (product.getStock() \u0026lt;= 0) { return Result.fail(\u0026#34;库存不足\u0026#34;); } // 2. 扣减库存 - 这里可能出现超卖！ product.setStock(product.getStock() - 1); productService.updateById(product); // 3. 创建订单 Order order = new Order(); order.setProductId(productId); order.setUserId(userId); orderService.save(order); return Result.success(\u0026#34;秒杀成功\u0026#34;); } } 2️⃣ 同步 vs 异步秒杀 秒杀处理可以分为两种模式：\n方式 用户请求 后端处理 优缺点 同步 用户请求直接调用数据库 立即处理库存和订单 高并发下数据库压力大，容易阻塞，超卖风险高 异步 用户请求先进入队列或缓存 后台异步消费队列，依次处理库存和订单 快速响应用户，削峰填谷，防止超卖 核心区别： 同步模式：前端等待后端完成所有操作 异步模式：前端请求先排队，后台慢慢处理业务，请求处理与业务逻辑解耦 3️⃣ 异步秒杀核心思路 异步秒杀通过以下流程实现高并发处理：\n步骤 1：接收请求（接口层） 用户点击秒杀按钮，前端请求秒杀接口。\n接口层快速判断：\n商品是否还有库存 用户是否已经下单 判断通过：\n使用 Redis + Lua 脚本进行库存预扣（原子操作） 生成订单 ID 或请求 ID 将请求封装成消息放入消息队列（RabbitMQ、Kafka、Redis Stream 等） 接口立即返回给前端：\n\u0026ldquo;排队成功\u0026quot;或\u0026quot;请求已接收\u0026rdquo; ⚡ 注意：前端用户此时并未直接拿到最终订单，只是拿到一个\u0026quot;抢购凭证\u0026quot;。\n步骤 2：异步处理请求（后台服务） 消费消息队列：\n扣数据库库存 创建订单记录 标记用户已下单 处理完成后通知用户：\n秒杀成功（订单生成成功） 秒杀失败（库存不足） 步骤 3：库存控制 Redis库存预减：\n秒杀前，将商品库存加载到 Redis 用户请求时，用 Redis 原子操作 DECR 扣减库存 扣减成功 → 放入消息队列 扣减失败 → 秒杀结束，返回失败 可使用 Lua 脚本将 判断库存 \u0026gt; 0 + 扣减库存 做成原子操作，避免超卖\n步骤 4：用户通知 秒杀结果异步返回：\n轮询接口 WebSocket 消息推送 前端用户拿到最终结果后，确认是否抢购成功\n4️⃣ 接口层快速判断库存与用户资格 接口层为什么可以快速判断库存和用户是否符合下单要求？核心是提前把关键数据缓存在 Redis：\n4.1 库存判断 秒杀开始前，将商品库存加载到 Redis：\n1 2 Key: \u0026#34;stock:商品ID\u0026#34; Value: 剩余库存数量 请求到来时：\n1 DECR stock:商品ID // 原子操作 返回值判断：\n≥0 → 库存还有，允许下单 \u0026lt;0 → 库存不足，秒杀结束 Lua 脚本可将\u0026quot;判断库存 + 扣减库存\u0026quot;原子化处理，避免超卖\n4.2 用户是否已下单 每位用户只能下单一次：\n1 2 Key: \u0026#34;order:用户ID:商品ID\u0026#34; Value: 1 // 已下单 接口层判断：\n1 2 EXISTS order:用户ID:商品ID → 已下单，拒绝 不存在 → 允许加入队列 ✅ 通过 Redis 判断库存与用户状态，实现秒杀接口快速响应，避免高并发直接打数据库。\n4.3 接口层完整流程 用户发起请求 接口层判断库存 + 用户是否已下单 判断通过： Redis预扣库存（Lua脚本） 生成订单ID 放入消息队列 返回\u0026quot;排队成功\u0026quot;，前端无需等待数据库操作 5️⃣ 异步的性能优势 异步模式比同步模式性能更好，原因在于解耦请求处理和数据库操作，避免阻塞：\n请求处理快：线程只做轻量判断 + Redis + 消息入队 → 立即释放 流量削峰填谷：队列缓冲高峰请求，数据库平滑消费 避免超卖：Redis原子扣减 + 队列顺序消费 系统吞吐量高：Web层快速响应 + 后端多线程或分布式处理 类比说明 同步：前端直接等菜做好 → 高峰期排长队，厨房忙不过来 异步：前端先拿到取餐号 → 厨房按顺序做菜 → 系统稳定，用户体验好 6️⃣ 核心技术实现要点 技术环节 实现关键 接入层 限流（Nginx/网关）防止请求暴涨 库存判断 Redis原子操作 DECR + Lua脚本 请求排队 消息队列异步处理（RabbitMQ/Kafka/Redis Stream） 订单处理 消费端事务写数据库 去重 用户下单前检查是否已下单 削峰填谷 消息队列保证平滑消费 幂等性 消费端保证重复消费不会产生重复订单 7️⃣ 完整代码实现 7.1 项目结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seckill-system/ ├── src/main/java/com/seckill/ │ ├── controller/ │ │ └── SeckillController.java │ ├── service/ │ │ ├── SeckillService.java │ │ ├── OrderService.java │ │ └── ProductService.java │ ├── config/ │ │ ├── RedisConfig.java │ │ └── RabbitMQConfig.java │ ├── entity/ │ │ ├── SeckillOrder.java │ │ └── SeckillProduct.java │ ├── dto/ │ │ └── SeckillMessage.java │ ├── consumer/ │ │ └── SeckillConsumer.java │ └── util/ │ └── RedisLuaScript.java 7.2 实体类定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 秒杀商品实体 @Data @Entity @Table(name = \u0026#34;seckill_product\u0026#34;) public class SeckillProduct { @Id private Long id; private String name; private BigDecimal price; private Integer stock; private LocalDateTime startTime; private LocalDateTime endTime; private Integer status; // 0-未开始 1-进行中 2-已结束 } // 秒杀订单实体 @Data @Entity @Table(name = \u0026#34;seckill_order\u0026#34;) public class SeckillOrder { @Id private String id; private Long userId; private Long productId; private BigDecimal price; private Integer status; // 0-待支付 1-已支付 2-已取消 private LocalDateTime createTime; private LocalDateTime payTime; } 7.3 Redis配置和Lua脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @Configuration public class RedisConfig { @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate\u0026lt;String, Object\u0026gt; template = new RedisTemplate\u0026lt;\u0026gt;(); template.setConnectionFactory(factory); // 设置序列化 Jackson2JsonRedisSerializer\u0026lt;Object\u0026gt; serializer = new Jackson2JsonRedisSerializer\u0026lt;\u0026gt;(Object.class); ObjectMapper mapper = new ObjectMapper(); mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL); serializer.setObjectMapper(mapper); template.setValueSerializer(serializer); template.setKeySerializer(new StringRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; } } // Lua脚本工具类 @Component public class RedisLuaScript { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; // 库存预扣Lua脚本 private static final String STOCK_DECR_SCRIPT = \u0026#34;local stock = redis.call(\u0026#39;get\u0026#39;, KEYS[1]) \u0026#34; + \u0026#34;if stock == false or tonumber(stock) \u0026lt;= 0 then \u0026#34; + \u0026#34; return -1 \u0026#34; + \u0026#34;end \u0026#34; + \u0026#34;local newStock = redis.call(\u0026#39;decr\u0026#39;, KEYS[1]) \u0026#34; + \u0026#34;if newStock \u0026lt; 0 then \u0026#34; + \u0026#34; redis.call(\u0026#39;incr\u0026#39;, KEYS[1]) \u0026#34; + \u0026#34; return -1 \u0026#34; + \u0026#34;end \u0026#34; + \u0026#34;return newStock\u0026#34;; // 检查用户是否已下单 private static final String CHECK_USER_ORDER_SCRIPT = \u0026#34;local exists = redis.call(\u0026#39;exists\u0026#39;, KEYS[1]) \u0026#34; + \u0026#34;if exists == 1 then \u0026#34; + \u0026#34; return 1 \u0026#34; + \u0026#34;end \u0026#34; + \u0026#34;redis.call(\u0026#39;setex\u0026#39;, KEYS[1], ARGV[1], \u0026#39;1\u0026#39;) \u0026#34; + \u0026#34;return 0\u0026#34;; /** * 原子性扣减库存 */ public Long decrStock(String stockKey) { DefaultRedisScript\u0026lt;Long\u0026gt; script = new DefaultRedisScript\u0026lt;\u0026gt;(); script.setScriptText(STOCK_DECR_SCRIPT); script.setResultType(Long.class); return redisTemplate.execute(script, Collections.singletonList(stockKey)); } /** * 检查并标记用户已下单 */ public Boolean checkAndSetUserOrder(String userOrderKey, int expireSeconds) { DefaultRedisScript\u0026lt;Long\u0026gt; script = new DefaultRedisScript\u0026lt;\u0026gt;(); script.setScriptText(CHECK_USER_ORDER_SCRIPT); script.setResultType(Long.class); Long result = redisTemplate.execute(script, Collections.singletonList(userOrderKey), String.valueOf(expireSeconds)); return result != null \u0026amp;\u0026amp; result == 0; // 0表示成功设置，1表示已存在 } } 7.4 消息队列配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @Configuration public class RabbitMQConfig { // 秒杀消息队列 public static final String SECKILL_QUEUE = \u0026#34;seckill.queue\u0026#34;; public static final String SECKILL_EXCHANGE = \u0026#34;seckill.exchange\u0026#34;; public static final String SECKILL_ROUTING_KEY = \u0026#34;seckill.message\u0026#34;; @Bean public Queue seckillQueue() { return QueueBuilder.durable(SECKILL_QUEUE).build(); } @Bean public DirectExchange seckillExchange() { return new DirectExchange(SECKILL_EXCHANGE); } @Bean public Binding seckillBinding() { return BindingBuilder .bind(seckillQueue()) .to(seckillExchange()) .with(SECKILL_ROUTING_KEY); } @Bean public MessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); } } // 秒杀消息DTO @Data @AllArgsConstructor @NoArgsConstructor public class SeckillMessage { private Long userId; private Long productId; private String orderId; private LocalDateTime createTime; } 7.5 秒杀控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @RestController @RequestMapping(\u0026#34;/seckill\u0026#34;) @Slf4j public class SeckillController { @Autowired private SeckillService seckillService; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; /** * 秒杀接口 */ @PostMapping(\u0026#34;/{productId}\u0026#34;) public Result\u0026lt;String\u0026gt; seckill(@PathVariable Long productId, @RequestParam Long userId) { try { // 1. 参数校验 if (productId == null || userId == null) { return Result.fail(\u0026#34;参数不能为空\u0026#34;); } // 2. 检查秒杀活动状态 if (!seckillService.isSeckillActive(productId)) { return Result.fail(\u0026#34;秒杀活动未开始或已结束\u0026#34;); } // 3. 执行秒杀 String orderId = seckillService.executeSeckill(productId, userId); if (orderId != null) { return Result.success(\u0026#34;排队成功，订单号：\u0026#34; + orderId); } else { return Result.fail(\u0026#34;秒杀失败，请重试\u0026#34;); } } catch (Exception e) { log.error(\u0026#34;秒杀异常，商品ID：{}，用户ID：{}\u0026#34;, productId, userId, e); return Result.fail(\u0026#34;系统异常，请稍后重试\u0026#34;); } } /** * 查询秒杀结果 */ @GetMapping(\u0026#34;/result/{orderId}\u0026#34;) public Result\u0026lt;SeckillOrder\u0026gt; getSeckillResult(@PathVariable String orderId) { try { SeckillOrder order = seckillService.getSeckillOrder(orderId); if (order != null) { return Result.success(order); } else { return Result.fail(\u0026#34;订单不存在或处理中\u0026#34;); } } catch (Exception e) { log.error(\u0026#34;查询秒杀结果异常，订单ID：{}\u0026#34;, orderId, e); return Result.fail(\u0026#34;查询失败\u0026#34;); } } /** * 获取商品库存 */ @GetMapping(\u0026#34;/stock/{productId}\u0026#34;) public Result\u0026lt;Integer\u0026gt; getStock(@PathVariable Long productId) { try { String stockKey = \u0026#34;stock:\u0026#34; + productId; Object stock = redisTemplate.opsForValue().get(stockKey); if (stock != null) { return Result.success(Integer.valueOf(stock.toString())); } else { return Result.success(0); } } catch (Exception e) { log.error(\u0026#34;获取库存异常，商品ID：{}\u0026#34;, productId, e); return Result.fail(\u0026#34;获取库存失败\u0026#34;); } } } 7.6 秒杀服务实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @Service @Slf4j public class SeckillService { @Autowired private ProductService productService; @Autowired private OrderService orderService; @Autowired private RedisLuaScript redisLuaScript; @Autowired private RabbitTemplate rabbitTemplate; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; private static final String STOCK_PREFIX = \u0026#34;stock:\u0026#34;; private static final String USER_ORDER_PREFIX = \u0026#34;user_order:\u0026#34;; private static final int USER_ORDER_EXPIRE = 3600; // 1小时 /** * 检查秒杀活动是否进行中 */ public boolean isSeckillActive(Long productId) { try { SeckillProduct product = productService.getById(productId); if (product == null) { return false; } LocalDateTime now = LocalDateTime.now(); return product.getStatus() == 1 \u0026amp;\u0026amp; now.isAfter(product.getStartTime()) \u0026amp;\u0026amp; now.isBefore(product.getEndTime()); } catch (Exception e) { log.error(\u0026#34;检查秒杀活动状态异常，商品ID：{}\u0026#34;, productId, e); return false; } } /** * 执行秒杀 */ public String executeSeckill(Long productId, Long userId) { try { // 1. 检查用户是否已下单 String userOrderKey = USER_ORDER_PREFIX + userId + \u0026#34;:\u0026#34; + productId; if (!redisLuaScript.checkAndSetUserOrder(userOrderKey, USER_ORDER_EXPIRE)) { log.warn(\u0026#34;用户已下单，用户ID：{}，商品ID：{}\u0026#34;, userId, productId); return null; } // 2. 原子性扣减库存 String stockKey = STOCK_PREFIX + productId; Long remainingStock = redisLuaScript.decrStock(stockKey); if (remainingStock == null || remainingStock \u0026lt; 0) { log.warn(\u0026#34;库存不足，商品ID：{}，用户ID：{}\u0026#34;, productId, userId); return null; } // 3. 生成订单ID String orderId = generateOrderId(); // 4. 发送消息到队列 SeckillMessage message = new SeckillMessage(); message.setUserId(userId); message.setProductId(productId); message.setOrderId(orderId); message.setCreateTime(LocalDateTime.now()); rabbitTemplate.convertAndSend( RabbitMQConfig.SECKILL_EXCHANGE, RabbitMQConfig.SECKILL_ROUTING_KEY, message ); log.info(\u0026#34;秒杀请求已入队，订单ID：{}，用户ID：{}，商品ID：{}\u0026#34;, orderId, userId, productId); return orderId; } catch (Exception e) { log.error(\u0026#34;执行秒杀异常，商品ID：{}，用户ID：{}\u0026#34;, productId, userId, e); return null; } } /** * 获取秒杀订单 */ public SeckillOrder getSeckillOrder(String orderId) { try { return orderService.getByOrderId(orderId); } catch (Exception e) { log.error(\u0026#34;获取秒杀订单异常，订单ID：{}\u0026#34;, orderId, e); return null; } } /** * 预热商品库存到Redis */ public void warmUpStock(Long productId) { try { SeckillProduct product = productService.getById(productId); if (product != null \u0026amp;\u0026amp; product.getStock() \u0026gt; 0) { String stockKey = STOCK_PREFIX + productId; redisTemplate.opsForValue().set(stockKey, product.getStock()); log.info(\u0026#34;商品库存预热成功，商品ID：{}，库存：{}\u0026#34;, productId, product.getStock()); } } catch (Exception e) { log.error(\u0026#34;预热商品库存异常，商品ID：{}\u0026#34;, productId, e); } } /** * 生成订单ID */ private String generateOrderId() { return \u0026#34;SK\u0026#34; + System.currentTimeMillis() + ThreadLocalRandom.current().nextInt(1000, 9999); } } 7.7 消息消费者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @Component @Slf4j public class SeckillConsumer { @Autowired private OrderService orderService; @Autowired private ProductService productService; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; /** * 消费秒杀消息 */ @RabbitListener(queues = RabbitMQConfig.SECKILL_QUEUE) public void handleSeckillMessage(SeckillMessage message) { log.info(\u0026#34;开始处理秒杀消息，订单ID：{}，用户ID：{}，商品ID：{}\u0026#34;, message.getOrderId(), message.getUserId(), message.getProductId()); try { // 1. 再次检查库存（双重保险） SeckillProduct product = productService.getById(message.getProductId()); if (product == null || product.getStock() \u0026lt;= 0) { log.warn(\u0026#34;商品不存在或库存不足，订单ID：{}\u0026#34;, message.getOrderId()); return; } // 2. 创建订单 SeckillOrder order = new SeckillOrder(); order.setId(message.getOrderId()); order.setUserId(message.getUserId()); order.setProductId(message.getProductId()); order.setPrice(product.getPrice()); order.setStatus(0); // 待支付 order.setCreateTime(LocalDateTime.now()); // 3. 扣减数据库库存 boolean stockUpdated = productService.decrStock(message.getProductId()); if (!stockUpdated) { log.warn(\u0026#34;扣减数据库库存失败，订单ID：{}\u0026#34;, message.getOrderId()); return; } // 4. 保存订单 orderService.save(order); log.info(\u0026#34;秒杀订单创建成功，订单ID：{}，用户ID：{}，商品ID：{}\u0026#34;, message.getOrderId(), message.getUserId(), message.getProductId()); } catch (Exception e) { log.error(\u0026#34;处理秒杀消息异常，订单ID：{}\u0026#34;, message.getOrderId(), e); } } } 7.8 商品服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Service @Transactional public class ProductService { @Autowired private SeckillProductMapper productMapper; /** * 扣减数据库库存 */ public boolean decrStock(Long productId) { try { int result = productMapper.decrStock(productId); return result \u0026gt; 0; } catch (Exception e) { log.error(\u0026#34;扣减数据库库存异常，商品ID：{}\u0026#34;, productId, e); return false; } } /** * 获取商品信息 */ public SeckillProduct getById(Long productId) { try { return productMapper.selectById(productId); } catch (Exception e) { log.error(\u0026#34;获取商品信息异常，商品ID：{}\u0026#34;, productId, e); return null; } } } 7.9 订单服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service public class OrderService { @Autowired private SeckillOrderMapper orderMapper; /** * 保存订单 */ public void save(SeckillOrder order) { try { orderMapper.insert(order); } catch (Exception e) { log.error(\u0026#34;保存订单异常，订单ID：{}\u0026#34;, order.getId(), e); throw new RuntimeException(\u0026#34;保存订单失败\u0026#34;, e); } } /** * 根据订单ID查询订单 */ public SeckillOrder getByOrderId(String orderId) { try { return orderMapper.selectByOrderId(orderId); } catch (Exception e) { log.error(\u0026#34;查询订单异常，订单ID：{}\u0026#34;, orderId, e); return null; } } } 7.10 数据库Mapper 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 商品Mapper @Mapper public interface SeckillProductMapper extends BaseMapper\u0026lt;SeckillProduct\u0026gt; { /** * 扣减库存 */ @Update(\u0026#34;UPDATE seckill_product SET stock = stock - 1 WHERE id = #{productId} AND stock \u0026gt; 0\u0026#34;) int decrStock(@Param(\u0026#34;productId\u0026#34;) Long productId); } // 订单Mapper @Mapper public interface SeckillOrderMapper extends BaseMapper\u0026lt;SeckillOrder\u0026gt; { /** * 根据订单ID查询 */ @Select(\u0026#34;SELECT * FROM seckill_order WHERE id = #{orderId}\u0026#34;) SeckillOrder selectByOrderId(@Param(\u0026#34;orderId\u0026#34;) String orderId); } 8️⃣ 异步秒杀优化技巧 8.1 本地缓存库存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Component public class LocalStockCache { private final Map\u0026lt;Long, AtomicInteger\u0026gt; localStockMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; /** * 获取本地库存 */ public int getLocalStock(Long productId) { AtomicInteger stock = localStockMap.get(productId); return stock != null ? stock.get() : 0; } /** * 扣减本地库存 */ public boolean decrLocalStock(Long productId) { AtomicInteger stock = localStockMap.computeIfAbsent(productId, k -\u0026gt; new AtomicInteger(0)); return stock.decrementAndGet() \u0026gt;= 0; } /** * 同步Redis库存到本地 */ @Scheduled(fixedRate = 1000) // 每秒同步一次 public void syncStockFromRedis() { for (Long productId : localStockMap.keySet()) { String stockKey = \u0026#34;stock:\u0026#34; + productId; Object redisStock = redisTemplate.opsForValue().get(stockKey); if (redisStock != null) { int stock = Integer.parseInt(redisStock.toString()); localStockMap.put(productId, new AtomicInteger(stock)); } } } } 8.2 限流配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @Configuration public class RateLimitConfig { @Bean public RedisRateLimiter redisRateLimiter() { return new RedisRateLimiter(100, 200); // 每秒100个请求，突发200个 } } // 限流注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface RateLimit { String key() default \u0026#34;rate_limit\u0026#34;; int time() default 60; int count() default 100; } // 限流切面 @Aspect @Component public class RateLimitAspect { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Around(\u0026#34;@annotation(rateLimit)\u0026#34;) public Object around(ProceedingJoinPoint point, RateLimit rateLimit) throws Throwable { String key = rateLimit.key(); int time = rateLimit.time(); int count = rateLimit.count(); String rateLimitKey = \u0026#34;rate_limit:\u0026#34; + key + \u0026#34;:\u0026#34; + System.currentTimeMillis() / 1000; Long current = redisTemplate.opsForValue().increment(rateLimitKey); if (current == 1) { redisTemplate.expire(rateLimitKey, time, TimeUnit.SECONDS); } if (current \u0026gt; count) { throw new RuntimeException(\u0026#34;请求过于频繁，请稍后重试\u0026#34;); } return point.proceed(); } } 8.3 热点商品预热 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component public class HotProductPreheater { @Autowired private SeckillService seckillService; @Autowired private ProductService productService; /** * 预热热点商品 */ @Scheduled(cron = \u0026#34;0 0 0 * * ?\u0026#34;) // 每天凌晨执行 public void preheatHotProducts() { List\u0026lt;SeckillProduct\u0026gt; hotProducts = productService.getHotProducts(); for (SeckillProduct product : hotProducts) { seckillService.warmUpStock(product.getId()); } log.info(\u0026#34;热点商品预热完成，预热商品数量：{}\u0026#34;, hotProducts.size()); } } 9️⃣ 监控和告警 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Component public class SeckillMonitor { @Autowired private MeterRegistry meterRegistry; private final Counter successCounter = Counter.builder(\u0026#34;seckill.success\u0026#34;).register(meterRegistry); private final Counter failCounter = Counter.builder(\u0026#34;seckill.fail\u0026#34;).register(meterRegistry); private final Timer processTimer = Timer.builder(\u0026#34;seckill.process.time\u0026#34;).register(meterRegistry); /** * 记录秒杀成功 */ public void recordSuccess() { successCounter.increment(); } /** * 记录秒杀失败 */ public void recordFail() { failCounter.increment(); } /** * 记录处理时间 */ public void recordProcessTime(Duration duration) { processTimer.record(duration); } } 🔟 前端实现示例 10.1 Vue.js 前端实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;seckill-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-info\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{ product.name }}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;价格：¥{{ product.price }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;库存：{{ stock }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;seckill-button\u0026#34;\u0026gt; \u0026lt;button v-if=\u0026#34;!isSeckilling \u0026amp;\u0026amp; stock \u0026gt; 0\u0026#34; @click=\u0026#34;startSeckill\u0026#34; :disabled=\u0026#34;isSeckilling\u0026#34; \u0026gt; 立即秒杀 \u0026lt;/button\u0026gt; \u0026lt;button v-else-if=\u0026#34;isSeckilling\u0026#34; disabled\u0026gt; 排队中... \u0026lt;/button\u0026gt; \u0026lt;button v-else disabled\u0026gt; 已售罄 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-if=\u0026#34;orderResult\u0026#34; class=\u0026#34;result\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;orderResult.success\u0026#34;\u0026gt;秒杀成功！订单号：{{ orderResult.orderId }}\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;{{ orderResult.message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { product: {}, stock: 0, isSeckilling: false, orderResult: null, pollTimer: null } }, mounted() { this.loadProductInfo(); this.startStockPolling(); }, beforeDestroy() { if (this.pollTimer) { clearInterval(this.pollTimer); } }, methods: { async loadProductInfo() { try { const response = await this.$http.get(`/api/product/${this.$route.params.productId}`); this.product = response.data; } catch (error) { console.error(\u0026#39;加载商品信息失败\u0026#39;, error); } }, async getStock() { try { const response = await this.$http.get(`/api/seckill/stock/${this.$route.params.productId}`); this.stock = response.data; } catch (error) { console.error(\u0026#39;获取库存失败\u0026#39;, error); } }, startStockPolling() { this.getStock(); this.pollTimer = setInterval(() =\u0026gt; { this.getStock(); }, 1000); }, async startSeckill() { this.isSeckilling = true; this.orderResult = null; try { const response = await this.$http.post(`/api/seckill/${this.$route.params.productId}`, { userId: this.getCurrentUserId() }); if (response.data.success) { this.orderResult = { success: true, orderId: response.data.data }; this.pollOrderResult(response.data.data); } else { this.orderResult = { success: false, message: response.data.message }; } } catch (error) { this.orderResult = { success: false, message: \u0026#39;网络异常，请重试\u0026#39; }; } finally { this.isSeckilling = false; } }, async pollOrderResult(orderId) { const maxAttempts = 30; // 最多轮询30次 let attempts = 0; const poll = async () =\u0026gt; { try { const response = await this.$http.get(`/api/seckill/result/${orderId}`); if (response.data.success) { this.orderResult = { success: true, orderId: orderId, order: response.data.data }; return; } attempts++; if (attempts \u0026lt; maxAttempts) { setTimeout(poll, 1000); // 1秒后重试 } else { this.orderResult = { success: false, message: \u0026#39;订单处理超时，请稍后查询\u0026#39; }; } } catch (error) { console.error(\u0026#39;查询订单结果失败\u0026#39;, error); attempts++; if (attempts \u0026lt; maxAttempts) { setTimeout(poll, 1000); } } }; poll(); }, getCurrentUserId() { // 获取当前用户ID的逻辑 return localStorage.getItem(\u0026#39;userId\u0026#39;) || \u0026#39;1\u0026#39;; } } } \u0026lt;/script\u0026gt; 1️⃣1️⃣ 总结与直观比喻 核心流程总结： 前端：拿到\u0026quot;抢购凭证\u0026quot;，无需直接等待数据库完成订单 接口层：快速判断库存和用户资格，入队 → 高并发下线程不被阻塞 后台：消费队列 → 扣数据库库存 → 创建订单 → 通知用户 Redis + 消息队列：保证库存原子性、顺序处理、系统平稳运行 ⚡ 异步秒杀的核心理念： 快速接收请求 + 排队 + 异步处理，实现削峰填谷、防止超卖、提升系统吞吐量。\n💡 直观类比： 前端用户：拿到取餐号 后台系统：厨房按顺序做菜 用户最终能拿到菜，但系统不会被瞬时流量压垮 技术优势： 高并发处理：Redis + 消息队列实现削峰填谷 防止超卖：Lua脚本保证原子性操作 系统稳定：异步处理避免数据库压力 用户体验：快速响应，无需长时间等待 可扩展性：支持分布式部署和水平扩展 通过本文的详细分析和完整代码实现，相信你已经对异步秒杀系统有了深入的理解。在实际项目中，可以根据具体业务需求对代码进行相应的调整和优化。\n本文档详细介绍了异步秒杀系统的设计与实现，包含了完整的代码示例和优化技巧，帮助开发者构建高性能、高可用的秒杀系统。\n","date":"2025-09-10T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E5%90%ABredis%E9%A2%84%E6%89%A3%E5%BA%93%E5%AD%98%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/","title":"异步秒杀系统深度解析（含Redis预扣库存与消息队列实现）"},{"content":"基于 Session 的短信登录完整解析 在现代 Web 应用中，短信验证码登录 是一种非常常见的无密码认证方式。它的好处是简单、安全，用户只需要输入手机号和验证码即可登录，而不用记复杂的密码。\n很多初学者在实现时会有疑惑：验证码存哪？怎么比对？登录状态如何保持？ 这篇文章将通过推导的方式，逐步解释清楚，并给出完整的代码示例。\n一、为什么需要 Session 要理解短信登录，必须先搞清楚 Session 的概念。\nHTTP 协议的一个最大特点是：无状态。\n这意味着每一次请求，服务器都不会记得你是谁。\n但是在实际应用里，我们需要：\n登录之后，保持登录状态 购物车内容能够一直保存 验证码发送后，能够正确地校验 这时候就需要 Session。\n1.1 Session 的类比 你可以把 Session 想象成服务器给用户开的一间小储物柜：\n当用户第一次访问时，服务器（tomcat）分配一个储物柜（Session），并生成一个唯一编号（Session ID） 服务器把这个编号写在一张小纸条上（Cookie），交给浏览器（客户端）保存 以后浏览器每次访问时，都会带上这张小纸条 服务器根据纸条上的编号，就能找到对应的储物柜，从里面取出属于该用户的数据 1.2 Session vs Cookie 特性 Cookie（小纸条） Session（储物柜） 存储位置 浏览器端 服务器端 安全性 较低（容易被篡改） 较高（由服务器维护） 容量 4KB 左右 取决于服务器内存 生命周期 可设置长时间保存 默认随浏览器关闭或超时清除 二、短信登录的推导过程 现在我们把 Session 的原理放到 短信验证码登录 的场景中，来一步步推导。\n2.1 用户提交手机号 用户在前端页面输入手机号 前端把手机号发送给后端 2.2 服务器生成验证码 后端生成一个 6 位随机数（例如 123456） 把这个验证码保存到 Session 储物柜 里 同时调用短信服务商的 API，把验证码发送到用户手机 此时，Session 中保存的是： key = \u0026ldquo;SMS_CODE_手机号\u0026rdquo; value = \u0026ldquo;123456\u0026rdquo;\n2.3 用户输入验证码登录 用户收到验证码，在页面输入 浏览器在发起请求时，会自动带上 Session ID 的小纸条（Cookie） 后端根据 Session ID 找到储物柜，从中取出验证码 比对用户输入的验证码与 Session 中保存的验证码 一致 ✅ → 登录成功 不一致 ❌ → 登录失败 三、代码实现示例（Spring Boot） 接下来用 Java + Spring Boot 来实现一个最简化的 基于 Session 的短信登录。\n3.1 发送验证码接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @RestController @RequestMapping(\u0026#34;/auth\u0026#34;) public class SmsLoginController { @PostMapping(\u0026#34;/sendCode\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; sendCode(@RequestParam String phone, HttpSession session) { // 生成 6 位验证码 String code = String.valueOf((int)((Math.random() * 9 + 1) * 100000)); // 模拟发送短信（真实情况需接入短信服务商 API） System.out.println(\u0026#34;向手机号 \u0026#34; + phone + \u0026#34; 发送验证码：\u0026#34; + code); // 保存到 session session.setAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone, code); session.setAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone, System.currentTimeMillis()); return ResponseEntity.ok(\u0026#34;验证码已发送\u0026#34;); } } 说明： 验证码保存在 Session 中，不存前端 建议同时保存验证码生成时间，方便后续判断是否过期\n3.2 验证登录接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @PostMapping(\u0026#34;/login\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; login(@RequestParam String phone, @RequestParam String code, HttpSession session) { String sessionCode = (String) session.getAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone); Long codeTime = (Long) session.getAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone); if (sessionCode == null) { return ResponseEntity.status(400).body(\u0026#34;验证码未发送或已过期\u0026#34;); } // 验证是否过期（5分钟有效） if (System.currentTimeMillis() - codeTime \u0026gt; 5 * 60 * 1000) { session.removeAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone); session.removeAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone); return ResponseEntity.status(400).body(\u0026#34;验证码已过期\u0026#34;); } if (!sessionCode.equals(code)) { return ResponseEntity.status(400).body(\u0026#34;验证码错误\u0026#34;); } // 登录成功，写入用户登录状态 session.setAttribute(\u0026#34;LOGIN_USER\u0026#34;, phone); // 清理验证码 session.removeAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone); session.removeAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone); return ResponseEntity.ok(\u0026#34;登录成功\u0026#34;); } 说明： 核心逻辑在 后端比对，前端只负责收集输入 验证码过期机制必须有，防止重复使用\n3.3 获取当前登录用户接口 1 2 3 4 5 6 7 8 @GetMapping(\u0026#34;/me\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; getUser(HttpSession session) { String phone = (String) session.getAttribute(\u0026#34;LOGIN_USER\u0026#34;); if (phone == null) { return ResponseEntity.status(401).body(\u0026#34;未登录\u0026#34;); } return ResponseEntity.ok(\u0026#34;当前登录用户：\u0026#34; + phone); } 四、关键点总结 1.Session 是储物柜，Cookie 是储物柜的取件凭证证 验证码存放在 Session（服务器端），不存浏览器 浏览器只保留 Session ID（Cookie） 2.比对逻辑必须在后端完成 前端只负责收集和提交手机号、验证码 服务器根据 Session 找到验证码并比对，决定是否登录 3.安全性措施 验证码要有过期时间（一般 5 分钟） 验证码要有发送频率限制，防止被恶意刷 五、流程回顾 让我们回顾整个短信登录的过程： 1.用户输入手机号 2.服务器生成验证码，存到 Session，并通过短信发送 3.用户收到验证码，输入到前端页面 4.浏览器请求时带上 Cookie（Session ID） 5.服务器用 Session ID 找到储物柜，取出验证码进行比对 一致 → 登录成功； 不一致/过期 → 登录失败 6.扩展思考 在实际生产环境中，Session 可能存放在 Redis 里，以便支持分布式部署。\n另外，也可以替代 Session，用 JWT（JSON Web Token） 实现无状态的登录。 但核心思想是一致的：\n验证码必须在后端保存和比对 前端只负责展示和输入 7.结语 通过上面的推导，我们把“短信登录”这个常见需求，完整地拆解成了 业务流程 + Session 原理 + 实现代码。\n如果你刚开始学习后端开发，希望你能从这篇文章中真正理解：\n为什么要用 Session 短信验证码应该存放在哪里 验证逻辑为什么要在后端 这样，不管是做一个小 demo，还是将来应对生产级的项目，你都能举一反三。\n","date":"2025-08-26T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/%E5%9F%BA%E4%BA%8E-session-%E7%9A%84%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E5%AE%8C%E6%95%B4%E8%A7%A3%E6%9E%90/","title":"基于 Session 的短信登录完整解析"},{"content":"数据库与 Redis 双写一致性问题全解析 在高并发系统中，Redis 作为缓存层，MySQL 作为存储层的组合几乎是标配。Redis 的高性能极大缓解了数据库的压力，但这也带来了一个核心难题：如何保证数据库与缓存的数据一致性？\n本文将全面分析数据库与 Redis 双写一致性问题，包括 不一致产生的原因、常见解决方案、优缺点分析、代码示例，以及通俗的生活类比。读完本文，你将对缓存一致性问题有系统、深刻的理解。\n一、为什么数据库和缓存可能不一致？ 很多人一开始会疑惑：数据库和缓存都是我们自己在控制，为什么会不一致？\n其实，问题的根源在于 缓存和数据库是两个独立系统，数据同步不是原子操作，中间存在时间差和失败的可能。\n1.1 常见不一致原因 ① 写数据库成功，但缓存没更新 原因：业务代码里先写数据库，再更新缓存。如果更新缓存失败（比如 Redis 宕机或网络抖动），就会出现 数据库新值、缓存旧值 的情况。\n通俗类比：你换了手机号码，但忘了告诉朋友。结果朋友打电话时，还是打到你旧号码。\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Service public class UserService { @Autowired private UserMapper userMapper; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; public void updateUser(User user) { try { // 1. 更新数据库 userMapper.updateById(user); // 2. 更新缓存 - 这里可能失败！ redisTemplate.opsForValue().set(\u0026#34;user:\u0026#34; + user.getId(), user); } catch (Exception e) { // 如果缓存更新失败，数据库已经更新了，但缓存还是旧值 log.error(\u0026#34;更新缓存失败\u0026#34;, e); } } } ② 更新顺序导致的问题 写数据库 → 删除缓存：如果写数据库成功，但删除缓存失败，那么缓存里依旧是旧数据，下一次查询会直接拿旧缓存。\n删除缓存 → 写数据库：如果在删除缓存后、写数据库前，恰好有请求查询数据，就会发生 缓存回填旧值 的问题。\n通俗类比：\n你要换家里的锁。 方案一（先换锁，再扔旧钥匙）：安全，但万一扔钥匙时手滑没扔掉（缓存没删掉），别人还能用旧钥匙开门。 方案二（先扔钥匙，再换锁）：在你换锁的几分钟里，别人可能正好用旧钥匙开门（缓存被旧值回填）。 代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 方案一：先写数据库，再删缓存 public void updateUserV1(User user) { // 1. 更新数据库 userMapper.updateById(user); // 2. 删除缓存 - 可能失败 try { redisTemplate.delete(\u0026#34;user:\u0026#34; + user.getId()); } catch (Exception e) { // 删除失败，缓存还是旧值 log.error(\u0026#34;删除缓存失败\u0026#34;, e); } } // 方案二：先删缓存，再写数据库 public void updateUserV2(User user) { // 1. 删除缓存 redisTemplate.delete(\u0026#34;user:\u0026#34; + user.getId()); // 2. 更新数据库 - 在删除缓存和更新数据库之间，可能有查询请求回填旧值 userMapper.updateById(user); } ③ 并发覆盖问题 在高并发下，多个请求同时修改同一条数据，可能出现覆盖。\n场景举例：\n请求 A：更新用户余额为 100 → 更新数据库成功 → 删除缓存 请求 B：更新用户余额为 200 → 更新数据库成功 → 删除缓存 请求 A 线程较慢，在 B 更新完成后又回填了 100 到缓存 结果：数据库是 200，缓存却是 100，产生了脏数据。 通俗类比：两个人同时往一个文档里写数据。甲写了新版内容，乙写完旧版后保存，最终的文档被乙覆盖，甲的修改消失。\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @Service public class AccountService { @Autowired private AccountMapper accountMapper; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; // 并发更新余额的问题示例 public void updateBalance(Long userId, BigDecimal amount) { // 1. 查询当前余额 Account account = accountMapper.selectById(userId); // 2. 计算新余额 BigDecimal newBalance = account.getBalance().add(amount); account.setBalance(newBalance); // 3. 更新数据库 accountMapper.updateById(account); // 4. 删除缓存 redisTemplate.delete(\u0026#34;account:\u0026#34; + userId); // 问题：如果两个线程同时执行，可能出现覆盖 } // 查询余额 public BigDecimal getBalance(Long userId) { // 1. 先查缓存 String cacheKey = \u0026#34;account:\u0026#34; + userId; BigDecimal balance = (BigDecimal) redisTemplate.opsForValue().get(cacheKey); if (balance != null) { return balance; } // 2. 缓存未命中，查数据库 Account account = accountMapper.selectById(userId); balance = account.getBalance(); // 3. 回填缓存 redisTemplate.opsForValue().set(cacheKey, balance, 30, TimeUnit.MINUTES); return balance; } } ④ 缓存回填问题 当缓存过期或被删除时，如果多个请求同时查询，会出现 缓存击穿，所有请求都直接打到数据库。如果数据库的数据恰好正在被更新，就可能回填旧值到缓存。\n通俗类比：大家都在查快递单号。缓存里过期了，大家都去问快递公司。正好快递公司系统还没更新，有人把旧的物流信息拿回来，又重新存进缓存。\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Service public class ProductService { @Autowired private ProductMapper productMapper; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; public Product getProduct(Long productId) { String cacheKey = \u0026#34;product:\u0026#34; + productId; // 1. 先查缓存 Product product = (Product) redisTemplate.opsForValue().get(cacheKey); if (product != null) { return product; } // 2. 缓存未命中，查数据库 product = productMapper.selectById(productId); // 3. 回填缓存 - 这里可能回填旧值 if (product != null) { redisTemplate.opsForValue().set(cacheKey, product, 30, TimeUnit.MINUTES); } return product; } public void updateProduct(Product product) { // 1. 更新数据库 productMapper.updateById(product); // 2. 删除缓存 redisTemplate.delete(\u0026#34;product:\u0026#34; + product.getId()); // 问题：在删除缓存后，如果有查询请求，可能回填旧值 } } ⑤ 异常或消息丢失 在使用消息队列、Binlog 同步的场景里，如果消息丢失或消费失败，也会造成数据库与缓存不一致。\n通俗类比：你让朋友帮忙转告一个信息。如果朋友忘了说（消息丢了），接收方就永远拿不到最新数据。\n小结 数据库与缓存的不一致，归根到底是因为 更新缓存和更新数据库不是一个原子操作，再加上 网络、并发、延迟、异常 等因素，导致不同步。\n接下来，我们看常见的解决方案。\n二、常见同步策略与实现 2.1 Cache Aside（旁路缓存模式） 这是最常见的缓存策略：\n读：先读缓存，缓存没有就读数据库，然后回填到缓存。 写：更新数据库，然后删除缓存。 流程图 1 2 3 4 读请求： 先查缓存 → 缓存命中 → 返回 缓存未命中 → 查数据库 → 写入缓存 → 返回 写请求： 先写数据库 → 删除缓存 优点 简单易实现 更新频率低、读多写少的场景下性能好 缺点 写后删除缓存不是原子操作，可能产生不一致 删除缓存和更新数据库之间有窗口期，容易被并发覆盖 通俗类比 你记不住朋友的手机号（数据库），于是写在纸条上放在口袋里（缓存）。每次查号码时，先摸口袋。如果号码变了，你改手机通讯录（数据库），然后把纸条扔掉（删缓存）。下次再有人问，就会从手机查出新号码，再抄一张新纸条。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @Service public class UserService { @Autowired private UserMapper userMapper; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; private static final String USER_CACHE_PREFIX = \u0026#34;user:\u0026#34;; private static final int CACHE_EXPIRE_TIME = 30; // 分钟 /** * 查询用户 - Cache Aside 读策略 */ public User getUser(Long userId) { String cacheKey = USER_CACHE_PREFIX + userId; // 1. 先查缓存 User user = (User) redisTemplate.opsForValue().get(cacheKey); if (user != null) { log.info(\u0026#34;缓存命中，用户ID: {}\u0026#34;, userId); return user; } // 2. 缓存未命中，查数据库 log.info(\u0026#34;缓存未命中，查询数据库，用户ID: {}\u0026#34;, userId); user = userMapper.selectById(userId); if (user != null) { // 3. 回填缓存 redisTemplate.opsForValue().set(cacheKey, user, CACHE_EXPIRE_TIME, TimeUnit.MINUTES); log.info(\u0026#34;数据回填缓存，用户ID: {}\u0026#34;, userId); } return user; } /** * 更新用户 - Cache Aside 写策略 */ @Transactional public boolean updateUser(User user) { try { // 1. 更新数据库 int result = userMapper.updateById(user); if (result \u0026lt;= 0) { log.warn(\u0026#34;更新用户失败，用户ID: {}\u0026#34;, user.getId()); return false; } // 2. 删除缓存 String cacheKey = USER_CACHE_PREFIX + user.getId(); redisTemplate.delete(cacheKey); log.info(\u0026#34;删除缓存成功，用户ID: {}\u0026#34;, user.getId()); return true; } catch (Exception e) { log.error(\u0026#34;更新用户异常，用户ID: {}\u0026#34;, user.getId(), e); throw new RuntimeException(\u0026#34;更新用户失败\u0026#34;, e); } } /** * 删除用户 */ @Transactional public boolean deleteUser(Long userId) { try { // 1. 删除数据库记录 int result = userMapper.deleteById(userId); if (result \u0026lt;= 0) { log.warn(\u0026#34;删除用户失败，用户ID: {}\u0026#34;, userId); return false; } // 2. 删除缓存 String cacheKey = USER_CACHE_PREFIX + userId; redisTemplate.delete(cacheKey); log.info(\u0026#34;删除缓存成功，用户ID: {}\u0026#34;, userId); return true; } catch (Exception e) { log.error(\u0026#34;删除用户异常，用户ID: {}\u0026#34;, userId, e); throw new RuntimeException(\u0026#34;删除用户失败\u0026#34;, e); } } } 2.2 延时双删策略 在 写数据库 + 删除缓存 的基础上，增加一次延时删除。\n1 2 3 4 updateDB(); delCache(); Thread.sleep(500); delCache(); 为什么要多删一次？ 因为第一次删缓存后，可能有并发请求查询，回填了旧值。第二次延迟删除，可以把旧值再清理掉。\n优点 思路简单，在一定程度上缓解并发覆盖问题 缺点 延迟时间不好确定，时间过长 → 脏数据存在太久；时间过短 → 覆盖问题仍可能发生 会带来额外的性能开销 通俗类比 你换了门锁。先把旧钥匙收走（删缓存）。但担心有人手里还有备份钥匙，于是过几分钟再来检查一次，把可能冒出来的旧钥匙也收走。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @Service public class UserServiceWithDelayDoubleDelete { @Autowired private UserMapper userMapper; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Autowired private ThreadPoolTaskExecutor taskExecutor; private static final String USER_CACHE_PREFIX = \u0026#34;user:\u0026#34;; private static final int DELAY_TIME = 500; // 毫秒 /** * 延时双删策略更新用户 */ @Transactional public boolean updateUserWithDelayDoubleDelete(User user) { try { // 1. 更新数据库 int result = userMapper.updateById(user); if (result \u0026lt;= 0) { return false; } // 2. 第一次删除缓存 String cacheKey = USER_CACHE_PREFIX + user.getId(); redisTemplate.delete(cacheKey); log.info(\u0026#34;第一次删除缓存，用户ID: {}\u0026#34;, user.getId()); // 3. 异步延时删除缓存 taskExecutor.execute(() -\u0026gt; { try { Thread.sleep(DELAY_TIME); redisTemplate.delete(cacheKey); log.info(\u0026#34;延时删除缓存完成，用户ID: {}\u0026#34;, user.getId()); } catch (InterruptedException e) { Thread.currentThread().interrupt(); log.error(\u0026#34;延时删除缓存被中断，用户ID: {}\u0026#34;, user.getId(), e); } catch (Exception e) { log.error(\u0026#34;延时删除缓存异常，用户ID: {}\u0026#34;, user.getId(), e); } }); return true; } catch (Exception e) { log.error(\u0026#34;更新用户异常，用户ID: {}\u0026#34;, user.getId(), e); throw new RuntimeException(\u0026#34;更新用户失败\u0026#34;, e); } } /** * 查询用户 */ public User getUser(Long userId) { String cacheKey = USER_CACHE_PREFIX + userId; // 1. 先查缓存 User user = (User) redisTemplate.opsForValue().get(cacheKey); if (user != null) { return user; } // 2. 缓存未命中，查数据库 user = userMapper.selectById(userId); if (user != null) { // 3. 回填缓存 redisTemplate.opsForValue().set(cacheKey, user, 30, TimeUnit.MINUTES); } return user; } } 2.3 加锁策略（读写锁、分布式锁） 通过加锁来保证写操作和读操作的互斥，避免并发不一致。\n读写锁 读锁（共享锁）：多个线程可以同时读，但不能写。 写锁（排他锁）：写时独占，其他线程不能读也不能写。 代码实现（Redisson 实现） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 @Service public class UserServiceWithLock { @Autowired private UserMapper userMapper; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Autowired private RedissonClient redissonClient; private static final String USER_CACHE_PREFIX = \u0026#34;user:\u0026#34;; private static final String LOCK_PREFIX = \u0026#34;lock:user:\u0026#34;; /** * 使用读写锁查询用户 */ public User getUserWithReadLock(Long userId) { String lockKey = LOCK_PREFIX + userId; RReadWriteLock rwLock = redissonClient.getReadWriteLock(lockKey); RLock readLock = rwLock.readLock(); try { readLock.lock(); // 1. 先查缓存 String cacheKey = USER_CACHE_PREFIX + userId; User user = (User) redisTemplate.opsForValue().get(cacheKey); if (user != null) { log.info(\u0026#34;缓存命中，用户ID: {}\u0026#34;, userId); return user; } // 2. 缓存未命中，查数据库 log.info(\u0026#34;缓存未命中，查询数据库，用户ID: {}\u0026#34;, userId); user = userMapper.selectById(userId); if (user != null) { // 3. 回填缓存 redisTemplate.opsForValue().set(cacheKey, user, 30, TimeUnit.MINUTES); log.info(\u0026#34;数据回填缓存，用户ID: {}\u0026#34;, userId); } return user; } finally { readLock.unlock(); } } /** * 使用写锁更新用户 */ @Transactional public boolean updateUserWithWriteLock(User user) { String lockKey = LOCK_PREFIX + user.getId(); RReadWriteLock rwLock = redissonClient.getReadWriteLock(lockKey); RLock writeLock = rwLock.writeLock(); try { writeLock.lock(); // 1. 更新数据库 int result = userMapper.updateById(user); if (result \u0026lt;= 0) { log.warn(\u0026#34;更新用户失败，用户ID: {}\u0026#34;, user.getId()); return false; } // 2. 删除缓存 String cacheKey = USER_CACHE_PREFIX + user.getId(); redisTemplate.delete(cacheKey); log.info(\u0026#34;删除缓存成功，用户ID: {}\u0026#34;, user.getId()); return true; } catch (Exception e) { log.error(\u0026#34;更新用户异常，用户ID: {}\u0026#34;, user.getId(), e); throw new RuntimeException(\u0026#34;更新用户失败\u0026#34;, e); } finally { writeLock.unlock(); } } /** * 使用分布式锁更新用户 */ @Transactional public boolean updateUserWithDistributedLock(User user) { String lockKey = LOCK_PREFIX + user.getId(); RLock lock = redissonClient.getLock(lockKey); try { // 尝试获取锁，最多等待10秒，锁持有时间30秒 boolean acquired = lock.tryLock(10, 30, TimeUnit.SECONDS); if (!acquired) { log.warn(\u0026#34;获取分布式锁失败，用户ID: {}\u0026#34;, user.getId()); return false; } // 1. 更新数据库 int result = userMapper.updateById(user); if (result \u0026lt;= 0) { log.warn(\u0026#34;更新用户失败，用户ID: {}\u0026#34;, user.getId()); return false; } // 2. 删除缓存 String cacheKey = USER_CACHE_PREFIX + user.getId(); redisTemplate.delete(cacheKey); log.info(\u0026#34;删除缓存成功，用户ID: {}\u0026#34;, user.getId()); return true; } catch (InterruptedException e) { Thread.currentThread().interrupt(); log.error(\u0026#34;获取分布式锁被中断，用户ID: {}\u0026#34;, user.getId(), e); return false; } catch (Exception e) { log.error(\u0026#34;更新用户异常，用户ID: {}\u0026#34;, user.getId(), e); throw new RuntimeException(\u0026#34;更新用户失败\u0026#34;, e); } finally { if (lock.isHeldByCurrentThread()) { lock.unlock(); } } } } 优点 能保证强一致性，避免脏读、脏写 特别适合对一致性要求高的业务 缺点 性能损耗较大，高并发下容易成为瓶颈 如果锁释放失败，可能导致死锁 通俗类比 图书馆借书：多个人同时看同一本书没问题（读读不互斥）。如果有人要在书上写笔记（写操作），那必须独占这本书，别人不能再看（读写互斥、写写互斥）。\n2.4 消息队列同步 更新数据库后，向消息队列发送更新事件，消费者订阅后更新缓存。\n代码实现 生产者（更新数据库后发送消息）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @Service public class UserServiceWithMQ { @Autowired private UserMapper userMapper; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Autowired private RabbitTemplate rabbitTemplate; private static final String USER_CACHE_PREFIX = \u0026#34;user:\u0026#34;; private static final String USER_UPDATE_QUEUE = \u0026#34;user.update.queue\u0026#34;; private static final String USER_DELETE_QUEUE = \u0026#34;user.delete.queue\u0026#34;; /** * 更新用户并发送消息 */ @Transactional public boolean updateUserWithMQ(User user) { try { // 1. 更新数据库 int result = userMapper.updateById(user); if (result \u0026lt;= 0) { return false; } // 2. 发送更新消息 UserUpdateEvent event = new UserUpdateEvent(); event.setUserId(user.getId()); event.setOperation(\u0026#34;UPDATE\u0026#34;); event.setTimestamp(System.currentTimeMillis()); rabbitTemplate.convertAndSend(USER_UPDATE_QUEUE, event); log.info(\u0026#34;发送用户更新消息，用户ID: {}\u0026#34;, user.getId()); return true; } catch (Exception e) { log.error(\u0026#34;更新用户异常，用户ID: {}\u0026#34;, user.getId(), e); throw new RuntimeException(\u0026#34;更新用户失败\u0026#34;, e); } } /** * 删除用户并发送消息 */ @Transactional public boolean deleteUserWithMQ(Long userId) { try { // 1. 删除数据库记录 int result = userMapper.deleteById(userId); if (result \u0026lt;= 0) { return false; } // 2. 发送删除消息 UserDeleteEvent event = new UserDeleteEvent(); event.setUserId(userId); event.setOperation(\u0026#34;DELETE\u0026#34;); event.setTimestamp(System.currentTimeMillis()); rabbitTemplate.convertAndSend(USER_DELETE_QUEUE, event); log.info(\u0026#34;发送用户删除消息，用户ID: {}\u0026#34;, userId); return true; } catch (Exception e) { log.error(\u0026#34;删除用户异常，用户ID: {}\u0026#34;, userId, e); throw new RuntimeException(\u0026#34;删除用户失败\u0026#34;, e); } } } // 事件类 @Data public class UserUpdateEvent { private Long userId; private String operation; private Long timestamp; } @Data public class UserDeleteEvent { private Long userId; private String operation; private Long timestamp; } 消费者（处理消息并更新缓存）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @Component public class UserCacheConsumer { @Autowired private UserMapper userMapper; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; private static final String USER_CACHE_PREFIX = \u0026#34;user:\u0026#34;; /** * 处理用户更新消息 */ @RabbitListener(queues = \u0026#34;user.update.queue\u0026#34;) public void handleUserUpdate(UserUpdateEvent event) { try { log.info(\u0026#34;收到用户更新消息，用户ID: {}\u0026#34;, event.getUserId()); // 1. 查询最新数据 User user = userMapper.selectById(event.getUserId()); if (user != null) { // 2. 更新缓存 String cacheKey = USER_CACHE_PREFIX + user.getId(); redisTemplate.opsForValue().set(cacheKey, user, 30, TimeUnit.MINUTES); log.info(\u0026#34;缓存更新成功，用户ID: {}\u0026#34;, user.getId()); } else { // 3. 如果用户不存在，删除缓存 String cacheKey = USER_CACHE_PREFIX + event.getUserId(); redisTemplate.delete(cacheKey); log.info(\u0026#34;用户不存在，删除缓存，用户ID: {}\u0026#34;, event.getUserId()); } } catch (Exception e) { log.error(\u0026#34;处理用户更新消息异常，用户ID: {}\u0026#34;, event.getUserId(), e); // 这里可以实现重试机制或死信队列 } } /** * 处理用户删除消息 */ @RabbitListener(queues = \u0026#34;user.delete.queue\u0026#34;) public void handleUserDelete(UserDeleteEvent event) { try { log.info(\u0026#34;收到用户删除消息，用户ID: {}\u0026#34;, event.getUserId()); // 删除缓存 String cacheKey = USER_CACHE_PREFIX + event.getUserId(); redisTemplate.delete(cacheKey); log.info(\u0026#34;缓存删除成功，用户ID: {}\u0026#34;, event.getUserId()); } catch (Exception e) { log.error(\u0026#34;处理用户删除消息异常，用户ID: {}\u0026#34;, event.getUserId(), e); } } } 优点 数据库与缓存解耦，保证异步最终一致性 能承受更高的并发量 缺点 引入 MQ 增加系统复杂度 消息丢失或重复消费需要额外处理 通俗类比 你搬家了，先在系统里改了地址（数据库）。系统发了一条通知（消息队列），告诉快递公司更新收件地址（缓存）。\n2.5 基于 Binlog 的 Canal 同步 通过监听 MySQL 的 Binlog，捕获数据变更事件，然后更新 Redis。\n流程 MySQL 开启 Binlog Canal 作为从库伪装，订阅 Binlog Binlog 里记录了 INSERT/UPDATE/DELETE Canal 解析事件并回写 Redis 代码实现 Canal 配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # canal.properties canal.port = 11111 canal.metrics.pull.port = 11112 canal.zkServers = localhost:2181 # 实例配置 canal.destinations = example canal.conf.dir = /opt/canal/conf canal.instance.global.master.address = 127.0.0.1:3306 canal.instance.global.master.journal.name = canal.instance.global.master.position = canal.instance.global.master.timestamp = canal.instance.global.master.gtid = canal.instance.dbUsername = canal canal.instance.dbPassword = canal canal.instance.connectionCharset = UTF-8 canal.instance.filter.regex = .*\\\\..* canal.instance.master.address = 127.0.0.1:3306 canal.instance.master.journal.name = canal.instance.master.position = canal.instance.master.timestamp = canal.instance.master.gtid = Canal 客户端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @Component public class CanalClient { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; private static final String USER_CACHE_PREFIX = \u0026#34;user:\u0026#34;; private static final String USER_TABLE = \u0026#34;t_user\u0026#34;; @PostConstruct public void startCanalClient() { // 创建Canal连接 CanalConnector connector = CanalConnectors.newSingleConnector( new InetSocketAddress(\u0026#34;127.0.0.1\u0026#34;, 11111), \u0026#34;example\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34; ); try { connector.connect(); connector.subscribe(\u0026#34;.*\\\\..*\u0026#34;); connector.rollback(); while (true) { Message message = connector.getWithoutAck(1000); long batchId = message.getBatchId(); int size = message.getEntries().size(); if (batchId == -1 || size == 0) { Thread.sleep(1000); } else { printEntry(message.getEntries()); connector.ack(batchId); } } } catch (Exception e) { log.error(\u0026#34;Canal客户端异常\u0026#34;, e); } finally { connector.disconnect(); } } private void printEntry(List\u0026lt;Entry\u0026gt; entries) { for (Entry entry : entries) { if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) { continue; } RowChange rowChange = null; try { rowChange = RowChange.parseFrom(entry.getStoreValue()); } catch (Exception e) { throw new RuntimeException(\u0026#34;解析binlog异常\u0026#34;, e); } EventType eventType = rowChange.getEventType(); String tableName = entry.getHeader().getTableName(); // 只处理用户表 if (!USER_TABLE.equals(tableName)) { continue; } for (RowData rowData : rowChange.getRowDatasList()) { if (eventType == EventType.DELETE) { handleDelete(rowData.getBeforeColumnsList()); } else if (eventType == EventType.INSERT) { handleInsert(rowData.getAfterColumnsList()); } else if (eventType == EventType.UPDATE) { handleUpdate(rowData.getAfterColumnsList()); } } } } private void handleInsert(List\u0026lt;Column\u0026gt; columns) { try { User user = buildUserFromColumns(columns); String cacheKey = USER_CACHE_PREFIX + user.getId(); redisTemplate.opsForValue().set(cacheKey, user, 30, TimeUnit.MINUTES); log.info(\u0026#34;Canal同步新增用户到缓存，用户ID: {}\u0026#34;, user.getId()); } catch (Exception e) { log.error(\u0026#34;处理新增用户异常\u0026#34;, e); } } private void handleUpdate(List\u0026lt;Column\u0026gt; columns) { try { User user = buildUserFromColumns(columns); String cacheKey = USER_CACHE_PREFIX + user.getId(); redisTemplate.opsForValue().set(cacheKey, user, 30, TimeUnit.MINUTES); log.info(\u0026#34;Canal同步更新用户到缓存，用户ID: {}\u0026#34;, user.getId()); } catch (Exception e) { log.error(\u0026#34;处理更新用户异常\u0026#34;, e); } } private void handleDelete(List\u0026lt;Column\u0026gt; columns) { try { Long userId = getUserIdFromColumns(columns); String cacheKey = USER_CACHE_PREFIX + userId; redisTemplate.delete(cacheKey); log.info(\u0026#34;Canal同步删除用户缓存，用户ID: {}\u0026#34;, userId); } catch (Exception e) { log.error(\u0026#34;处理删除用户异常\u0026#34;, e); } } private User buildUserFromColumns(List\u0026lt;Column\u0026gt; columns) { User user = new User(); for (Column column : columns) { String name = column.getName(); String value = column.getValue(); switch (name) { case \u0026#34;id\u0026#34;: user.setId(Long.valueOf(value)); break; case \u0026#34;username\u0026#34;: user.setUsername(value); break; case \u0026#34;email\u0026#34;: user.setEmail(value); break; case \u0026#34;phone\u0026#34;: user.setPhone(value); break; case \u0026#34;create_time\u0026#34;: user.setCreateTime(LocalDateTime.parse(value)); break; case \u0026#34;update_time\u0026#34;: user.setUpdateTime(LocalDateTime.parse(value)); break; } } return user; } private Long getUserIdFromColumns(List\u0026lt;Column\u0026gt; columns) { for (Column column : columns) { if (\u0026#34;id\u0026#34;.equals(column.getName())) { return Long.valueOf(column.getValue()); } } return null; } } 优点 数据库是最终数据源，Canal 保证数据库和缓存高度一致 适合强一致性、读写频繁的场景 缺点 Canal 部署和维护成本较高 实时性取决于 Binlog 解析和消费速度 通俗类比 就像你给家里装了一个监控（Canal），每次有人开门换锁（数据库更新），监控立刻通知保安（Redis 更新）。\n三、方案对比总结 方案 一致性 性能 复杂度 适用场景 Cache Aside 弱一致性 高 低 读多写少，数据允许短暂不一致 延时双删 较强一致性 中 中 能容忍短延迟，写请求较多时 加锁策略 强一致性 低 中 金融、电商等对一致性要求高 消息队列同步 最终一致性 高 高 高并发、异步场景 Canal Binlog 同步 准实时强一致性 中 高 核心业务，强一致要求 四、最佳实践建议 读多写少，数据允许短暂不一致 → 使用 Cache Aside 高并发写场景 → 延时双删 + 合理时间窗口 金融、交易业务 → 分布式读写锁，保证强一致性 高可扩展、高并发 → 数据库写 + MQ 异步更新缓存 企业级核心业务 → Binlog + Canal，保证数据库与缓存实时同步 五、实际项目中的综合方案 在实际项目中，往往需要根据不同的业务场景采用不同的策略：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Service public class UserServiceComprehensive { @Autowired private UserMapper userMapper; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Autowired private RedissonClient redissonClient; @Autowired private RabbitTemplate rabbitTemplate; private static final String USER_CACHE_PREFIX = \u0026#34;user:\u0026#34;; private static final String LOCK_PREFIX = \u0026#34;lock:user:\u0026#34;; /** * 根据业务类型选择不同的缓存策略 */ public User getUser(Long userId, CacheStrategy strategy) { switch (strategy) { case CACHE_ASIDE: return getUserWithCacheAside(userId); case READ_WRITE_LOCK: return getUserWithReadWriteLock(userId); case MQ_SYNC: return getUserWithMQSync(userId); default: return getUserWithCacheAside(userId); } } /** * 根据业务类型选择不同的更新策略 */ public boolean updateUser(User user, CacheStrategy strategy) { switch (strategy) { case CACHE_ASIDE: return updateUserWithCacheAside(user); case DELAY_DOUBLE_DELETE: return updateUserWithDelayDoubleDelete(user); case READ_WRITE_LOCK: return updateUserWithReadWriteLock(user); case MQ_SYNC: return updateUserWithMQSync(user); default: return updateUserWithCacheAside(user); } } // 各种策略的具体实现... } enum CacheStrategy { CACHE_ASIDE, // 旁路缓存 DELAY_DOUBLE_DELETE, // 延时双删 READ_WRITE_LOCK, // 读写锁 MQ_SYNC, // 消息队列同步 CANAL_SYNC // Canal同步 } 六、监控和告警 为了保证缓存一致性，还需要完善的监控体系：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @Component public class CacheConsistencyMonitor { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Autowired private UserMapper userMapper; /** * 定期检查缓存一致性 */ @Scheduled(fixedRate = 300000) // 5分钟检查一次 public void checkCacheConsistency() { // 随机抽样检查缓存一致性 List\u0026lt;Long\u0026gt; userIds = getRandomUserIds(100); for (Long userId : userIds) { try { // 1. 查询数据库 User dbUser = userMapper.selectById(userId); // 2. 查询缓存 String cacheKey = \u0026#34;user:\u0026#34; + userId; User cacheUser = (User) redisTemplate.opsForValue().get(cacheKey); // 3. 比较数据 if (dbUser != null \u0026amp;\u0026amp; cacheUser != null) { if (!Objects.equals(dbUser.getUsername(), cacheUser.getUsername()) || !Objects.equals(dbUser.getEmail(), cacheUser.getEmail())) { // 数据不一致，记录告警 log.warn(\u0026#34;发现缓存不一致，用户ID: {}, 数据库: {}, 缓存: {}\u0026#34;, userId, dbUser, cacheUser); // 修复缓存 redisTemplate.opsForValue().set(cacheKey, dbUser, 30, TimeUnit.MINUTES); } } } catch (Exception e) { log.error(\u0026#34;检查缓存一致性异常，用户ID: {}\u0026#34;, userId, e); } } } private List\u0026lt;Long\u0026gt; getRandomUserIds(int count) { // 实现随机获取用户ID的逻辑 return userMapper.selectRandomUserIds(count); } } 七、结语 数据库与 Redis 的一致性问题，本质是 如何处理\u0026quot;两个副本数据的不同步\u0026quot;。\n没有一种万能方案，需要结合业务特点选择：\n性能优先 → Cache Aside 一致性优先 → 加锁 / Canal 折中 → 延时双删 / MQ 在真实项目中，往往是 多种方案结合 使用，才能既保证性能，又保证数据可靠。\n通过本文的详细分析和代码示例，相信你已经对缓存一致性问题有了深入的理解。在实际开发中，要根据具体的业务场景、性能要求、一致性要求来选择最适合的方案，并在必要时结合多种策略来实现最佳效果。\n本文档详细介绍了数据库与Redis双写一致性问题的各种解决方案，并提供了完整的代码实现示例，帮助开发者在实际项目中做出正确的技术选择。\n","date":"2025-08-14T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E-redis-%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E5%85%A8%E8%A7%A3%E6%9E%90/","title":"数据库与 Redis 双写一致性问题全解析"},{"content":"Spring Boot JWT 与拦截器详解：BaseContext、HandlerMethod、HttpServletRequest 与 instanceof 在开发 Java Web 项目时，经常会用到 JWT 鉴权、拦截器以及请求上下文管理。本文结合一个咖啡购物车项目，详细讲解相关概念和代码实现。\n📋 目录 HttpServletRequest 是什么？ Controller 方法为什么有时需要 HttpServletRequest？ 注释解析：\u0026ldquo;从请求头中获取用户ID\u0026rdquo; JwtTokenUserInterceptor 拦截器详解 Long userId = Long.valueOf(claims.get(\u0026ldquo;userId\u0026rdquo;).toString()); 解析 BaseContext 是什么？ 判断 handler 是否是 Controller 方法 instanceof 是什么？ 完整项目实战 最佳实践与注意事项 总结与流程图示意 1. HttpServletRequest 是什么？ HttpServletRequest 是 Java Servlet API 提供的接口，用来封装客户端发给服务器的请求信息。\n🔧 核心功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 获取请求方式、路径 request.getMethod() // GET / POST request.getRequestURI() // /cart/list // 获取请求头 request.getHeader(\u0026#34;Authorization\u0026#34;) request.getHeader(\u0026#34;User-Agent\u0026#34;) // 获取请求参数 request.getParameter(\u0026#34;name\u0026#34;) request.getParameterMap() // 获取请求体（POST JSON 或表单） request.getReader() // 获取客户端信息 request.getRemoteAddr() // IP地址 request.getHeader(\u0026#34;User-Agent\u0026#34;) // 浏览器信息 // 获取会话信息 request.getSession() 💡 实际应用场景 在我们的咖啡项目中，HttpServletRequest 主要用于：\nJWT Token 获取：从 Authorization 请求头中提取 JWT Token 用户身份识别：解析 Token 获取用户 ID 请求日志记录：记录客户端 IP、User-Agent 等信息 跨域处理：获取 Origin 请求头进行跨域验证 2. Controller 方法为什么有时需要 HttpServletRequest？ ✅ 不需要 HttpServletRequest 的情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController @RequestMapping(\u0026#34;/products\u0026#34;) public class ProductController { // 只需要业务参数，Spring 自动绑定 @GetMapping(\u0026#34;/{id}\u0026#34;) public Result\u0026lt;Product\u0026gt; getProduct(@PathVariable Long id) { return productService.getById(id); } @PostMapping public Result\u0026lt;String\u0026gt; createProduct(@RequestBody ProductDTO productDTO) { return productService.create(productDTO); } } ❌ 需要 HttpServletRequest 的情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { @Autowired private JwtProperties jwtProperties; /** * 需要获取当前登录用户信息 */ @GetMapping(\u0026#34;/profile\u0026#34;) public Result\u0026lt;UserProfile\u0026gt; getProfile(HttpServletRequest request) { // 从请求头中获取用户ID Long userId = getCurrentUserId(request); return userService.getProfile(userId); } /** * 从请求中获取当前用户ID */ private Long getCurrentUserId(HttpServletRequest request) { String token = request.getHeader(\u0026#34;Authorization\u0026#34;); if (token != null \u0026amp;\u0026amp; token.startsWith(\u0026#34;Bearer \u0026#34;)) { token = token.substring(7); } try { Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token); return Long.valueOf(claims.get(\u0026#34;userId\u0026#34;).toString()); } catch (Exception e) { log.error(\u0026#34;解析token失败\u0026#34;, e); throw new RuntimeException(\u0026#34;无效的token\u0026#34;); } } } 🎯 使用场景总结 场景 是否需要 HttpServletRequest 原因 获取请求头信息 ✅ 需要 如 JWT Token、User-Agent 获取客户端 IP ✅ 需要 安全审计、限流 获取 Session 信息 ✅ 需要 会话管理 获取 Cookie ✅ 需要 状态保持 纯业务参数处理 ❌ 不需要 Spring 自动绑定 3. 注释解析：\u0026ldquo;从请求头中获取用户ID\u0026rdquo; 📝 注释含义解析 1 // 从请求头中获取用户ID（这里需要根据你的JWT实现来获取） 这个注释的含义是：\n用户登录流程：用户登录后，前端会拿到一个 JWT Token Token 传递：前端每次请求时，将 Token 放在请求头中（Authorization: Bearer \u0026lt;token\u0026gt;） 后端解析：后端解析 JWT Token 获取 userId 注释说明：目前代码直接从请求头取 userId，在真实项目中要解析 JWT Token 🔄 完整流程示意 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sequenceDiagram participant F as 前端 participant B as 后端 participant J as JWT工具 F-\u0026gt;\u0026gt;B: 登录请求 B-\u0026gt;\u0026gt;J: 生成JWT Token J--\u0026gt;\u0026gt;B: 返回Token B--\u0026gt;\u0026gt;F: 返回Token Note over F: 存储Token到localStorage F-\u0026gt;\u0026gt;B: 业务请求 + Authorization: Bearer \u0026lt;token\u0026gt; B-\u0026gt;\u0026gt;J: 解析Token J--\u0026gt;\u0026gt;B: 返回Claims(userId) B-\u0026gt;\u0026gt;B: 从Claims中提取userId B--\u0026gt;\u0026gt;F: 返回业务数据 4. JwtTokenUserInterceptor 拦截器详解 🏗️ 完整拦截器实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @Component @Slf4j public class JwtTokenUserInterceptor implements HandlerInterceptor { @Autowired private JwtProperties jwtProperties; /** * 请求处理前的拦截逻辑 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 1. 判断当前拦截到的是Controller的方法还是其他资源 if (!(handler instanceof HandlerMethod)) { // 当前拦截到的不是动态方法，直接放行（静态资源等） return true; } // 2. 从请求头中获取令牌 String token = request.getHeader(jwtProperties.getUserTokenName()); log.info(\u0026#34;请求头名称: {}\u0026#34;, jwtProperties.getUserTokenName()); log.info(\u0026#34;Authorization头: {}\u0026#34;, request.getHeader(\u0026#34;Authorization\u0026#34;)); // 3. 去掉Bearer前缀 if (token != null \u0026amp;\u0026amp; token.startsWith(\u0026#34;Bearer \u0026#34;)) { token = token.substring(7); } // 4. 校验令牌 try { log.info(\u0026#34;JWT校验: {}\u0026#34;, token); Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token); Long userId = Long.valueOf(claims.get(\u0026#34;userId\u0026#34;).toString()); log.info(\u0026#34;当前用户ID：{}\u0026#34;, userId); // 5. 将用户ID存储到ThreadLocal中 BaseContext.setCurrentId(userId); // 6. 通过，放行 return true; } catch (Exception ex) { log.error(\u0026#34;JWT校验失败: {}\u0026#34;, ex.getMessage()); // 7. 不通过，响应401状态码 response.setStatus(401); return false; } } } 🔍 代码逐行解析 步骤1：判断请求类型 1 2 3 if (!(handler instanceof HandlerMethod)) { return true; // 静态资源直接放行 } 目的：区分 Controller 方法和静态资源请求 原理：Spring MVC 中，每个请求都有一个 handler 来处理 HandlerMethod：Controller 方法的处理器 ResourceHttpRequestHandler：静态资源的处理器 步骤2：获取 JWT Token 1 String token = request.getHeader(jwtProperties.getUserTokenName()); 配置化：通过 JwtProperties 管理请求头名称 灵活性：可以配置不同的请求头名称（如 Authorization、X-Token 等） 步骤3：处理 Bearer 前缀 1 2 3 if (token != null \u0026amp;\u0026amp; token.startsWith(\u0026#34;Bearer \u0026#34;)) { token = token.substring(7); } 标准格式：JWT Token 通常以 Bearer 前缀传输 安全考虑：明确标识 Token 类型，避免与其他认证方式混淆 步骤4：JWT 解析与验证 1 2 Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token); Long userId = Long.valueOf(claims.get(\u0026#34;userId\u0026#34;).toString()); 签名验证：使用相同的密钥验证 Token 签名 过期检查：JWT 库会自动检查 Token 是否过期 Claims 提取：从 JWT 载荷中提取用户信息 步骤5：上下文存储 1 BaseContext.setCurrentId(userId); ThreadLocal：每个请求线程独立存储用户信息 避免传参：Controller 和 Service 层可以直接获取当前用户 ID 5. Long userId = Long.valueOf(claims.get(\u0026ldquo;userId\u0026rdquo;).toString()); 解析 🔄 类型转换过程 1 2 3 4 // 步骤分解 Object userIdObj = claims.get(\u0026#34;userId\u0026#34;); // 1. 从Claims中获取userId（Object类型） String userIdStr = userIdObj.toString(); // 2. 转成字符串 Long userId = Long.valueOf(userIdStr); // 3. 转成Long对象 ⚠️ 潜在问题与解决方案 问题1：类型转换异常 1 2 // 可能抛出 NumberFormatException Long userId = Long.valueOf(claims.get(\u0026#34;userId\u0026#34;).toString()); 解决方案：\n1 2 3 4 5 6 7 8 9 10 11 12 // 安全的类型转换 public static Long getUserIdSafely(Claims claims) { try { Object userIdObj = claims.get(\u0026#34;userId\u0026#34;); if (userIdObj == null) { throw new IllegalArgumentException(\u0026#34;用户ID不能为空\u0026#34;); } return Long.valueOf(userIdObj.toString()); } catch (NumberFormatException e) { throw new IllegalArgumentException(\u0026#34;用户ID格式错误: \u0026#34; + userIdObj); } } 问题2：空值处理 1 2 3 4 5 // 检查空值 Object userIdObj = claims.get(\u0026#34;userId\u0026#34;); if (userIdObj == null) { throw new IllegalArgumentException(\u0026#34;JWT中缺少用户ID\u0026#34;); } 🎯 最佳实践 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 安全地从Claims中获取用户ID */ private Long extractUserId(Claims claims) { Object userIdObj = claims.get(\u0026#34;userId\u0026#34;); if (userIdObj == null) { throw new IllegalArgumentException(\u0026#34;JWT中缺少用户ID\u0026#34;); } try { return Long.valueOf(userIdObj.toString()); } catch (NumberFormatException e) { throw new IllegalArgumentException(\u0026#34;用户ID格式错误: \u0026#34; + userIdObj); } } 6. BaseContext 是什么？ 🏗️ BaseContext 完整实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * 基于ThreadLocal封装工具类，用于保存和获取当前登录用户ID */ public class BaseContext { private static ThreadLocal\u0026lt;Long\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); /** * 设置当前用户ID * @param id 用户ID */ public static void setCurrentId(Long id) { threadLocal.set(id); } /** * 获取当前用户ID * @return 用户ID */ public static Long getCurrentId() { return threadLocal.get(); } /** * 删除当前用户ID（防止内存泄漏） */ public static void removeCurrentId() { threadLocal.remove(); } } 🧵 ThreadLocal 原理 为什么使用 ThreadLocal？ 线程隔离：每个请求线程都有独立的用户信息存储 避免传参：不需要在每个方法中传递用户 ID 代码简洁：Controller 和 Service 层可以直接获取当前用户 ThreadLocal 内存模型 1 2 3 4 5 6 7 8 9 10 11 12 graph TD A[请求线程1] --\u0026gt; B[ThreadLocal Map] C[请求线程2] --\u0026gt; D[ThreadLocal Map] E[请求线程3] --\u0026gt; F[ThreadLocal Map] B --\u0026gt; G[userId: 1001] D --\u0026gt; H[userId: 1002] F --\u0026gt; I[userId: 1003] style A fill:#e1f5fe style C fill:#e8f5e8 style E fill:#fff3e0 🔧 实际使用场景 Controller 层使用 1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\u0026#34;/admin\u0026#34;) public class AdminController { @GetMapping(\u0026#34;/info\u0026#34;) public Result\u0026lt;AdminLoginVO\u0026gt; info() { // 直接获取当前登录管理员ID，无需传参 Long adminId = BaseContext.getCurrentId(); AdminLoginVO adminInfo = adminService.getById(adminId); return Result.success(adminInfo); } } Service 层使用 1 2 3 4 5 6 7 8 9 10 11 12 13 @Service public class OrderServiceImpl implements OrderService { @Override public Result\u0026lt;String\u0026gt; createOrder(OrderDTO orderDTO) { // 直接获取当前用户ID Long userId = BaseContext.getCurrentId(); orderDTO.setUserId(userId); // 业务逻辑处理 return processOrder(orderDTO); } } ⚠️ 内存泄漏防护 问题：ThreadLocal 内存泄漏 1 2 3 4 5 6 // 错误示例：没有清理ThreadLocal public void processRequest() { BaseContext.setCurrentId(1001L); // 处理业务逻辑 // 忘记调用 removeCurrentId() } 解决方案：拦截器后处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component @Slf4j public class JwtTokenUserInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // JWT验证逻辑... BaseContext.setCurrentId(userId); return true; } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // 请求完成后清理ThreadLocal，防止内存泄漏 BaseContext.removeCurrentId(); } } 7. 判断 handler 是否是 Controller 方法 🔍 HandlerMethod 详解 1 2 3 if (!(handler instanceof HandlerMethod)) { return true; // 静态资源直接放行 } Spring MVC 请求处理流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 graph TD A[客户端请求] --\u0026gt; B[DispatcherServlet] B --\u0026gt; C[HandlerMapping] C --\u0026gt; D{请求类型判断} D --\u0026gt;|Controller方法| E[HandlerMethod] D --\u0026gt;|静态资源| F[ResourceHttpRequestHandler] D --\u0026gt;|其他资源| G[其他Handler] E --\u0026gt; H[拦截器链] F --\u0026gt; I[直接处理] G --\u0026gt; I H --\u0026gt; J[Controller方法执行] I --\u0026gt; K[返回资源] J --\u0026gt; L[返回响应] K --\u0026gt; L HandlerMethod vs ResourceHttpRequestHandler 类型 用途 示例 HandlerMethod Controller 方法 @GetMapping(\u0026quot;/users\u0026quot;) ResourceHttpRequestHandler 静态资源 /static/css/style.css RequestMappingHandlerMapping 请求映射 默认的请求处理器 🎯 实际应用场景 场景1：只拦截 Controller 方法 1 2 3 4 5 6 7 8 9 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 只对Controller方法进行JWT验证 if (!(handler instanceof HandlerMethod)) { return true; // 静态资源、健康检查等直接放行 } // JWT验证逻辑... } 场景2：记录所有请求 1 2 3 4 5 6 7 8 9 10 11 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String requestType = handler instanceof HandlerMethod ? \u0026#34;Controller\u0026#34; : \u0026#34;Static\u0026#34;; log.info(\u0026#34;请求类型: {}, 路径: {}\u0026#34;, requestType, request.getRequestURI()); if (!(handler instanceof HandlerMethod)) { return true; } // 其他逻辑... } 8. instanceof 是什么？ 🔧 instanceof 语法详解 instanceof 是 Java 关键字，用于判断对象是否是某个类或接口的实例。\n基本语法 1 object instanceof ClassName 返回值 true：对象是指定类或接口的实例 false：对象不是指定类或接口的实例 📝 实际示例 示例1：基本类型判断 1 2 3 4 5 // 动物类层次结构 Animal animal = new Dog(); System.out.println(animal instanceof Animal); // true System.out.println(animal instanceof Dog); // true System.out.println(animal instanceof Cat); // false 示例2：接口判断 1 2 3 4 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); System.out.println(list instanceof List); // true System.out.println(list instanceof ArrayList); // true System.out.println(list instanceof LinkedList); // false 示例3：null 处理 1 2 String str = null; System.out.println(str instanceof String); // false（null 不是任何类的实例） 🎯 在拦截器中的应用 判断 Handler 类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (handler instanceof HandlerMethod) { // Controller 方法处理 HandlerMethod handlerMethod = (HandlerMethod) handler; log.info(\u0026#34;Controller: {}, Method: {}\u0026#34;, handlerMethod.getBeanType().getSimpleName(), handlerMethod.getMethod().getName()); // JWT 验证逻辑 return validateJWT(request, response); } else if (handler instanceof ResourceHttpRequestHandler) { // 静态资源处理 log.info(\u0026#34;静态资源请求: {}\u0026#34;, request.getRequestURI()); return true; } else { // 其他类型处理 log.info(\u0026#34;其他类型请求: {}\u0026#34;, handler.getClass().getSimpleName()); return true; } } 获取方法信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 if (handler instanceof HandlerMethod) { HandlerMethod handlerMethod = (HandlerMethod) handler; // 获取 Controller 类名 String controllerName = handlerMethod.getBeanType().getSimpleName(); // 获取方法名 String methodName = handlerMethod.getMethod().getName(); // 获取注解信息 RequestMapping mapping = handlerMethod.getMethodAnnotation(RequestMapping.class); log.info(\u0026#34;执行方法: {}.{}\u0026#34;, controllerName, methodName); } 9. 完整项目实战 🏗️ 项目结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 coffee-project/ ├── coffee-common/ # 公共模块 │ ├── src/main/java/com/coffee/ │ │ ├── context/ # 上下文管理 │ │ │ └── BaseContext.java │ │ ├── properties/ # 配置属性 │ │ │ └── JwtProperties.java │ │ └── utils/ # 工具类 │ │ └── JwtUtil.java │ └── pom.xml ├── coffee-server/ # 服务端模块 │ ├── src/main/java/com/coffee/ │ │ ├── config/ # 配置类 │ │ │ └── WebMvcConfiguration.java │ │ ├── interceptor/ # 拦截器 │ │ │ ├── JwtTokenAdminInterceptor.java │ │ │ └── JwtTokenUserInterceptor.java │ │ └── controller/ # 控制器 │ │ ├── admin/ # 管理端 │ │ └── user/ # 用户端 │ └── src/main/resources/ │ └── application.yml # 配置文件 └── pom.xml ⚙️ 配置文件 application.yml 1 2 3 4 5 6 7 8 9 10 11 coffee: jwt: # 管理员JWT配置 admin-secret-key: itcast admin-ttl: 7200000 # 2小时 admin-token-name: Authorization # 用户JWT配置 user-secret-key: itcast user-ttl: 7200000 # 2小时 user-token-name: Authorization JwtProperties.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Data @Component @ConfigurationProperties(prefix = \u0026#34;coffee.jwt\u0026#34;) public class JwtProperties { /** * 管理员JWT签名密钥 */ private String adminSecretKey; /** * 管理员JWT过期时间(毫秒) */ private Long adminTtl; /** * 管理员令牌名称 */ private String adminTokenName; /** * 用户令牌名称 */ private String userTokenName; /** * 用户JWT签名密钥 */ private String userSecretKey; /** * 用户JWT过期时间(毫秒) */ private Long userTtl; } 🔧 拦截器配置 WebMvcConfiguration.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Configuration @Slf4j public class WebMvcConfiguration implements WebMvcConfigurer { @Autowired private JwtTokenAdminInterceptor jwtTokenAdminInterceptor; /** * 注册拦截器 */ @Override public void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;开始注册自定义拦截器...\u0026#34;); // 管理端拦截器 registry.addInterceptor(jwtTokenAdminInterceptor) .addPathPatterns(\u0026#34;/admin/**\u0026#34;) // 拦截管理端所有请求 .excludePathPatterns(\u0026#34;/admin/login\u0026#34;); // 排除登录接口 } /** * 跨域配置 */ @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) .allowedOriginPatterns(\u0026#34;*\u0026#34;) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .allowCredentials(true) .maxAge(3600); } } 🎯 实际使用示例 管理端控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @RestController @RequestMapping(\u0026#34;/admin\u0026#34;) @Slf4j @Api(tags = \u0026#34;管理端相关接口\u0026#34;) public class AdminController { @Autowired private AdminService adminService; /** * 管理员登录（不需要JWT验证） */ @PostMapping(\u0026#34;/login\u0026#34;) @ApiOperation(\u0026#34;管理员登录\u0026#34;) public Result\u0026lt;AdminLoginVO\u0026gt; login(@Valid @RequestBody AdminLoginDTO adminLoginDTO) { log.info(\u0026#34;管理员登录：{}\u0026#34;, adminLoginDTO); AdminLoginVO adminLoginVO = adminService.login(adminLoginDTO); return Result.success(adminLoginVO); } /** * 获取管理员信息（需要JWT验证） */ @GetMapping(\u0026#34;/info\u0026#34;) @ApiOperation(\u0026#34;获取管理员信息\u0026#34;) public Result\u0026lt;AdminLoginVO\u0026gt; info() { // 从ThreadLocal中获取当前登录管理员ID Long adminId = BaseContext.getCurrentId(); AdminLoginVO adminInfo = adminService.getById(adminId); return Result.success(adminInfo); } } 10. 最佳实践与注意事项 ✅ 最佳实践 1. 安全的JWT处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * 安全的JWT解析方法 */ private Long extractUserIdSafely(String token) { if (StringUtils.isBlank(token)) { throw new IllegalArgumentException(\u0026#34;Token不能为空\u0026#34;); } try { Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token); // 检查Token是否过期 if (claims.getExpiration().before(new Date())) { throw new IllegalArgumentException(\u0026#34;Token已过期\u0026#34;); } // 安全地提取用户ID Object userIdObj = claims.get(\u0026#34;userId\u0026#34;); if (userIdObj == null) { throw new IllegalArgumentException(\u0026#34;Token中缺少用户ID\u0026#34;); } return Long.valueOf(userIdObj.toString()); } catch (Exception e) { log.error(\u0026#34;JWT解析失败: {}\u0026#34;, e.getMessage()); throw new IllegalArgumentException(\u0026#34;无效的Token\u0026#34;); } } 2. 完整的拦截器实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @Component @Slf4j public class JwtTokenUserInterceptor implements HandlerInterceptor { @Autowired private JwtProperties jwtProperties; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 1. 只处理Controller方法 if (!(handler instanceof HandlerMethod)) { return true; } // 2. 获取Token String token = extractToken(request); if (StringUtils.isBlank(token)) { sendErrorResponse(response, \u0026#34;缺少认证Token\u0026#34;); return false; } // 3. 验证Token try { Long userId = extractUserIdSafely(token); BaseContext.setCurrentId(userId); return true; } catch (Exception e) { log.error(\u0026#34;JWT验证失败: {}\u0026#34;, e.getMessage()); sendErrorResponse(response, \u0026#34;Token验证失败: \u0026#34; + e.getMessage()); return false; } } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // 清理ThreadLocal，防止内存泄漏 BaseContext.removeCurrentId(); } private String extractToken(HttpServletRequest request) { String token = request.getHeader(jwtProperties.getUserTokenName()); if (token != null \u0026amp;\u0026amp; token.startsWith(\u0026#34;Bearer \u0026#34;)) { return token.substring(7); } return token; } private void sendErrorResponse(HttpServletResponse response, String message) throws IOException { response.setStatus(401); response.setContentType(\u0026#34;application/json;charset=UTF-8\u0026#34;); response.getWriter().write(\u0026#34;{\\\u0026#34;code\\\u0026#34;:401,\\\u0026#34;message\\\u0026#34;:\\\u0026#34;\u0026#34; + message + \u0026#34;\\\u0026#34;}\u0026#34;); } } 3. 异常处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @RestControllerAdvice @Slf4j public class GlobalExceptionHandler { /** * JWT相关异常处理 */ @ExceptionHandler(IllegalArgumentException.class) public Result\u0026lt;String\u0026gt; handleJWTException(IllegalArgumentException e) { log.error(\u0026#34;JWT异常: {}\u0026#34;, e.getMessage()); return Result.error(\u0026#34;认证失败: \u0026#34; + e.getMessage()); } /** * 通用异常处理 */ @ExceptionHandler(Exception.class) public Result\u0026lt;String\u0026gt; handleException(Exception e) { log.error(\u0026#34;系统异常: \u0026#34;, e); return Result.error(\u0026#34;系统异常，请联系管理员\u0026#34;); } } ⚠️ 注意事项 1. 内存泄漏防护 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 错误示例：忘记清理ThreadLocal public void processRequest() { BaseContext.setCurrentId(1001L); // 处理业务逻辑 // 忘记调用 removeCurrentId() } // 正确示例：使用try-finally确保清理 public void processRequest() { try { BaseContext.setCurrentId(1001L); // 处理业务逻辑 } finally { BaseContext.removeCurrentId(); } } 2. 线程安全问题 1 2 3 4 5 6 7 8 9 10 // ThreadLocal是线程安全的，但要注意使用方式 public class BaseContext { // 每个线程都有独立的副本 private static ThreadLocal\u0026lt;Long\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); // 静态方法，线程安全 public static void setCurrentId(Long id) { threadLocal.set(id); } } 3. JWT密钥管理 1 2 3 4 5 # 生产环境配置 coffee: jwt: admin-secret-key: ${JWT_ADMIN_SECRET:default-secret} user-secret-key: ${JWT_USER_SECRET:default-secret} 11. 总结与流程图示意 🔄 完整请求流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 sequenceDiagram participant C as 客户端 participant D as DispatcherServlet participant I as 拦截器 participant H as HandlerMethod participant B as BaseContext participant S as Service C-\u0026gt;\u0026gt;D: HTTP请求 + Authorization头 D-\u0026gt;\u0026gt;I: 请求进入拦截器 I-\u0026gt;\u0026gt;I: 检查handler instanceof HandlerMethod I-\u0026gt;\u0026gt;I: 提取JWT Token I-\u0026gt;\u0026gt;I: 解析Token获取Claims I-\u0026gt;\u0026gt;B: BaseContext.setCurrentId(userId) I-\u0026gt;\u0026gt;H: 放行到Controller H-\u0026gt;\u0026gt;B: BaseContext.getCurrentId() B--\u0026gt;\u0026gt;H: 返回userId H-\u0026gt;\u0026gt;S: 调用Service方法 S-\u0026gt;\u0026gt;B: BaseContext.getCurrentId() B--\u0026gt;\u0026gt;S: 返回userId S--\u0026gt;\u0026gt;H: 返回业务数据 H--\u0026gt;\u0026gt;C: 返回响应 Note over I: 请求完成后清理ThreadLocal I-\u0026gt;\u0026gt;B: BaseContext.removeCurrentId() 📊 核心概念总结 概念 作用 关键点 HttpServletRequest 封装请求信息 获取Header、参数、Session等 HandlerMethod Controller方法处理器 区分Controller和静态资源 instanceof 类型判断 判断对象类型，确保类型安全 BaseContext 线程上下文 ThreadLocal存储用户信息 JWT拦截器 统一认证 自动解析Token，设置用户上下文 🎯 技术要点 HttpServletRequest：封装请求信息，可以获取 Header、参数、Session、客户端信息等 JWT + 拦截器：统一解析用户身份，拦截未授权请求 BaseContext：存储当前请求的用户信息（ThreadLocal），避免传参麻烦 handler \u0026amp; HandlerMethod：判断请求处理对象类型，区分 Controller 与静态资源 instanceof：判断对象类型，是 Java 的基础语法 🚀 项目优势 统一认证：通过拦截器实现JWT统一验证 代码简洁：使用BaseContext避免层层传参 类型安全：通过instanceof确保类型正确性 内存安全：正确使用ThreadLocal，避免内存泄漏 配置灵活：通过配置文件管理JWT参数 这篇博客详细解析了Spring Boot中JWT鉴权、拦截器实现的核心原理，结合实际项目代码，让你深入理解用户认证的底层流程。通过掌握这些技术要点，你可以构建更加健壮和安全的Web应用系统。\n💡 提示：本文基于咖啡购物车项目实战，所有代码示例都经过实际测试验证。如果你有任何问题或建议，欢迎在评论区讨论！\n","date":"2025-01-27T10:00:00+08:00","permalink":"https://Yin123-ybh.github.io/p/spring-boot-jwt-%E4%B8%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%A6%E8%A7%A3basecontexthandlermethodhttpservletrequest-%E4%B8%8E-instanceof/","title":"Spring Boot JWT 与拦截器详解：BaseContext、HandlerMethod、HttpServletRequest 与 instanceof"},{"content":"Hash咖啡项目后端改造指南 - 第一部分：项目概述和数据库设计 目录 项目概述 技术栈说明 整体架构设计 数据库设计完善 下一步计划 项目概述 本指南将基于现有的Hash咖啡项目，实现一个完整的分布式秒杀系统，包含以下核心功能：\n分布式锁防超卖：基于Redisson和Lua脚本实现高并发场景下的库存控制 消息队列解耦：RabbitMQ异步处理订单支付和积分系统 多端支持：管理端、用户端、微信小程序统一后端服务 完整部署：Docker + Nginx配置，支持生产环境部署 功能目标 实现高并发的秒杀活动系统 防止超卖和重复参与 支持分布式部署 提供用户友好的界面 保证数据一致性和系统稳定性 技术栈说明 组件 技术选型 版本 作用 后端框架 Spring Boot 2.7.3 主框架，提供基础功能 数据库 MySQL 8.0 数据持久化存储 缓存 Redis 6.2 缓存和分布式锁 消息队列 RabbitMQ 3.9 异步消息处理 分布式锁 Redisson 3.17.7 防超卖和并发控制 管理端前端 Vue.js + Element UI - 管理端界面（苍穹外卖前端-frontend） 用户端 UniApp - 微信小程序用户端（project-rjwm-weixin-uniapp-develop-wsy） 反向代理 Nginx - 负载均衡和静态资源服务 核心技术特性 高并发处理：Redis缓存 + 分布式锁 异步解耦：RabbitMQ消息队列 数据一致性：Lua脚本保证原子性操作 系统监控：健康检查和日志记录 限流保护：Nginx层面的请求限流 整体架构设计 架构图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ┌─────────────────────────────────┐ ┌─────────────────────────────────┐ │ 管理端前端 │ │ 微信小程序用户端 │ │ Hash咖啡前端-frontend │ │ project-rjwm-weixin-uniapp- │ │ Vue.js + Element UI │ │ develop-wsy (UniApp) │ └─────────────┬───────────────────┘ └─────────────┬───────────────────┘ │ │ └──────────────────┬───────────────────┘ │ ┌─────────────┴─────────────┐ │ Nginx 反向代理 │ │ (负载均衡 + 限流) │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ Hash Coffee 后端 │ │ Spring Boot + MyBatis │ │ (端口: 8084) │ └─────────────┬─────────────┘ │ ┌────────────────────────┼────────────────────────┐ │ │ │ ┌───────┴────────┐ ┌─────────┴─────────┐ ┌─────────┴─────────┐ │ Redis 缓存 │ │ RabbitMQ 消息队列 │ │ Redisson 分布式锁 │ │ 分布式锁+秒杀缓存│ │ 异步处理+延迟消息 │ │ 防超卖+幂等性 │ │ (端口: 6379) │ │ (端口: 5672) │ │ │ └────────────────┘ └───────────────────┘ └───────────────────┘ │ │ │ └───────────────────────┼────────────────────────┘ │ ┌─────────────┴─────────────┐ │ MySQL 数据库 │ │ (主从复制 + 事务) │ │ (端口: 3306) │ └───────────────────────────┘ 数据流向 管理员访问流程：\n管理员通过管理端前端(Vue.js)发起请求 Nginx接收请求并进行反向代理 后端服务处理业务逻辑 返回响应给管理员 用户访问流程：\n用户通过微信小程序(UniApp)发起请求 Nginx接收请求并进行反向代理 后端服务处理业务逻辑 返回响应给用户 秒杀流程：\n用户参与秒杀活动 Redis分布式锁防止重复参与 Lua脚本保证库存扣减原子性 异步创建订单和更新数据库 消息队列流程：\n订单支付成功后发送消息 RabbitMQ异步处理积分计算 解耦支付服务和积分服务 数据库设计完善 现有数据库表结构 项目已经包含了完整的数据库设计（script3.sql），主要包括：\n核心业务表 1. 秒杀活动表 (seckill_activity)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 CREATE TABLE seckill_activity ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;活动ID\u0026#39; PRIMARY KEY, name VARCHAR(100) NOT NULL COMMENT \u0026#39;活动名称\u0026#39;, description TEXT COMMENT \u0026#39;活动描述\u0026#39;, dish_id BIGINT NOT NULL COMMENT \u0026#39;菜品ID\u0026#39;, seckill_price DECIMAL(10,2) NOT NULL COMMENT \u0026#39;秒杀价格\u0026#39;, original_price DECIMAL(10,2) NOT NULL COMMENT \u0026#39;原价\u0026#39;, stock INT NOT NULL COMMENT \u0026#39;秒杀库存\u0026#39;, sold_count INT DEFAULT 0 COMMENT \u0026#39;已售数量\u0026#39;, per_user_limit INT DEFAULT 1 COMMENT \u0026#39;每人限购数量\u0026#39;, start_time DATETIME NOT NULL COMMENT \u0026#39;开始时间\u0026#39;, end_time DATETIME NOT NULL COMMENT \u0026#39;结束时间\u0026#39;, status TINYINT(1) DEFAULT 1 COMMENT \u0026#39;状态：1-启用，0-禁用\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, create_user BIGINT COMMENT \u0026#39;创建人\u0026#39;, update_user BIGINT COMMENT \u0026#39;修改人\u0026#39; ); 2. 秒杀订单表 (seckill_order)\n1 2 3 4 5 6 7 8 9 10 11 12 CREATE TABLE seckill_order ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;主键ID\u0026#39; PRIMARY KEY, activity_id BIGINT NOT NULL COMMENT \u0026#39;秒杀活动ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, dish_id BIGINT NOT NULL COMMENT \u0026#39;商品ID\u0026#39;, quantity INT NOT NULL COMMENT \u0026#39;购买数量\u0026#39;, seckill_price DECIMAL(10,2) NOT NULL COMMENT \u0026#39;秒杀价格\u0026#39;, total_amount DECIMAL(10,2) NOT NULL COMMENT \u0026#39;总金额\u0026#39;, status TINYINT(1) DEFAULT 0 COMMENT \u0026#39;订单状态：0-待支付，1-已支付，2-已取消\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39; ); 3. 秒杀参与记录表 (seckill_participant)\n1 2 3 4 5 6 7 8 9 10 CREATE TABLE seckill_participant ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;主键ID\u0026#39; PRIMARY KEY, activity_id BIGINT NOT NULL COMMENT \u0026#39;秒杀活动ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, quantity INT NOT NULL COMMENT \u0026#39;参与数量\u0026#39;, status TINYINT(1) DEFAULT 0 COMMENT \u0026#39;状态：0-待处理，1-成功，2-失败\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, UNIQUE KEY uk_user_activity (user_id, activity_id) ); 4. 库存扣减记录表 (seckill_stock_log)\n1 2 3 4 5 6 7 8 9 10 CREATE TABLE seckill_stock_log ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;主键ID\u0026#39; PRIMARY KEY, activity_id BIGINT NOT NULL COMMENT \u0026#39;秒杀活动ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, quantity INT NOT NULL COMMENT \u0026#39;扣减数量\u0026#39;, before_stock INT NOT NULL COMMENT \u0026#39;扣减前库存\u0026#39;, after_stock INT NOT NULL COMMENT \u0026#39;扣减后库存\u0026#39;, status TINYINT(1) DEFAULT 1 COMMENT \u0026#39;状态：1-成功，0-失败\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39; ); 优惠券相关表 5. 优惠券模板表 (coupon_template)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CREATE TABLE coupon_template ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;模板ID\u0026#39; PRIMARY KEY, name VARCHAR(100) NOT NULL COMMENT \u0026#39;优惠券名称\u0026#39;, description VARCHAR(500) COMMENT \u0026#39;优惠券描述\u0026#39;, type TINYINT(1) NOT NULL COMMENT \u0026#39;优惠券类型：1-满减券，2-折扣券，3-代金券\u0026#39;, discount_type TINYINT(1) NOT NULL COMMENT \u0026#39;折扣类型：1-固定金额，2-百分比\u0026#39;, discount_value DECIMAL(10,2) NOT NULL COMMENT \u0026#39;折扣值\u0026#39;, min_amount DECIMAL(10,2) DEFAULT 0.00 COMMENT \u0026#39;最低消费金额\u0026#39;, total_count INT NOT NULL COMMENT \u0026#39;发放总数量\u0026#39;, used_count INT DEFAULT 0 COMMENT \u0026#39;已使用数量\u0026#39;, per_user_limit INT DEFAULT 1 COMMENT \u0026#39;每人限领数量\u0026#39;, valid_days INT COMMENT \u0026#39;有效天数\u0026#39;, start_time DATETIME NOT NULL COMMENT \u0026#39;开始时间\u0026#39;, end_time DATETIME NOT NULL COMMENT \u0026#39;结束时间\u0026#39;, status TINYINT(1) DEFAULT 1 COMMENT \u0026#39;状态：1-启用，0-禁用\u0026#39; ); 6. 优惠券表 (coupon)\n1 2 3 4 5 6 7 8 9 10 11 12 CREATE TABLE coupon ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;优惠券ID\u0026#39; PRIMARY KEY, template_id BIGINT NOT NULL COMMENT \u0026#39;模板ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, code VARCHAR(32) NOT NULL COMMENT \u0026#39;优惠券码\u0026#39;, status TINYINT(1) DEFAULT 0 COMMENT \u0026#39;状态：0-未使用，1-已使用，2-已过期\u0026#39;, used_time DATETIME COMMENT \u0026#39;使用时间\u0026#39;, order_id BIGINT COMMENT \u0026#39;使用订单ID\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, UNIQUE KEY uk_code (code) ); 系统配置表 7. 系统配置表 (system_config)\n1 2 3 4 5 6 7 8 9 CREATE TABLE system_config ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;ID\u0026#39; PRIMARY KEY, config_key VARCHAR(100) NOT NULL COMMENT \u0026#39;配置键\u0026#39;, config_value TEXT COMMENT \u0026#39;配置值\u0026#39;, description VARCHAR(255) COMMENT \u0026#39;描述\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, UNIQUE KEY uk_config_key (config_key) ); 8. 用户积分记录表 (user_points_log)\n1 2 3 4 5 6 7 8 9 CREATE TABLE user_points_log ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;ID\u0026#39; PRIMARY KEY, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, order_id BIGINT COMMENT \u0026#39;订单ID\u0026#39;, points INT NOT NULL COMMENT \u0026#39;积分变化\u0026#39;, type TINYINT(1) NOT NULL COMMENT \u0026#39;类型：1-获得，2-消费\u0026#39;, description VARCHAR(255) COMMENT \u0026#39;描述\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39; ); 数据库索引优化 为了提升查询性能，建议添加以下索引：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 秒杀活动表索引 CREATE INDEX idx_seckill_time_status ON seckill_activity(start_time, end_time, status); CREATE INDEX idx_seckill_dish_time ON seckill_activity(dish_id, start_time, end_time, status); -- 秒杀订单表索引 CREATE INDEX idx_seckill_order_user_time ON seckill_order(user_id, create_time); CREATE INDEX idx_seckill_order_activity_status ON seckill_order(activity_id, status); -- 秒杀参与记录表索引 CREATE INDEX idx_participant_activity ON seckill_participant(activity_id); CREATE INDEX idx_participant_user ON seckill_participant(user_id); -- 优惠券表索引 CREATE INDEX idx_coupon_user_status ON coupon(user_id, status); CREATE INDEX idx_coupon_template_time ON coupon_template(start_time, end_time, status); 数据库设计特点 完整性：包含秒杀活动的完整生命周期管理 一致性：通过外键约束保证数据一致性 性能：合理的索引设计提升查询效率 扩展性：预留字段支持未来功能扩展 审计：完整的创建和更新时间记录 下一步计划 在接下来的部分中，我们将详细讲解：\n第二部分：实体类和分布式锁实现\n实体类设计（SeckillParticipant、SeckillOrder、SeckillStockLog） DTO类创建（SeckillParticipateDTO、SeckillOrderDTO） Mapper接口实现和XML配置 分布式锁服务（DistributedLockService） Lua脚本实现（防超卖核心逻辑） 服务层增强（SeckillActivityServiceImpl） 第三部分：消息队列和API接口\nRabbitMQ配置和消息队列架构 消息实体类设计（OrderPayMessage、PointsEarnMessage等） 消息生产者服务（MessageProducerService） 消息消费者服务（MessageConsumerService） API接口开发（用户端控制器） 配置文件完善和部署测试 每个部分都会提供完整的代码示例和详细的实现说明，确保你可以按照指南逐步完成后端改造。\n继续阅读：Hash咖啡后端改造指南 - 第二部分：实体类和分布式锁实现\n","date":"2025-01-14T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/hash%E5%92%96%E5%95%A1%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E6%94%B9%E9%80%A0%E6%8C%87%E5%8D%97-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","title":"Hash咖啡项目后端改造指南 - 第一部分：项目概述和数据库设计"},{"content":"Hash咖啡后端改造指南-第三部分-消息队列和API接口 目录 项目概述 消息队列配置 消息实体类 消息生产者服务 消息消费者服务 API接口实现 Nginx配置 部署注意事项 消息队列高级特性 流控和熔断 监控和告警 性能优化 安全防护 测试策略 概述 本部分主要介绍Hash咖啡项目中消息队列RabbitMQ的配置、消息生产者/消费者实现，以及用户端API接口的开发。通过消息队列解耦用户支付服务和积分服务，构建异步通信架构，同时实现延迟消息插件处理超时未支付订单的自动取消。\n1. RabbitMQ配置 1.1 RabbitMQ配置类 文件位置: sky-server/src/main/java/com/sky/config/RabbitMQConfig.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 package com.sky.config; import org.springframework.amqp.core.*; import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.amqp.rabbit.listener.RabbitListenerContainerFactory; import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * RabbitMQ配置 * 配置消息队列、交换机、路由等，支持异步消息处理 */ @Configuration public class RabbitMQConfig { // 订单相关队列 public static final String ORDER_QUEUE = \u0026#34;order.queue\u0026#34;; public static final String ORDER_EXCHANGE = \u0026#34;order.exchange\u0026#34;; public static final String ORDER_ROUTING_KEY = \u0026#34;order.pay\u0026#34;; // 积分相关队列 public static final String POINTS_QUEUE = \u0026#34;points.queue\u0026#34;; public static final String POINTS_EXCHANGE = \u0026#34;points.exchange\u0026#34;; public static final String POINTS_ROUTING_KEY = \u0026#34;points.earn\u0026#34;; // 订单超时队列 public static final String ORDER_TIMEOUT_QUEUE = \u0026#34;order.timeout.queue\u0026#34;; public static final String ORDER_TIMEOUT_EXCHANGE = \u0026#34;order.timeout.exchange\u0026#34;; public static final String ORDER_TIMEOUT_ROUTING_KEY = \u0026#34;order.timeout\u0026#34;; // 死信队列 public static final String ORDER_DLX_QUEUE = \u0026#34;order.dlx.queue\u0026#34;; public static final String ORDER_DLX_EXCHANGE = \u0026#34;order.dlx.exchange\u0026#34;; public static final String ORDER_DLX_ROUTING_KEY = \u0026#34;order.dlx\u0026#34;; /** * 消息转换器 * 使用Jackson2JsonMessageConverter进行JSON序列化 */ @Bean public Jackson2JsonMessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); } /** * RabbitTemplate配置 * 配置消息发送模板，支持消息确认和返回机制 */ @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate template = new RabbitTemplate(connectionFactory); template.setMessageConverter(messageConverter()); template.setMandatory(true); template.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -\u0026gt; { System.out.println(\u0026#34;消息发送失败: \u0026#34; + message + \u0026#34;, 原因: \u0026#34; + replyText); }); return template; } /** * 消费者容器工厂配置 * 配置消费者参数，支持手动确认和限流 */ @Bean public RabbitListenerContainerFactory\u0026lt;?\u0026gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory) { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); factory.setMessageConverter(messageConverter()); factory.setAcknowledgeMode(AcknowledgeMode.MANUAL); factory.setConcurrentConsumers(3); factory.setMaxConcurrentConsumers(10); factory.setPrefetchCount(1); return factory; } // ========== 订单相关配置 ========== /** * 订单交换机 * 使用DirectExchange，支持精确路由 */ @Bean public DirectExchange orderExchange() { return new DirectExchange(ORDER_EXCHANGE, true, false); } /** * 订单队列 * 持久化队列，支持消息持久化 */ @Bean public Queue orderQueue() { return QueueBuilder.durable(ORDER_QUEUE).build(); } /** * 订单队列绑定 * 绑定队列到交换机，设置路由键 */ @Bean public Binding orderBinding() { return BindingBuilder.bind(orderQueue()).to(orderExchange()).with(ORDER_ROUTING_KEY); } // ========== 积分相关配置 ========== /** * 积分交换机 * 使用DirectExchange，支持精确路由 */ @Bean public DirectExchange pointsExchange() { return new DirectExchange(POINTS_EXCHANGE, true, false); } /** * 积分队列 * 持久化队列，支持消息持久化 */ @Bean public Queue pointsQueue() { return QueueBuilder.durable(POINTS_QUEUE).build(); } /** * 积分队列绑定 * 绑定队列到交换机，设置路由键 */ @Bean public Binding pointsBinding() { return BindingBuilder.bind(pointsQueue()).to(pointsExchange()).with(POINTS_ROUTING_KEY); } // ========== 订单超时相关配置 ========== /** * 订单超时交换机 * 使用DirectExchange，支持精确路由 */ @Bean public DirectExchange orderTimeoutExchange() { return new DirectExchange(ORDER_TIMEOUT_EXCHANGE, true, false); } /** * 订单超时队列 * 持久化队列，支持消息持久化 */ @Bean public Queue orderTimeoutQueue() { return QueueBuilder.durable(ORDER_TIMEOUT_QUEUE).build(); } /** * 订单超时队列绑定 * 绑定队列到交换机，设置路由键 */ @Bean public Binding orderTimeoutBinding() { return BindingBuilder.bind(orderTimeoutQueue()).to(orderTimeoutExchange()).with(ORDER_TIMEOUT_ROUTING_KEY); } // ========== 死信队列配置 ========== /** * 死信交换机 * 使用DirectExchange，支持精确路由 */ @Bean public DirectExchange orderDlxExchange() { return new DirectExchange(ORDER_DLX_EXCHANGE, true, false); } /** * 死信队列 * 持久化队列，支持消息持久化 */ @Bean public Queue orderDlxQueue() { return QueueBuilder.durable(ORDER_DLX_QUEUE).build(); } /** * 死信队列绑定 * 绑定队列到交换机，设置路由键 */ @Bean public Binding orderDlxBinding() { return BindingBuilder.bind(orderDlxQueue()).to(orderDlxExchange()).with(ORDER_DLX_ROUTING_KEY); } } 配置特点:\n消息持久化: 确保消息不丢失 手动确认: 提高消息处理可靠性 限流配置: 防止消费者过载 死信队列: 处理失败消息 1.2 配置文件更新 文件位置: sky-server/src/main/resources/application.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 # 在现有配置基础上添加以下配置 spring: # RabbitMQ配置 rabbitmq: host: ${sky.rabbitmq.host:localhost} port: ${sky.rabbitmq.port:5672} username: ${sky.rabbitmq.username:guest} password: ${sky.rabbitmq.password:guest} virtual-host: ${sky.rabbitmq.virtual-host:/} connection-timeout: 15000 publisher-confirm-type: correlated publisher-returns: true listener: simple: acknowledge-mode: manual retry: enabled: true max-attempts: 3 initial-interval: 1000 max-interval: 10000 multiplier: 2 concurrency: 3 max-concurrency: 10 prefetch: 1 # Redis配置 redis: host: ${sky.redis.host} port: ${sky.redis.port} database: ${sky.redis.database} password: ${sky.redis.password} timeout: 5000ms lettuce: pool: max-active: 8 max-wait: -1ms max-idle: 8 min-idle: 0 # 日志配置 logging: level: com: sky: mapper: debug service: info controller: info org.springframework.amqp: debug pattern: console: \u0026#34;%clr(%d{yyyy-MM-dd HH:mm:ss}){faint} %clr([%thread]){faint} %clr(%-5level) %clr(%logger{36}){cyan} %clr(-){faint} %msg%n\u0026#34; file: \u0026#34;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\u0026#34; file: name: logs/sky-server.log max-size: 100MB max-history: 30 # 自定义配置 sky: redis: seckill: prefix: \u0026#34;seckill:\u0026#34; 配置说明:\n连接配置: 支持环境变量配置 确认机制: 支持消息确认和返回 重试机制: 支持消息重试 限流配置: 支持消费者限流 2. 消息生产者服务 2.1 消息生产者接口 文件位置: sky-server/src/main/java/com/sky/service/MessageProducerService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.sky.service; import com.sky.entity.message.OrderPayMessage; import com.sky.entity.message.OrderTimeoutMessage; import com.sky.entity.message.PointsEarnMessage; /** * 消息生产者服务接口 * 定义消息发送的接口规范 */ public interface MessageProducerService { /** * 发送订单支付消息 * @param message 订单支付消息 */ void sendOrderPayMessage(OrderPayMessage message); /** * 发送积分获得消息 * @param message 积分获得消息 */ void sendPointsEarnMessage(PointsEarnMessage message); /** * 发送订单超时消息 * @param message 订单超时消息 */ void sendOrderTimeoutMessage(OrderTimeoutMessage message); } 2.2 消息生产者实现 文件位置: sky-server/src/main/java/com/sky/service/impl/MessageProducerServiceImpl.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package com.sky.service.impl; import com.sky.entity.message.OrderPayMessage; import com.sky.entity.message.OrderTimeoutMessage; import com.sky.entity.message.PointsEarnMessage; import com.sky.service.MessageProducerService; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.MessageDeliveryMode; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; /** * 消息生产者服务实现类 * 实现消息发送的具体逻辑 */ @Service @Slf4j public class MessageProducerServiceImpl implements MessageProducerService { @Autowired private RabbitTemplate rabbitTemplate; /** * 发送订单支付消息 * 用于异步处理订单支付后的业务逻辑 */ @Override public void sendOrderPayMessage(OrderPayMessage message) { try { rabbitTemplate.convertAndSend( \u0026#34;order.exchange\u0026#34;, \u0026#34;order.pay\u0026#34;, message, msg -\u0026gt; { msg.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT); return msg; } ); log.info(\u0026#34;订单支付消息发送成功: {}\u0026#34;, message); } catch (Exception e) { log.error(\u0026#34;订单支付消息发送失败: {}\u0026#34;, message, e); throw new RuntimeException(\u0026#34;消息发送失败\u0026#34;, e); } } /** * 发送积分获得消息 * 用于异步处理用户积分增加 */ @Override public void sendPointsEarnMessage(PointsEarnMessage message) { try { rabbitTemplate.convertAndSend( \u0026#34;points.exchange\u0026#34;, \u0026#34;points.earn\u0026#34;, message, msg -\u0026gt; { msg.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT); return msg; } ); log.info(\u0026#34;积分获得消息发送成功: {}\u0026#34;, message); } catch (Exception e) { log.error(\u0026#34;积分获得消息发送失败: {}\u0026#34;, message, e); throw new RuntimeException(\u0026#34;消息发送失败\u0026#34;, e); } } /** * 发送订单超时消息 * 用于异步处理订单超时取消 */ @Override public void sendOrderTimeoutMessage(OrderTimeoutMessage message) { try { rabbitTemplate.convertAndSend( \u0026#34;order.timeout.exchange\u0026#34;, \u0026#34;order.timeout\u0026#34;, message, msg -\u0026gt; { msg.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT); return msg; } ); log.info(\u0026#34;订单超时消息发送成功: {}\u0026#34;, message); } catch (Exception e) { log.error(\u0026#34;订单超时消息发送失败: {}\u0026#34;, message, e); throw new RuntimeException(\u0026#34;消息发送失败\u0026#34;, e); } } } 设计特点:\n消息持久化: 确保消息不丢失 异常处理: 完善的异常处理机制 日志记录: 详细的操作日志 异步处理: 提高系统响应速度 3. 消息消费者服务 3.1 消息消费者接口 文件位置: sky-server/src/main/java/com/sky/service/MessageConsumerService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.sky.service; import com.sky.entity.message.OrderPayMessage; import com.sky.entity.message.OrderTimeoutMessage; import com.sky.entity.message.PointsEarnMessage; /** * 消息消费者服务接口 * 定义消息消费的接口规范 */ public interface MessageConsumerService { /** * 处理订单支付消息 * @param message 订单支付消息 */ void handleOrderPayMessage(OrderPayMessage message); /** * 处理积分获得消息 * @param message 积分获得消息 */ void handlePointsEarnMessage(PointsEarnMessage message); /** * 处理订单超时消息 * @param message 订单超时消息 */ void handleOrderTimeoutMessage(OrderTimeoutMessage message); } 3.2 消息消费者实现 文件位置: sky-server/src/main/java/com/sky/service/impl/MessageConsumerServiceImpl.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 package com.sky.service.impl; import com.rabbitmq.client.Channel; import com.sky.entity.message.OrderPayMessage; import com.sky.entity.message.OrderTimeoutMessage; import com.sky.entity.message.PointsEarnMessage; import com.sky.service.MessageConsumerService; import com.sky.service.MessageProducerService; import com.sky.service.OrderService; import com.sky.service.UserService; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.amqp.support.AmqpHeaders; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.messaging.handler.annotation.Header; import org.springframework.stereotype.Service; import java.io.IOException; /** * 消息消费者服务实现类 * 实现消息消费的具体逻辑 */ @Service @Slf4j public class MessageConsumerServiceImpl implements MessageConsumerService { @Autowired private OrderService orderService; @Autowired private UserService userService; @Autowired private MessageProducerService messageProducerService; /** * 处理订单支付消息 * 异步处理订单支付后的业务逻辑 */ @RabbitListener(queues = \u0026#34;order.queue\u0026#34;) public void handleOrderPayMessage(OrderPayMessage message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) { try { log.info(\u0026#34;收到订单支付消息: {}\u0026#34;, message); // 处理订单支付 orderService.processOrderPayment(message.getOrderId(), message.getAmount()); // 发送积分获得消息 PointsEarnMessage pointsMessage = PointsEarnMessage.builder() .userId(message.getUserId()) .orderId(message.getOrderId()) .points(calculatePoints(message.getAmount())) .earnTime(message.getPayTime()) .build(); messageProducerService.sendPointsEarnMessage(pointsMessage); // 手动确认消息 channel.basicAck(deliveryTag, false); log.info(\u0026#34;订单支付消息处理成功: {}\u0026#34;, message); } catch (Exception e) { log.error(\u0026#34;订单支付消息处理失败: {}\u0026#34;, message, e); try { // 拒绝消息，不重新入队 channel.basicNack(deliveryTag, false, false); } catch (IOException ioException) { log.error(\u0026#34;消息拒绝失败\u0026#34;, ioException); } } } /** * 处理积分获得消息 * 异步处理用户积分增加 */ @RabbitListener(queues = \u0026#34;points.queue\u0026#34;) public void handlePointsEarnMessage(PointsEarnMessage message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) { try { log.info(\u0026#34;收到积分获得消息: {}\u0026#34;, message); // 添加用户积分 userService.addUserPoints(message.getUserId(), message.getPoints(), message.getOrderId()); // 手动确认消息 channel.basicAck(deliveryTag, false); log.info(\u0026#34;积分获得消息处理成功: {}\u0026#34;, message); } catch (Exception e) { log.error(\u0026#34;积分获得消息处理失败: {}\u0026#34;, message, e); try { // 拒绝消息，不重新入队 channel.basicNack(deliveryTag, false, false); } catch (IOException ioException) { log.error(\u0026#34;消息拒绝失败\u0026#34;, ioException); } } } /** * 处理订单超时消息 * 异步处理订单超时取消 */ @RabbitListener(queues = \u0026#34;order.timeout.queue\u0026#34;) public void handleOrderTimeoutMessage(OrderTimeoutMessage message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) { try { log.info(\u0026#34;收到订单超时消息: {}\u0026#34;, message); // 取消超时订单 orderService.cancelTimeoutOrder(message.getOrderId()); // 手动确认消息 channel.basicAck(deliveryTag, false); log.info(\u0026#34;订单超时消息处理成功: {}\u0026#34;, message); } catch (Exception e) { log.error(\u0026#34;订单超时消息处理失败: {}\u0026#34;, message, e); try { // 拒绝消息，不重新入队 channel.basicNack(deliveryTag, false, false); } catch (IOException ioException) { log.error(\u0026#34;消息拒绝失败\u0026#34;, ioException); } } } /** * 计算积分 * 根据订单金额计算用户获得的积分 */ private Integer calculatePoints(java.math.BigDecimal amount) { // 每消费1元获得1积分 return amount.intValue(); } } 设计特点:\n手动确认: 确保消息处理成功后才确认 异常处理: 完善的异常处理机制 业务解耦: 通过消息队列解耦业务逻辑 异步处理: 提高系统响应速度 4. 用户端API接口 4.1 用户端秒杀活动控制器 文件位置: sky-server/src/main/java/com/sky/controller/user/UserSeckillActivityController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package com.sky.controller.user; import com.sky.entity.SeckillActivity; import com.sky.result.Result; import com.sky.service.SeckillActivityService; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; /** * 用户端秒杀活动控制器 * 提供秒杀活动相关的用户端接口 */ @RestController @RequestMapping(\u0026#34;/user/seckill/activity\u0026#34;) @Api(tags = \u0026#34;用户端秒杀活动\u0026#34;) @Slf4j public class UserSeckillActivityController { @Autowired private SeckillActivityService seckillActivityService; @GetMapping(\u0026#34;/current\u0026#34;) @ApiOperation(\u0026#34;获取当前进行中的秒杀活动\u0026#34;) public Result\u0026lt;List\u0026lt;SeckillActivity\u0026gt;\u0026gt; getCurrentActivities() { log.info(\u0026#34;获取当前进行中的秒杀活动\u0026#34;); List\u0026lt;SeckillActivity\u0026gt; activities = seckillActivityService.getCurrentActivities(); return Result.success(activities); } @GetMapping(\u0026#34;/{id}\u0026#34;) @ApiOperation(\u0026#34;根据id查询秒杀活动详情\u0026#34;) public Result\u0026lt;SeckillActivity\u0026gt; getById(@PathVariable Long id) { log.info(\u0026#34;根据id查询秒杀活动详情：{}\u0026#34;, id); SeckillActivity seckillActivity = seckillActivityService.getById(id); return Result.success(seckillActivity); } @PostMapping(\u0026#34;/participate/{id}\u0026#34;) @ApiOperation(\u0026#34;参与秒杀活动\u0026#34;) public Result\u0026lt;String\u0026gt; participateSeckill(@PathVariable Long id, @RequestParam Integer quantity, @RequestHeader(\u0026#34;userId\u0026#34;) Long userId) { log.info(\u0026#34;用户参与秒杀活动：id={}, quantity={}, userId={}\u0026#34;, id, quantity, userId); String result = seckillActivityService.participateSeckill(id, userId, quantity); return Result.success(result); } } 接口说明:\n获取活动列表: 获取当前可参与的秒杀活动 活动详情: 获取指定活动的详细信息 参与秒杀: 用户参与秒杀活动 4.2 用户端优惠券控制器 文件位置: sky-server/src/main/java/com/sky/controller/user/UserCouponController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package com.sky.controller.user; import com.sky.entity.Coupon; import com.sky.entity.CouponTemplate; import com.sky.result.Result; import com.sky.service.CouponService; import com.sky.service.CouponTemplateService; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.math.BigDecimal; import java.util.List; /** * 用户端优惠券控制器 * 提供优惠券相关的用户端接口 */ @RestController @RequestMapping(\u0026#34;/user/coupon\u0026#34;) @Api(tags = \u0026#34;用户端优惠券\u0026#34;) @Slf4j public class UserCouponController { @Autowired private CouponTemplateService couponTemplateService; @Autowired private CouponService couponService; @GetMapping(\u0026#34;/templates/available\u0026#34;) @ApiOperation(\u0026#34;获取可领取的优惠券模板\u0026#34;) public Result\u0026lt;List\u0026lt;CouponTemplate\u0026gt;\u0026gt; getAvailableTemplates() { log.info(\u0026#34;获取可领取的优惠券模板\u0026#34;); List\u0026lt;CouponTemplate\u0026gt; templates = couponTemplateService.getAvailableTemplates(); return Result.success(templates); } @PostMapping(\u0026#34;/claim\u0026#34;) @ApiOperation(\u0026#34;领取优惠券\u0026#34;) public Result\u0026lt;String\u0026gt; claimCoupon(@RequestParam Long templateId, @RequestHeader(\u0026#34;userId\u0026#34;) Long userId) { log.info(\u0026#34;用户领取优惠券：templateId={}, userId={}\u0026#34;, templateId, userId); String result = couponService.claimCoupon(templateId, userId); return Result.success(result); } @GetMapping(\u0026#34;/my\u0026#34;) @ApiOperation(\u0026#34;获取我的优惠券\u0026#34;) public Result\u0026lt;List\u0026lt;Coupon\u0026gt;\u0026gt; getMyCoupons(@RequestHeader(\u0026#34;userId\u0026#34;) Long userId) { log.info(\u0026#34;获取用户优惠券：userId={}\u0026#34;, userId); List\u0026lt;Coupon\u0026gt; coupons = couponService.getUserAvailableCoupons(userId); return Result.success(coupons); } @PostMapping(\u0026#34;/check\u0026#34;) @ApiOperation(\u0026#34;检查优惠券是否可用\u0026#34;) public Result\u0026lt;String\u0026gt; checkCouponAvailable(@RequestParam Long couponId, @RequestParam BigDecimal orderAmount, @RequestHeader(\u0026#34;userId\u0026#34;) Long userId) { log.info(\u0026#34;检查优惠券是否可用：couponId={}, orderAmount={}, userId={}\u0026#34;, couponId, orderAmount, userId); String result = couponService.checkCouponAvailable(couponId, userId, orderAmount); return Result.success(result); } } 接口说明:\n获取优惠券模板: 获取可领取的优惠券模板 领取优惠券: 用户领取优惠券 我的优惠券: 获取用户的优惠券列表 检查优惠券: 检查优惠券是否可用 4.3 健康检查控制器 文件位置: sky-server/src/main/java/com/sky/controller/HealthController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.sky.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; import java.util.Map; /** * 健康检查控制器 * 提供系统健康状态检查接口 */ @RestController @RequestMapping(\u0026#34;/health\u0026#34;) public class HealthController { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @GetMapping(\u0026#34;/check\u0026#34;) public Map\u0026lt;String, Object\u0026gt; healthCheck() { Map\u0026lt;String, Object\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); // 检查Redis连接 try { redisTemplate.opsForValue().get(\u0026#34;health:check\u0026#34;); result.put(\u0026#34;redis\u0026#34;, \u0026#34;UP\u0026#34;); } catch (Exception e) { result.put(\u0026#34;redis\u0026#34;, \u0026#34;DOWN\u0026#34;); } // 检查应用状态 result.put(\u0026#34;application\u0026#34;, \u0026#34;UP\u0026#34;); result.put(\u0026#34;timestamp\u0026#34;, System.currentTimeMillis()); return result; } } 功能说明:\nRedis检查: 检查Redis连接状态 应用状态: 检查应用运行状态 时间戳: 返回检查时间 5. Nginx配置更新 文件位置: nginx-conf/New file.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 在现有配置基础上添加以下配置 # 秒杀活动相关接口 location /seckill/ { proxy_pass http://localhost:8084/user/seckill/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # 优惠券相关接口 location /coupon/ { proxy_pass http://localhost:8084/user/coupon/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # 健康检查接口 location /health/ { proxy_pass http://localhost:8084/health/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } 配置说明:\n反向代理: 将请求转发到后端服务 请求头设置: 保持原始请求信息 负载均衡: 支持多实例部署 6. 关键特性 6.1 消息队列解耦 支付服务和积分服务完全解耦 异步处理提高系统性能 消息持久化保证可靠性 6.2 削峰填谷 消费者容器工厂限流配置 手动ACK机制 消息重试机制 6.3 延迟消息处理 订单超时自动取消 死信队列处理失败消息 消息TTL设置 6.4 服务监控 健康检查接口 日志彩色输出 性能监控 7. 测试建议 7.1 消息队列测试 消息发送测试: 测试各种消息的发送 消息消费测试: 测试消息的消费处理 异常处理测试: 测试消息处理异常情况 性能测试: 测试高并发消息处理 7.2 API接口测试 秒杀接口测试: 测试秒杀活动的参与 优惠券接口测试: 测试优惠券的领取和使用 健康检查测试: 测试系统健康状态 并发测试: 测试高并发场景 8. 部署注意事项 RabbitMQ配置: 确保RabbitMQ服务正常运行 Redis配置: 确保Redis连接配置正确 日志配置: 确保日志文件路径存在 Nginx配置: 确保反向代理配置正确 9. 消息队列高级特性 9.1 消息可靠性保证 9.1.1 生产者确认机制 确认模式配置:\n1 2 3 4 5 6 spring: rabbitmq: publisher-confirm-type: correlated publisher-returns: true template: mandatory: true 确认回调处理:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Configuration public class RabbitMQConfirmConfig { @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate template = new RabbitTemplate(connectionFactory); // 设置确认回调 template.setConfirmCallback((correlationData, ack, cause) -\u0026gt; { if (ack) { log.info(\u0026#34;消息发送成功: {}\u0026#34;, correlationData.getId()); } else { log.error(\u0026#34;消息发送失败: {}, 原因: {}\u0026#34;, correlationData.getId(), cause); } }); // 设置返回回调 template.setReturnsCallback(returned -\u0026gt; { log.error(\u0026#34;消息路由失败: {}, 回复码: {}, 回复文本: {}\u0026#34;, returned.getMessage(), returned.getReplyCode(), returned.getReplyText()); }); return template; } } 9.1.2 消费者确认机制 手动确认配置:\n1 2 3 4 5 6 7 8 9 spring: rabbitmq: listener: simple: acknowledge-mode: manual retry: enabled: true max-attempts: 3 initial-interval: 1000 消息处理示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RabbitListener(queues = \u0026#34;order.pay.queue\u0026#34;) public void handleOrderPay(OrderPayMessage message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) { try { // 处理业务逻辑 processOrderPayment(message); // 手动确认消息 channel.basicAck(deliveryTag, false); log.info(\u0026#34;订单支付消息处理成功: {}\u0026#34;, message.getOrderId()); } catch (Exception e) { try { // 拒绝消息并重新入队 channel.basicNack(deliveryTag, false, true); log.error(\u0026#34;订单支付消息处理失败: {}\u0026#34;, message.getOrderId(), e); } catch (IOException ioException) { log.error(\u0026#34;消息确认失败\u0026#34;, ioException); } } } 9.2 消息持久化 9.2.1 队列持久化 队列配置:\n1 2 3 4 5 6 7 @Bean public Queue orderPayQueue() { return QueueBuilder.durable(\u0026#34;order.pay.queue\u0026#34;) .withArgument(\u0026#34;x-message-ttl\u0026#34;, 300000) // 消息TTL 5分钟 .withArgument(\u0026#34;x-max-length\u0026#34;, 10000) // 最大长度 .build(); } 交换机持久化:\n1 2 3 4 5 6 @Bean public TopicExchange orderExchange() { return ExchangeBuilder.topicExchange(\u0026#34;order.exchange\u0026#34;) .durable(true) .build(); } 9.2.2 消息持久化 消息属性设置:\n1 2 3 4 5 6 7 8 9 10 public void sendOrderPayMessage(OrderPayMessage message) { MessageProperties properties = new MessageProperties(); properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); properties.setPriority(5); properties.setExpiration(\u0026#34;300000\u0026#34;); // 5分钟过期 Message msg = new Message(JSON.toJSONBytes(message), properties); rabbitTemplate.convertAndSend(\u0026#34;order.exchange\u0026#34;, \u0026#34;order.pay\u0026#34;, msg); } 9.3 死信队列 9.3.1 死信队列配置 死信交换机配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Bean public TopicExchange deadLetterExchange() { return ExchangeBuilder.topicExchange(\u0026#34;dead.letter.exchange\u0026#34;) .durable(true) .build(); } @Bean public Queue deadLetterQueue() { return QueueBuilder.durable(\u0026#34;dead.letter.queue\u0026#34;).build(); } @Bean public Binding deadLetterBinding() { return BindingBuilder.bind(deadLetterQueue()) .to(deadLetterExchange()) .with(\u0026#34;dead.letter.#\u0026#34;); } 业务队列配置:\n1 2 3 4 5 6 7 8 @Bean public Queue orderPayQueue() { return QueueBuilder.durable(\u0026#34;order.pay.queue\u0026#34;) .withArgument(\u0026#34;x-dead-letter-exchange\u0026#34;, \u0026#34;dead.letter.exchange\u0026#34;) .withArgument(\u0026#34;x-dead-letter-routing-key\u0026#34;, \u0026#34;dead.letter.order.pay\u0026#34;) .withArgument(\u0026#34;x-message-ttl\u0026#34;, 300000) .build(); } 9.3.2 死信处理 死信消息处理:\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RabbitListener(queues = \u0026#34;dead.letter.queue\u0026#34;) public void handleDeadLetter(String message, @Header(\u0026#34;x-dead-letter-reason\u0026#34;) String reason) { log.warn(\u0026#34;收到死信消息: {}, 原因: {}\u0026#34;, message, reason); // 根据死信原因进行不同处理 if (\u0026#34;expired\u0026#34;.equals(reason)) { // 处理过期消息 handleExpiredMessage(message); } else if (\u0026#34;rejected\u0026#34;.equals(reason)) { // 处理被拒绝的消息 handleRejectedMessage(message); } } 9.4 消息幂等性 9.4.1 幂等性保证 消息去重:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class MessageIdempotencyService { @Autowired private RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate; private static final String MESSAGE_PROCESSED_KEY = \u0026#34;message:processed:\u0026#34;; private static final int EXPIRE_TIME = 3600; // 1小时 public boolean isMessageProcessed(String messageId) { String key = MESSAGE_PROCESSED_KEY + messageId; return redisTemplate.hasKey(key); } public void markMessageProcessed(String messageId) { String key = MESSAGE_PROCESSED_KEY + messageId; redisTemplate.opsForValue().set(key, \u0026#34;1\u0026#34;, EXPIRE_TIME, TimeUnit.SECONDS); } } 幂等性处理:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @RabbitListener(queues = \u0026#34;order.pay.queue\u0026#34;) public void handleOrderPay(OrderPayMessage message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) { String messageId = message.getMessageId(); // 检查消息是否已处理 if (messageIdempotencyService.isMessageProcessed(messageId)) { log.info(\u0026#34;消息已处理，跳过: {}\u0026#34;, messageId); channel.basicAck(deliveryTag, false); return; } try { // 处理业务逻辑 processOrderPayment(message); // 标记消息已处理 messageIdempotencyService.markMessageProcessed(messageId); // 确认消息 channel.basicAck(deliveryTag, false); } catch (Exception e) { log.error(\u0026#34;消息处理失败: {}\u0026#34;, messageId, e); // 拒绝消息 channel.basicNack(deliveryTag, false, false); } } 10. 流控和熔断 10.1 Sentinel流控 10.1.1 流控规则配置 流控规则定义:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Component public class SentinelFlowControlConfig { @PostConstruct public void initFlowRules() { List\u0026lt;FlowRule\u0026gt; rules = new ArrayList\u0026lt;\u0026gt;(); // 秒杀接口流控 FlowRule seckillRule = new FlowRule(); seckillRule.setResource(\u0026#34;seckill:participate\u0026#34;); seckillRule.setGrade(RuleConstant.FLOW_GRADE_QPS); seckillRule.setCount(100); // 每秒100个请求 seckillRule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER); rules.add(seckillRule); // 优惠券接口流控 FlowRule couponRule = new FlowRule(); couponRule.setResource(\u0026#34;coupon:claim\u0026#34;); couponRule.setGrade(RuleConstant.FLOW_GRADE_QPS); couponRule.setCount(50); // 每秒50个请求 couponRule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER); rules.add(couponRule); FlowRuleManager.loadRules(rules); } } 10.1.2 流控处理 流控异常处理:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class SeckillController { @SentinelResource(value = \u0026#34;seckill:participate\u0026#34;, blockHandler = \u0026#34;handleSeckillBlock\u0026#34;, fallback = \u0026#34;handleSeckillFallback\u0026#34;) @PostMapping(\u0026#34;/seckill/participate\u0026#34;) public Result participateSeckill(@RequestBody SeckillParticipateDTO dto) { return seckillService.participateSeckill(dto); } public Result handleSeckillBlock(SeckillParticipateDTO dto, BlockException ex) { log.warn(\u0026#34;秒杀接口被流控: {}\u0026#34;, ex.getMessage()); return Result.error(\u0026#34;系统繁忙，请稍后重试\u0026#34;); } public Result handleSeckillFallback(SeckillParticipateDTO dto, Throwable ex) { log.error(\u0026#34;秒杀接口异常: {}\u0026#34;, ex.getMessage()); return Result.error(\u0026#34;系统异常，请稍后重试\u0026#34;); } } 10.2 熔断降级 10.2.1 熔断规则配置 熔断规则定义:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Component public class SentinelCircuitBreakerConfig { @PostConstruct public void initCircuitBreakerRules() { List\u0026lt;CircuitBreakerRule\u0026gt; rules = new ArrayList\u0026lt;\u0026gt;(); // 数据库熔断规则 CircuitBreakerRule dbRule = new CircuitBreakerRule(); dbRule.setResource(\u0026#34;database:query\u0026#34;); dbRule.setGrade(RuleConstant.DEGRADE_GRADE_RT); dbRule.setCount(100); // 平均响应时间100ms dbRule.setTimeWindow(10); // 熔断时长10秒 dbRule.setMinRequestAmount(5); // 最小请求数 dbRule.setStatIntervalMs(1000); // 统计时长1秒 rules.add(dbRule); // Redis熔断规则 CircuitBreakerRule redisRule = new CircuitBreakerRule(); redisRule.setResource(\u0026#34;redis:operation\u0026#34;); redisRule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO); redisRule.setCount(0.5); // 异常比例50% redisRule.setTimeWindow(10); redisRule.setMinRequestAmount(5); redisRule.setStatIntervalMs(1000); rules.add(redisRule); CircuitBreakerRuleManager.loadRules(rules); } } 10.2.2 熔断处理 熔断降级处理:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Service public class SeckillService { @SentinelResource(value = \u0026#34;database:query\u0026#34;, fallback = \u0026#34;fallbackQueryActivity\u0026#34;) public SeckillActivity queryActivity(Long activityId) { return seckillActivityMapper.selectById(activityId); } public SeckillActivity fallbackQueryActivity(Long activityId, Throwable ex) { log.error(\u0026#34;数据库查询熔断: {}\u0026#34;, ex.getMessage()); // 返回缓存数据或默认值 return getCachedActivity(activityId); } @SentinelResource(value = \u0026#34;redis:operation\u0026#34;, fallback = \u0026#34;fallbackRedisOperation\u0026#34;) public void updateStock(Long activityId, Integer quantity) { redisTemplate.opsForValue().decrement(\u0026#34;seckill:stock:\u0026#34; + activityId, quantity); } public void fallbackRedisOperation(Long activityId, Integer quantity, Throwable ex) { log.error(\u0026#34;Redis操作熔断: {}\u0026#34;, ex.getMessage()); // 降级处理：直接更新数据库 updateStockInDatabase(activityId, quantity); } } 11. 监控和告警 11.1 应用监控 11.1.1 指标收集 自定义指标:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Component public class BusinessMetrics { private final MeterRegistry meterRegistry; private final Counter seckillSuccessCounter; private final Counter seckillFailCounter; private final Timer seckillTimer; public BusinessMetrics(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.seckillSuccessCounter = Counter.builder(\u0026#34;seckill.success\u0026#34;) .description(\u0026#34;秒杀成功次数\u0026#34;) .register(meterRegistry); this.seckillFailCounter = Counter.builder(\u0026#34;seckill.fail\u0026#34;) .description(\u0026#34;秒杀失败次数\u0026#34;) .register(meterRegistry); this.seckillTimer = Timer.builder(\u0026#34;seckill.duration\u0026#34;) .description(\u0026#34;秒杀处理时间\u0026#34;) .register(meterRegistry); } public void recordSeckillSuccess() { seckillSuccessCounter.increment(); } public void recordSeckillFail() { seckillFailCounter.increment(); } public void recordSeckillDuration(Duration duration) { seckillTimer.record(duration); } } 11.1.2 健康检查 健康检查配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component public class CustomHealthIndicator implements HealthIndicator { @Autowired private RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate; @Autowired private DataSource dataSource; @Override public Health health() { Health.Builder builder = new Health.Builder(); // 检查Redis连接 try { redisTemplate.opsForValue().get(\u0026#34;health:check\u0026#34;); builder.withDetail(\u0026#34;redis\u0026#34;, \u0026#34;UP\u0026#34;); } catch (Exception e) { builder.down().withDetail(\u0026#34;redis\u0026#34;, \u0026#34;DOWN: \u0026#34; + e.getMessage()); } // 检查数据库连接 try { dataSource.getConnection().close(); builder.withDetail(\u0026#34;database\u0026#34;, \u0026#34;UP\u0026#34;); } catch (Exception e) { builder.down().withDetail(\u0026#34;database\u0026#34;, \u0026#34;DOWN: \u0026#34; + e.getMessage()); } return builder.build(); } } 11.2 业务监控 11.2.1 业务指标监控 业务指标收集:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Service public class BusinessMonitorService { @Autowired private BusinessMetrics businessMetrics; @EventListener public void handleSeckillSuccess(SeckillSuccessEvent event) { businessMetrics.recordSeckillSuccess(); log.info(\u0026#34;秒杀成功: 活动ID={}, 用户ID={}\u0026#34;, event.getActivityId(), event.getUserId()); } @EventListener public void handleSeckillFail(SeckillFailEvent event) { businessMetrics.recordSeckillFail(); log.warn(\u0026#34;秒杀失败: 活动ID={}, 用户ID={}, 原因={}\u0026#34;, event.getActivityId(), event.getUserId(), event.getReason()); } @EventListener public void handleCouponClaim(CouponClaimEvent event) { log.info(\u0026#34;优惠券领取: 模板ID={}, 用户ID={}\u0026#34;, event.getTemplateId(), event.getUserId()); } } 11.2.2 告警配置 告警规则配置:\n1 2 3 4 5 6 7 8 9 10 11 management: endpoints: web: exposure: include: health,metrics,prometheus metrics: export: prometheus: enabled: true tags: application: sky-server 告警规则:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 groups: - name: sky-server-alerts rules: - alert: HighErrorRate expr: rate(http_server_requests_seconds_count{status=~\u0026#34;5..\u0026#34;}[5m]) \u0026gt; 0.1 for: 2m labels: severity: warning annotations: summary: \u0026#34;高错误率告警\u0026#34; description: \u0026#34;错误率超过10%\u0026#34; - alert: HighResponseTime expr: histogram_quantile(0.95, rate(http_server_requests_seconds_bucket[5m])) \u0026gt; 1 for: 2m labels: severity: warning annotations: summary: \u0026#34;高响应时间告警\u0026#34; description: \u0026#34;95%响应时间超过1秒\u0026#34; 12. 性能优化 12.1 缓存优化 12.1.1 多级缓存 本地缓存配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration @EnableCaching public class CacheConfig { @Bean public CacheManager cacheManager() { CaffeineCacheManager cacheManager = new CaffeineCacheManager(); cacheManager.setCaffeine(Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(10, TimeUnit.MINUTES) .recordStats()); return cacheManager; } } 多级缓存实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Service public class SeckillActivityService { @Cacheable(value = \u0026#34;seckill:activity\u0026#34;, key = \u0026#34;#activityId\u0026#34;) public SeckillActivity getActivity(Long activityId) { // 先从本地缓存获取 SeckillActivity activity = localCache.get(activityId); if (activity != null) { return activity; } // 从Redis获取 activity = redisTemplate.opsForValue().get(\u0026#34;seckill:activity:\u0026#34; + activityId); if (activity != null) { localCache.put(activityId, activity); return activity; } // 从数据库获取 activity = seckillActivityMapper.selectById(activityId); if (activity != null) { redisTemplate.opsForValue().set(\u0026#34;seckill:activity:\u0026#34; + activityId, activity, 10, TimeUnit.MINUTES); localCache.put(activityId, activity); } return activity; } } 12.1.2 缓存预热 缓存预热服务:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Service public class CacheWarmupService { @Autowired private SeckillActivityService seckillActivityService; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @PostConstruct public void warmupCache() { // 预热秒杀活动缓存 List\u0026lt;SeckillActivity\u0026gt; activities = seckillActivityService.getActiveActivities(); for (SeckillActivity activity : activities) { String key = \u0026#34;seckill:activity:\u0026#34; + activity.getId(); redisTemplate.opsForValue().set(key, activity, 10, TimeUnit.MINUTES); } // 预热库存缓存 for (SeckillActivity activity : activities) { String stockKey = \u0026#34;seckill:stock:\u0026#34; + activity.getId(); redisTemplate.opsForValue().set(stockKey, activity.getStock()); } } } 12.2 数据库优化 12.2.1 读写分离 数据源配置:\n1 2 3 4 5 6 7 8 9 10 11 12 spring: datasource: master: url: jdbc:mysql://localhost:3306/sky?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;serverTimezone=GMT%2B8 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver slave: url: jdbc:mysql://localhost:3307/sky?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;serverTimezone=GMT%2B8 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver 读写分离配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Configuration public class DataSourceConfig { @Bean @Primary public DataSource masterDataSource() { return DataSourceBuilder.create() .url(\u0026#34;jdbc:mysql://localhost:3306/sky\u0026#34;) .username(\u0026#34;root\u0026#34;) .password(\u0026#34;root\u0026#34;) .driverClassName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;) .build(); } @Bean public DataSource slaveDataSource() { return DataSourceBuilder.create() .url(\u0026#34;jdbc:mysql://localhost:3307/sky\u0026#34;) .username(\u0026#34;root\u0026#34;) .password(\u0026#34;root\u0026#34;) .driverClassName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;) .build(); } @Bean public DataSource routingDataSource() { DynamicRoutingDataSource routingDataSource = new DynamicRoutingDataSource(); Map\u0026lt;Object, Object\u0026gt; dataSourceMap = new HashMap\u0026lt;\u0026gt;(); dataSourceMap.put(\u0026#34;master\u0026#34;, masterDataSource()); dataSourceMap.put(\u0026#34;slave\u0026#34;, slaveDataSource()); routingDataSource.setTargetDataSources(dataSourceMap); routingDataSource.setDefaultTargetDataSource(masterDataSource()); return routingDataSource; } } 12.2.2 分库分表 分表策略:\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Component public class ShardingStrategy { public String getTableName(String baseTable, Long userId) { int shard = (int) (userId % 4); return baseTable + \u0026#34;_\u0026#34; + shard; } public String getDatabaseName(String baseDatabase, Long userId) { int shard = (int) (userId % 2); return baseDatabase + \u0026#34;_\u0026#34; + shard; } } 13. 安全防护 13.1 接口安全 13.1.1 接口鉴权 JWT配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class JwtConfig { @Value(\u0026#34;${jwt.secret}\u0026#34;) private String secret; @Value(\u0026#34;${jwt.expiration}\u0026#34;) private Long expiration; @Bean public JwtTokenProvider jwtTokenProvider() { return new JwtTokenProvider(secret, expiration); } } JWT工具类:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @Component public class JwtTokenProvider { private final String secret; private final Long expiration; public JwtTokenProvider(String secret, Long expiration) { this.secret = secret; this.expiration = expiration; } public String generateToken(Long userId) { Date now = new Date(); Date expiryDate = new Date(now.getTime() + expiration); return Jwts.builder() .setSubject(userId.toString()) .setIssuedAt(now) .setExpiration(expiryDate) .signWith(SignatureAlgorithm.HS512, secret) .compact(); } public Long getUserIdFromToken(String token) { Claims claims = Jwts.parser() .setSigningKey(secret) .parseClaimsJws(token) .getBody(); return Long.parseLong(claims.getSubject()); } public boolean validateToken(String token) { try { Jwts.parser().setSigningKey(secret).parseClaimsJws(token); return true; } catch (JwtException | IllegalArgumentException e) { return false; } } } 13.1.2 接口限流 限流配置:\n1 2 3 4 5 6 7 8 @Configuration public class RateLimitConfig { @Bean public RateLimiter rateLimiter() { return RateLimiter.create(100.0); // 每秒100个请求 } } 限流拦截器:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component public class RateLimitInterceptor implements HandlerInterceptor { @Autowired private RateLimiter rateLimiter; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { if (rateLimiter.tryAcquire()) { return true; } else { response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value()); return false; } } } 13.2 数据安全 13.2.1 数据加密 敏感数据加密:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class DataEncryptionService { private final AESUtil aesUtil; public DataEncryptionService() { this.aesUtil = new AESUtil(\u0026#34;your-secret-key\u0026#34;); } public String encrypt(String data) { return aesUtil.encrypt(data); } public String decrypt(String encryptedData) { return aesUtil.decrypt(encryptedData); } } 13.2.2 数据脱敏 数据脱敏工具:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class DataMaskingService { public String maskPhone(String phone) { if (phone == null || phone.length() \u0026lt; 7) { return phone; } return phone.substring(0, 3) + \u0026#34;****\u0026#34; + phone.substring(phone.length() - 4); } public String maskEmail(String email) { if (email == null || !email.contains(\u0026#34;@\u0026#34;)) { return email; } String[] parts = email.split(\u0026#34;@\u0026#34;); String username = parts[0]; if (username.length() \u0026lt;= 2) { return email; } return username.substring(0, 2) + \u0026#34;***@\u0026#34; + parts[1]; } } 14. 测试策略 14.1 单元测试 14.1.1 服务层测试 测试示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @SpringBootTest class SeckillActivityServiceTest { @Autowired private SeckillActivityService seckillActivityService; @MockBean private SeckillActivityMapper seckillActivityMapper; @MockBean private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Test void testParticipateSeckill_Success() { // 准备测试数据 SeckillParticipateDTO dto = new SeckillParticipateDTO(); dto.setActivityId(1L); dto.setUserId(1L); dto.setQuantity(1); SeckillActivity activity = new SeckillActivity(); activity.setId(1L); activity.setStock(10); activity.setStatus(1); // Mock方法调用 when(seckillActivityMapper.selectById(1L)).thenReturn(activity); when(redisTemplate.opsForValue().get(\u0026#34;seckill:stock:1\u0026#34;)).thenReturn(10); // 执行测试 Result result = seckillActivityService.participateSeckill(dto); // 验证结果 assertThat(result.getCode()).isEqualTo(1); assertThat(result.getMsg()).isEqualTo(\u0026#34;参与成功\u0026#34;); } } 14.1.2 控制器测试 测试示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @WebMvcTest(SeckillActivityController.class) class SeckillActivityControllerTest { @Autowired private MockMvc mockMvc; @MockBean private SeckillActivityService seckillActivityService; @Test void testParticipateSeckill() throws Exception { // 准备测试数据 SeckillParticipateDTO dto = new SeckillParticipateDTO(); dto.setActivityId(1L); dto.setUserId(1L); dto.setQuantity(1); Result expectedResult = Result.success(\u0026#34;参与成功\u0026#34;); when(seckillActivityService.participateSeckill(any())).thenReturn(expectedResult); // 执行测试 mockMvc.perform(post(\u0026#34;/seckill/participate\u0026#34;) .contentType(MediaType.APPLICATION_JSON) .content(JSON.toJSONString(dto))) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.code\u0026#34;).value(1)) .andExpect(jsonPath(\u0026#34;$.msg\u0026#34;).value(\u0026#34;参与成功\u0026#34;)); } } 14.2 集成测试 14.2.1 数据库集成测试 测试配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @SpringBootTest @Testcontainers class DatabaseIntegrationTest { @Container static MySQLContainer\u0026lt;?\u0026gt; mysql = new MySQLContainer\u0026lt;\u0026gt;(\u0026#34;mysql:8.0\u0026#34;) .withDatabaseName(\u0026#34;test_sky\u0026#34;) .withUsername(\u0026#34;test\u0026#34;) .withPassword(\u0026#34;test\u0026#34;); @DynamicPropertySource static void configureProperties(DynamicPropertyRegistry registry) { registry.add(\u0026#34;spring.datasource.url\u0026#34;, mysql::getJdbcUrl); registry.add(\u0026#34;spring.datasource.username\u0026#34;, mysql::getUsername); registry.add(\u0026#34;spring.datasource.password\u0026#34;, mysql::getPassword); } @Test void testDatabaseConnection() { // 测试数据库连接 assertThat(mysql.isRunning()).isTrue(); } } 14.2.2 Redis集成测试 测试配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @SpringBootTest @Testcontainers class RedisIntegrationTest { @Container static GenericContainer\u0026lt;?\u0026gt; redis = new GenericContainer\u0026lt;\u0026gt;(\u0026#34;redis:7-alpine\u0026#34;) .withExposedPorts(6379); @DynamicPropertySource static void configureProperties(DynamicPropertyRegistry registry) { registry.add(\u0026#34;spring.redis.host\u0026#34;, redis::getHost); registry.add(\u0026#34;spring.redis.port\u0026#34;, () -\u0026gt; redis.getMappedPort(6379)); } @Test void testRedisConnection() { // 测试Redis连接 assertThat(redis.isRunning()).isTrue(); } } 14.3 性能测试 14.3.1 压力测试 JMeter测试计划:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;jmeterTestPlan version=\u0026#34;1.2\u0026#34;\u0026gt; \u0026lt;hashTree\u0026gt; \u0026lt;TestPlan testname=\u0026#34;Seckill Performance Test\u0026#34;\u0026gt; \u0026lt;elementProp name=\u0026#34;TestPlan.arguments\u0026#34; elementType=\u0026#34;Arguments\u0026#34; guiclass=\u0026#34;ArgumentsPanel\u0026#34;\u0026gt; \u0026lt;collectionProp name=\u0026#34;Arguments.arguments\u0026#34;/\u0026gt; \u0026lt;/elementProp\u0026gt; \u0026lt;stringProp name=\u0026#34;TestPlan.user_define_classpath\u0026#34;\u0026gt;\u0026lt;/stringProp\u0026gt; \u0026lt;boolProp name=\u0026#34;TestPlan.functional_mode\u0026#34;\u0026gt;false\u0026lt;/boolProp\u0026gt; \u0026lt;boolProp name=\u0026#34;TestPlan.serialize_threadgroups\u0026#34;\u0026gt;false\u0026lt;/boolProp\u0026gt; \u0026lt;elementProp name=\u0026#34;TestPlan.arguments\u0026#34; elementType=\u0026#34;Arguments\u0026#34; guiclass=\u0026#34;ArgumentsPanel\u0026#34;\u0026gt; \u0026lt;collectionProp name=\u0026#34;Arguments.arguments\u0026#34;/\u0026gt; \u0026lt;/elementProp\u0026gt; \u0026lt;stringProp name=\u0026#34;TestPlan.user_define_classpath\u0026#34;\u0026gt;\u0026lt;/stringProp\u0026gt; \u0026lt;boolProp name=\u0026#34;TestPlan.functional_mode\u0026#34;\u0026gt;false\u0026lt;/boolProp\u0026gt; \u0026lt;boolProp name=\u0026#34;TestPlan.serialize_threadgroups\u0026#34;\u0026gt;false\u0026lt;/boolProp\u0026gt; \u0026lt;/TestPlan\u0026gt; \u0026lt;/hashTree\u0026gt; \u0026lt;/jmeterTestPlan\u0026gt; 14.3.2 负载测试 负载测试配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @SpringBootTest class LoadTest { @Autowired private SeckillActivityService seckillActivityService; @Test void testConcurrentSeckill() throws InterruptedException { int threadCount = 100; int requestCount = 1000; CountDownLatch latch = new CountDownLatch(threadCount); AtomicInteger successCount = new AtomicInteger(0); AtomicInteger failCount = new AtomicInteger(0); for (int i = 0; i \u0026lt; threadCount; i++) { new Thread(() -\u0026gt; { for (int j = 0; j \u0026lt; requestCount / threadCount; j++) { try { SeckillParticipateDTO dto = new SeckillParticipateDTO(); dto.setActivityId(1L); dto.setUserId(Thread.currentThread().getId()); dto.setQuantity(1); Result result = seckillActivityService.participateSeckill(dto); if (result.getCode() == 1) { successCount.incrementAndGet(); } else { failCount.incrementAndGet(); } } catch (Exception e) { failCount.incrementAndGet(); } } latch.countDown(); }).start(); } latch.await(); System.out.println(\u0026#34;成功: \u0026#34; + successCount.get()); System.out.println(\u0026#34;失败: \u0026#34; + failCount.get()); } } 通过以上实现，我们建立了一个完整的消息队列异步处理系统，实现了支付和积分服务的解耦，提高了系统的可扩展性和稳定性。\n","date":"2025-01-14T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/hash%E5%92%96%E5%95%A1%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E6%94%B9%E9%80%A0%E6%8C%87%E5%8D%97-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8Capi%E6%8E%A5%E5%8F%A3/","title":"Hash咖啡项目后端改造指南 - 第三部分：消息队列和API接口"},{"content":"Hash咖啡后端改造指南-第二部分-实体类和分布式锁实现 目录 项目概述 实体类设计 分布式锁实现 Lua脚本优化 数据库操作优化 缓存策略 异常处理 性能监控 业务流程详解 性能优化策略 监控和告警 测试策略 部署和运维 概述 本部分主要介绍Hash咖啡项目中秒杀和优惠券功能的实体类设计、分布式锁实现，以及相关的Service层扩展。通过Lua脚本与Redisson分布式锁防止优惠券超卖与重复获取，同时通过MySQL数据库的原子性操作保证库存扣减的线程安全。\n1. 实体类扩展 1.1 用户实体类扩展 文件位置: sky-pojo/src/main/java/com/sky/entity/User.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.sky.entity; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.time.LocalDate; import java.time.LocalDateTime; @Data @Builder @NoArgsConstructor @AllArgsConstructor public class User implements Serializable { private static final long serialVersionUID = 1L; private Long id; //微信用户唯一标识 private String openid; //姓名 private String name; //手机号 private String phone; //性别 0 女 1 男 private String sex; //身份证号 private String idNumber; //头像 private String avatar; //积分 private Integer points; //注册时间 private LocalDateTime createTime; } 主要变更说明:\n添加了 points 字段用于存储用户积分 积分系统是用户忠诚度管理的重要组成部分 积分可以用于兑换优惠券、抵扣现金等 业务价值:\n用户留存: 通过积分系统提高用户粘性 消费激励: 积分奖励机制促进用户消费 数据分析: 积分数据可用于用户行为分析 1.2 消息实体类设计 1.2.1 订单支付消息 文件位置: sky-pojo/src/main/java/com/sky/entity/message/OrderPayMessage.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.sky.entity.message; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.math.BigDecimal; import java.time.LocalDateTime; /** * 订单支付消息 * 用于异步处理订单支付后的业务逻辑 */ @Data @Builder @NoArgsConstructor @AllArgsConstructor public class OrderPayMessage implements Serializable { private static final long serialVersionUID = 1L; /** * 订单ID */ private Long orderId; /** * 用户ID */ private Long userId; /** * 支付金额 */ private BigDecimal amount; /** * 支付时间 */ private LocalDateTime payTime; /** * 支付方式 * 1-微信支付 2-支付宝 3-银行卡 */ private Integer payMethod; } 设计理念:\n使用消息队列解耦支付服务和积分服务 提高系统响应速度和稳定性 支持异步处理，避免同步阻塞 1.2.2 积分获得消息 文件位置: sky-pojo/src/main/java/com/sky/entity/message/PointsEarnMessage.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.sky.entity.message; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.time.LocalDateTime; /** * 积分获得消息 * 用于处理用户积分增加的业务逻辑 */ @Data @Builder @NoArgsConstructor @AllArgsConstructor public class PointsEarnMessage implements Serializable { private static final long serialVersionUID = 1L; /** * 用户ID */ private Long userId; /** * 订单ID */ private Long orderId; /** * 获得积分 */ private Integer points; /** * 获得时间 */ private LocalDateTime earnTime; } 业务规则:\n每消费1元获得1积分 积分有效期为1年 积分可用于兑换优惠券 1.2.3 订单超时消息 文件位置: sky-pojo/src/main/java/com/sky/entity/message/OrderTimeoutMessage.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package com.sky.entity.message; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.time.LocalDateTime; /** * 订单超时消息 * 用于处理订单超时未支付的业务逻辑 */ @Data @Builder @NoArgsConstructor @AllArgsConstructor public class OrderTimeoutMessage implements Serializable { private static final long serialVersionUID = 1L; /** * 订单ID */ private Long orderId; /** * 用户ID */ private Long userId; /** * 超时时间 */ private LocalDateTime timeoutTime; } 超时处理机制:\n订单创建后15分钟内未支付自动取消 释放库存，恢复商品可售状态 发送超时通知给用户 2. 分布式锁服务实现 2.1 分布式锁服务类 文件位置: sky-server/src/main/java/com/sky/lock/DistributedLockService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 package com.sky.lock; import com.sky.constant.RedisKeyConstants; import lombok.extern.slf4j.Slf4j; import org.redisson.api.RLock; import org.redisson.api.RedissonClient; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.ClassPathResource; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.script.DefaultRedisScript; import org.springframework.scripting.support.ResourceScriptSource; import org.springframework.stereotype.Service; import java.util.Arrays; import java.util.List; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.TimeUnit; import java.util.function.Supplier; /** * 分布式锁服务（优化版） * 基于Redisson实现分布式锁，支持秒杀场景下的高并发控制 */ @Slf4j @Service public class DistributedLockService { @Autowired private RedissonClient redissonClient; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Value(\u0026#34;${sky.redis.seckill.prefix}\u0026#34;) private String seckillPrefix; // 锁缓存，避免重复获取锁对象 private final ConcurrentHashMap\u0026lt;String, RLock\u0026gt; lockCache = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 秒杀参与脚本 private final DefaultRedisScript\u0026lt;List\u0026gt; seckillParticipateScript; public DistributedLockService() { // 初始化秒杀参与脚本 this.seckillParticipateScript = new DefaultRedisScript\u0026lt;\u0026gt;(); this.seckillParticipateScript.setScriptSource( new ResourceScriptSource(new ClassPathResource(\u0026#34;scripts/seckill_participate.lua\u0026#34;)) ); this.seckillParticipateScript.setResultType(List.class); } /** * 获取锁对象（带缓存） * 使用缓存机制避免重复创建锁对象，提高性能 */ private RLock getLock(String lockKey) { return lockCache.computeIfAbsent(lockKey, key -\u0026gt; redissonClient.getLock(key)); } /** * 秒杀参与 * 使用Lua脚本保证原子性操作，防止超卖 */ public List\u0026lt;Object\u0026gt; seckillParticipate(Long activityId, Long userId, Integer quantity, Integer perUserLimit) { // 使用工具方法生成键 String stockKey = seckillPrefix + RedisKeyConstants.getStockKey(activityId); String participantsKey = seckillPrefix + RedisKeyConstants.getParticipantsKey(activityId); List\u0026lt;String\u0026gt; keys = Arrays.asList(stockKey, participantsKey); Object[] args = {userId.toString(), quantity.toString(), perUserLimit.toString()}; return redisTemplate.execute(seckillParticipateScript, keys, args); } /** * 尝试获取锁（优化版） * 支持超时机制，避免死锁 */ public boolean tryLock(String lockKey, long waitTime, long leaseTime, TimeUnit unit) { RLock lock = getLock(lockKey); try { return lock.tryLock(waitTime, leaseTime, unit); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException(\u0026#34;获取锁被中断\u0026#34;, e); } } /** * 释放锁（优化版） * 确保锁的正确释放，避免资源泄露 */ public void unlock(String lockKey) { RLock lock = getLock(lockKey); try { if (lock.isHeldByCurrentThread()) { lock.unlock(); } } catch (Exception e) { log.warn(\u0026#34;释放锁失败: {}\u0026#34;, lockKey, e); } } /** * 执行带锁的操作（推荐使用） * 自动管理锁的获取和释放，确保业务逻辑的原子性 */ public \u0026lt;T\u0026gt; T executeWithLock(String lockKey, long waitTime, long leaseTime, TimeUnit unit, Supplier\u0026lt;T\u0026gt; supplier) { RLock lock = getLock(lockKey); try { if (lock.tryLock(waitTime, leaseTime, unit)) { return supplier.get(); } else { throw new RuntimeException(\u0026#34;获取锁失败: \u0026#34; + lockKey); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException(\u0026#34;获取锁被中断: \u0026#34; + lockKey, e); } finally { if (lock.isHeldByCurrentThread()) { lock.unlock(); } } } /** * 检查锁状态 * 用于监控和调试 */ public boolean isLocked(String lockKey) { RLock lock = getLock(lockKey); return lock.isLocked(); } /** * 获取锁剩余时间 * 用于监控锁的使用情况 */ public long getLockRemainingTime(String lockKey) { RLock lock = getLock(lockKey); return lock.remainTimeToLive(); } } 设计特点:\n锁缓存机制: 避免重复创建锁对象，提高性能 Lua脚本: 保证操作的原子性，防止超卖 超时机制: 避免死锁，提高系统稳定性 异常处理: 确保锁的正确释放 2.2 Redis键常量类 文件位置: sky-common/src/main/java/com/sky/constant/RedisKeyConstants.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package com.sky.constant; /** * Redis键常量类 * 统一管理Redis键的命名规范，避免键冲突 */ public class RedisKeyConstants { // 秒杀相关前缀 public static final String SECKILL_PREFIX = \u0026#34;seckill:\u0026#34;; // 秒杀子键 public static final String STOCK_KEY = \u0026#34;stock:\u0026#34;; public static final String PARTICIPANTS_KEY = \u0026#34;participants:\u0026#34;; public static final String LOCK_KEY = \u0026#34;lock:\u0026#34;; public static final String ORDER_KEY = \u0026#34;order:\u0026#34;; /** * 生成库存键 * 格式: seckill:stock:活动ID */ public static String getStockKey(Long activityId) { return SECKILL_PREFIX + STOCK_KEY + activityId; } /** * 生成参与者键 * 格式: seckill:participants:活动ID */ public static String getParticipantsKey(Long activityId) { return SECKILL_PREFIX + PARTICIPANTS_KEY + activityId; } /** * 生成锁键 * 格式: seckill:lock:业务键 */ public static String getLockKey(String businessKey) { return SECKILL_PREFIX + LOCK_KEY + businessKey; } /** * 生成订单键 * 格式: seckill:order:订单ID */ public static String getOrderKey(Long orderId) { return SECKILL_PREFIX + ORDER_KEY + orderId; } } 命名规范:\n使用冒号分隔层级结构 前缀统一管理，避免键冲突 支持按业务模块分类管理 3. Service层扩展 3.1 UserService扩展 文件位置: sky-server/src/main/java/com/sky/service/UserService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.sky.service; import com.sky.dto.UserLoginDTO; import com.sky.entity.User; public interface UserService { /** * 微信登录 * @param userLoginDTO * @return */ User wxLogin(UserLoginDTO userLoginDTO); /** * 添加用户积分 * @param userId 用户ID * @param points 积分数量 * @param orderId 订单ID */ void addUserPoints(Long userId, Integer points, Long orderId); /** * 获取用户积分 * @param userId 用户ID * @return 用户积分 */ Integer getUserPoints(Long userId); } 文件位置: sky-server/src/main/java/com/sky/service/impl/UserServiceImpl.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 在UserServiceImpl中添加以下方法 /** * 添加用户积分 * @param userId 用户ID * @param points 积分数量 * @param orderId 订单ID */ @Override public void addUserPoints(Long userId, Integer points, Long orderId) { // 查询用户当前积分 User user = userMapper.getById(userId); if (user != null) { // 更新用户积分 userMapper.updateUserPoints(userId, user.getPoints() + points); log.info(\u0026#34;用户积分增加成功：userId={}, points={}, orderId={}\u0026#34;, userId, points, orderId); } } /** * 获取用户积分 * @param userId 用户ID * @return 用户积分 */ @Override public Integer getUserPoints(Long userId) { User user = userMapper.getById(userId); return user != null ? user.getPoints() : 0; } 业务逻辑:\n积分增加: 用户消费后自动增加积分 积分查询: 支持用户查看当前积分 积分使用: 积分可用于兑换优惠券 3.2 OrderService扩展 文件位置: sky-server/src/main/java/com/sky/service/OrderService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 在OrderService接口中添加以下方法 /** * 处理订单支付 * @param orderId 订单ID * @param amount 支付金额 */ void processOrderPayment(Long orderId, BigDecimal amount); /** * 取消超时订单 * @param orderId 订单ID */ void cancelTimeoutOrder(Long orderId); /** * 发送订单支付消息 * @param orderId 订单ID * @param userId 用户ID * @param amount 支付金额 */ void sendOrderPayMessage(Long orderId, Long userId, BigDecimal amount); 文件位置: sky-server/src/main/java/com/sky/service/impl/OrderServiceImpl.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 在OrderServiceImpl中添加以下方法 /** * 处理订单支付 * @param orderId 订单ID * @param amount 支付金额 */ @Override public void processOrderPayment(Long orderId, BigDecimal amount) { // 更新订单状态为已支付 Orders orders = Orders.builder() .id(orderId) .status(Orders.TO_BE_CONFIRMED) .payStatus(Orders.PAID) .checkoutTime(LocalDateTime.now()) .build(); orderMapper.update(orders); log.info(\u0026#34;订单支付处理成功：orderId={}, amount={}\u0026#34;, orderId, amount); } /** * 取消超时订单 * @param orderId 订单ID */ @Override public void cancelTimeoutOrder(Long orderId) { // 查询订单状态 Orders ordersDB = orderMapper.getById(orderId); if (ordersDB != null \u0026amp;\u0026amp; ordersDB.getStatus().equals(Orders.PENDING_PAYMENT)) { // 更新订单状态为已取消 Orders orders = Orders.builder() .id(orderId) .status(Orders.CANCELLED) .cancelReason(\u0026#34;订单超时自动取消\u0026#34;) .cancelTime(LocalDateTime.now()) .build(); orderMapper.update(orders); log.info(\u0026#34;订单超时取消成功：orderId={}\u0026#34;, orderId); } } /** * 发送订单支付消息 * @param orderId 订单ID * @param userId 用户ID * @param amount 支付金额 */ @Override public void sendOrderPayMessage(Long orderId, Long userId, BigDecimal amount) { // 这里可以添加发送消息的逻辑 log.info(\u0026#34;发送订单支付消息：orderId={}, userId={}, amount={}\u0026#34;, orderId, userId, amount); } 业务流程:\n支付处理: 更新订单状态，记录支付信息 超时取消: 自动取消超时未支付订单 消息发送: 异步发送支付消息 3.3 CouponService扩展 文件位置: sky-server/src/main/java/com/sky/service/CouponService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 在CouponService接口中添加以下方法 /** * 领取优惠券 * @param templateId 优惠券模板ID * @param userId 用户ID * @return 领取结果 */ String claimCoupon(Long templateId, Long userId); /** * 获取用户可用优惠券 * @param userId 用户ID * @return 用户可用优惠券列表 */ List\u0026lt;Coupon\u0026gt; getUserAvailableCoupons(Long userId); /** * 检查优惠券是否可用 * @param couponId 优惠券ID * @param userId 用户ID * @param orderAmount 订单金额 * @return 检查结果 */ String checkCouponAvailable(Long couponId, Long userId, BigDecimal orderAmount); 文件位置: sky-server/src/main/java/com/sky/service/impl/CouponServiceImpl.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 在CouponServiceImpl中添加以下方法 /** * 领取优惠券 * @param templateId 优惠券模板ID * @param userId 用户ID * @return 领取结果 */ @Override public String claimCoupon(Long templateId, Long userId) { // 检查用户是否已领取该模板的优惠券 if (hasReceived(userId, templateId)) { return \u0026#34;您已经领取过该优惠券了\u0026#34;; } // 检查优惠券模板是否存在且可用 CouponTemplate template = couponTemplateMapper.getById(templateId); if (template == null || template.getStatus() != 1) { return \u0026#34;优惠券模板不存在或已禁用\u0026#34;; } // 检查是否在有效期内 if (template.getEndTime().isBefore(LocalDateTime.now())) { return \u0026#34;优惠券已过期\u0026#34;; } // 创建优惠券 Coupon coupon = Coupon.builder() .templateId(templateId) .userId(userId) .status(0) // 0-未使用 .createTime(LocalDateTime.now()) .updateTime(LocalDateTime.now()) .build(); couponMapper.insert(coupon); return \u0026#34;优惠券领取成功\u0026#34;; } /** * 获取用户可用优惠券 * @param userId 用户ID * @return 用户可用优惠券列表 */ @Override public List\u0026lt;Coupon\u0026gt; getUserAvailableCoupons(Long userId) { return couponMapper.getByUserId(userId, 0); // 0-未使用 } /** * 检查优惠券是否可用 * @param couponId 优惠券ID * @param userId 用户ID * @param orderAmount 订单金额 * @return 检查结果 */ @Override public String checkCouponAvailable(Long couponId, Long userId, BigDecimal orderAmount) { // 这里可以添加优惠券可用性检查逻辑 return \u0026#34;优惠券可用\u0026#34;; } 业务规则:\n领取限制: 每个用户每种优惠券只能领取一次 有效期检查: 确保优惠券在有效期内 使用条件: 检查优惠券的使用条件 4. Mapper层扩展 4.1 UserMapper扩展 文件位置: sky-server/src/main/java/com/sky/mapper/UserMapper.java\n1 2 3 4 5 6 7 8 // 在UserMapper接口中添加以下方法 /** * 更新用户积分 * @param userId 用户ID * @param points 新积分 */ void updateUserPoints(Long userId, Integer points); 文件位置: sky-server/src/main/resources/mapper/UserMapper.xml\n1 2 3 4 5 6 7 8 \u0026lt;!-- 在UserMapper.xml中添加以下SQL --\u0026gt; \u0026lt;update id=\u0026#34;updateUserPoints\u0026#34;\u0026gt; UPDATE user SET points = #{points}, update_time = NOW() WHERE id = #{userId} \u0026lt;/update\u0026gt; 4.2 CouponMapper扩展 文件位置: sky-server/src/main/java/com/sky/mapper/CouponMapper.java\n1 2 3 4 5 6 // 在CouponMapper接口中添加以下方法 /** * 插入优惠券 */ void insert(Coupon coupon); 文件位置: sky-server/src/main/resources/mapper/CouponMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!-- 在CouponMapper.xml中添加以下SQL --\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.sky.entity.Coupon\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; INSERT INTO coupon ( template_id, user_id, status, create_time, update_time ) VALUES ( #{templateId}, #{userId}, #{status}, #{createTime}, #{updateTime} ) \u0026lt;/insert\u0026gt; 4.3 CouponTemplateMapper扩展 文件位置: sky-server/src/main/java/com/sky/mapper/CouponTemplateMapper.java\n1 2 3 4 5 6 7 // 在CouponTemplateMapper接口中添加以下方法 /** * 获取可领取的优惠券模板 * @return 可领取的优惠券模板列表 */ List\u0026lt;CouponTemplate\u0026gt; getAvailableTemplates(); 文件位置: sky-server/src/main/resources/mapper/CouponTemplateMapper.xml\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- 在CouponTemplateMapper.xml中添加以下SQL --\u0026gt; \u0026lt;select id=\u0026#34;getAvailableTemplates\u0026#34; resultType=\u0026#34;com.sky.entity.CouponTemplate\u0026#34;\u0026gt; SELECT * FROM coupon_template WHERE status = 1 AND start_time \u0026amp;lt;= NOW() AND end_time \u0026amp;gt;= NOW() ORDER BY create_time DESC \u0026lt;/select\u0026gt; 5. 配置类 5.1 Redisson配置 文件位置: sky-server/src/main/java/com/sky/config/RedissonConfig.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.sky.config; import org.redisson.Redisson; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * Redisson配置 * 配置分布式锁客户端，支持高并发场景 */ @Configuration public class RedissonConfig { @Value(\u0026#34;${spring.redis.host}\u0026#34;) private String host; @Value(\u0026#34;${spring.redis.port}\u0026#34;) private int port; @Value(\u0026#34;${spring.redis.password:}\u0026#34;) private String password; @Value(\u0026#34;${spring.redis.database:0}\u0026#34;) private int database; @Bean public RedissonClient redissonClient() { Config config = new Config(); String address = \u0026#34;redis://\u0026#34; + host + \u0026#34;:\u0026#34; + port; config.useSingleServer() .setAddress(address) .setPassword(password) .setDatabase(database) .setConnectionPoolSize(10) .setConnectionMinimumIdleSize(5) .setIdleConnectionTimeout(10000) .setConnectTimeout(10000) .setRetryAttempts(3) .setRetryInterval(1500); return Redisson.create(config); } } 配置说明:\n连接池大小: 10个连接，支持高并发 最小空闲连接: 5个，保证连接可用性 超时设置: 10秒连接超时，避免长时间等待 重试机制: 3次重试，提高连接成功率 6. 关键特性 6.1 分布式锁防超卖 基于Redisson实现分布式锁 使用Lua脚本保证原子性操作 锁缓存机制提高性能 6.2 线程安全 MySQL数据库原子性操作 Redis Lua脚本保证一致性 分布式锁防止并发问题 6.3 性能优化 锁对象缓存 连接池配置 异步处理机制 7. 注意事项 锁超时设置: 合理设置锁的超时时间，避免死锁 异常处理: 确保锁的释放，避免资源泄露 性能监控: 监控锁的获取和释放性能 数据一致性: 确保Redis和MySQL数据的一致性 8. 测试建议 并发测试: 使用JMeter等工具测试高并发场景 锁测试: 验证分布式锁的正确性 性能测试: 测试系统在高负载下的表现 异常测试: 测试各种异常情况下的系统行为 9. 业务流程详解 9.1 秒杀业务流程 9.1.1 用户参与秒杀流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 sequenceDiagram participant U as 用户 participant C as 控制器 participant S as 服务层 participant R as Redis participant D as 数据库 U-\u0026gt;\u0026gt;C: 参与秒杀请求 C-\u0026gt;\u0026gt;S: 调用秒杀服务 S-\u0026gt;\u0026gt;R: 获取分布式锁 R--\u0026gt;\u0026gt;S: 锁获取成功 S-\u0026gt;\u0026gt;R: 执行Lua脚本 R--\u0026gt;\u0026gt;S: 返回执行结果 S-\u0026gt;\u0026gt;D: 更新数据库 D--\u0026gt;\u0026gt;S: 更新成功 S-\u0026gt;\u0026gt;R: 释放锁 R--\u0026gt;\u0026gt;S: 锁释放成功 S--\u0026gt;\u0026gt;C: 返回结果 C--\u0026gt;\u0026gt;U: 返回响应 流程说明:\n用户请求: 用户发起秒杀参与请求 获取锁: 使用分布式锁防止并发问题 执行脚本: 使用Lua脚本保证原子性 更新数据库: 更新库存和订单信息 释放锁: 释放分布式锁 返回结果: 返回处理结果给用户 9.1.2 防超卖机制 Lua脚本实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 -- 秒杀参与脚本 local stockKey = KEYS[1] local participantsKey = KEYS[2] local userId = ARGV[1] local quantity = tonumber(ARGV[2]) local perUserLimit = tonumber(ARGV[3]) -- 检查库存 local currentStock = redis.call(\u0026#39;get\u0026#39;, stockKey) if not currentStock then return {0, \u0026#39;活动不存在\u0026#39;} end currentStock = tonumber(currentStock) if currentStock \u0026lt; quantity then return {0, \u0026#39;库存不足\u0026#39;} end -- 检查用户购买限制 local userPurchased = redis.call(\u0026#39;hget\u0026#39;, participantsKey, userId) if userPurchased then userPurchased = tonumber(userPurchased) if userPurchased + quantity \u0026gt; perUserLimit then return {0, \u0026#39;超出购买限制\u0026#39;} end end -- 扣减库存 redis.call(\u0026#39;decrby\u0026#39;, stockKey, quantity) -- 记录用户购买 redis.call(\u0026#39;hincrby\u0026#39;, participantsKey, userId, quantity) return {1, \u0026#39;参与成功\u0026#39;} 防超卖原理:\n原子性操作: Lua脚本保证操作的原子性 库存检查: 先检查库存再扣减 用户限制: 检查用户购买限制 状态更新: 同时更新库存和用户记录 9.2 优惠券业务流程 9.2.1 优惠券领取流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sequenceDiagram participant U as 用户 participant C as 控制器 participant S as 服务层 participant D as 数据库 U-\u0026gt;\u0026gt;C: 领取优惠券请求 C-\u0026gt;\u0026gt;S: 调用优惠券服务 S-\u0026gt;\u0026gt;D: 检查用户是否已领取 D--\u0026gt;\u0026gt;S: 返回检查结果 S-\u0026gt;\u0026gt;D: 检查优惠券模板 D--\u0026gt;\u0026gt;S: 返回模板信息 S-\u0026gt;\u0026gt;D: 创建优惠券记录 D--\u0026gt;\u0026gt;S: 创建成功 S--\u0026gt;\u0026gt;C: 返回结果 C--\u0026gt;\u0026gt;U: 返回响应 业务规则:\n领取限制: 每个用户每种优惠券只能领取一次 有效期检查: 确保优惠券在有效期内 状态检查: 检查优惠券模板是否可用 记录创建: 创建用户优惠券记录 9.2.2 优惠券使用流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sequenceDiagram participant U as 用户 participant C as 控制器 participant S as 服务层 participant D as 数据库 U-\u0026gt;\u0026gt;C: 使用优惠券请求 C-\u0026gt;\u0026gt;S: 调用优惠券服务 S-\u0026gt;\u0026gt;D: 检查优惠券状态 D--\u0026gt;\u0026gt;S: 返回优惠券信息 S-\u0026gt;\u0026gt;D: 检查使用条件 D--\u0026gt;\u0026gt;S: 返回检查结果 S-\u0026gt;\u0026gt;D: 更新优惠券状态 D--\u0026gt;\u0026gt;S: 更新成功 S--\u0026gt;\u0026gt;C: 返回结果 C--\u0026gt;\u0026gt;U: 返回响应 使用条件:\n状态检查: 优惠券必须为未使用状态 有效期检查: 优惠券必须在有效期内 使用条件: 检查订单金额是否满足使用条件 状态更新: 更新优惠券为已使用状态 9.3 积分业务流程 9.3.1 积分获得流程 1 2 3 4 5 6 7 8 9 10 11 12 13 sequenceDiagram participant O as 订单服务 participant M as 消息队列 participant I as 积分服务 participant D as 数据库 O-\u0026gt;\u0026gt;M: 发送积分消息 M-\u0026gt;\u0026gt;I: 消费积分消息 I-\u0026gt;\u0026gt;D: 查询用户积分 D--\u0026gt;\u0026gt;I: 返回当前积分 I-\u0026gt;\u0026gt;D: 更新用户积分 D--\u0026gt;\u0026gt;I: 更新成功 I-\u0026gt;\u0026gt;M: 确认消息 积分规则:\n获得规则: 每消费1元获得1积分 有效期: 积分有效期为1年 使用规则: 积分可用于兑换优惠券 记录管理: 记录积分变动历史 9.3.2 积分使用流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 sequenceDiagram participant U as 用户 participant C as 控制器 participant S as 服务层 participant D as 数据库 U-\u0026gt;\u0026gt;C: 使用积分请求 C-\u0026gt;\u0026gt;S: 调用积分服务 S-\u0026gt;\u0026gt;D: 检查用户积分 D--\u0026gt;\u0026gt;S: 返回积分信息 S-\u0026gt;\u0026gt;D: 扣减用户积分 D--\u0026gt;\u0026gt;S: 扣减成功 S--\u0026gt;\u0026gt;C: 返回结果 C--\u0026gt;\u0026gt;U: 返回响应 使用限制:\n积分检查: 确保用户有足够积分 有效期检查: 确保积分在有效期内 使用记录: 记录积分使用历史 状态更新: 更新用户积分余额 10. 性能优化策略 10.1 缓存策略 10.1.1 Redis缓存设计 缓存键设计:\n1 2 3 4 seckill:stock:活动ID # 库存缓存 seckill:participants:活动ID # 参与者缓存 seckill:lock:业务键 # 锁缓存 seckill:order:订单ID # 订单缓存 缓存更新策略:\n写穿透: 先更新数据库，再更新缓存 缓存预热: 系统启动时预加载热点数据 缓存更新: 数据变更时及时更新缓存 缓存过期: 设置合理的过期时间 10.1.2 缓存一致性 一致性保证:\n最终一致性: 允许短暂的不一致 版本控制: 使用版本号控制缓存更新 事件驱动: 通过事件机制更新缓存 监控告警: 监控缓存一致性状态 10.2 数据库优化 10.2.1 索引优化 秒杀活动表索引:\n1 2 3 4 5 6 7 8 -- 活动状态索引 CREATE INDEX idx_seckill_activity_status ON seckill_activity(status); -- 时间范围索引 CREATE INDEX idx_seckill_activity_time ON seckill_activity(start_time, end_time); -- 商品ID索引 CREATE INDEX idx_seckill_activity_dish_id ON seckill_activity(dish_id); 优惠券表索引:\n1 2 3 4 5 6 7 8 -- 用户ID索引 CREATE INDEX idx_coupon_user_id ON coupon(user_id); -- 状态索引 CREATE INDEX idx_coupon_status ON coupon(status); -- 模板ID索引 CREATE INDEX idx_coupon_template_id ON coupon(template_id); 10.2.2 分库分表策略 分表策略:\n按时间分表: 按月或按年分表 按用户ID分表: 按用户ID哈希分表 按活动ID分表: 按活动ID分表 按状态分表: 按数据状态分表 10.3 并发控制 10.3.1 分布式锁优化 锁粒度控制:\n细粒度锁: 按商品ID加锁 锁超时设置: 设置合理的锁超时时间 锁重入: 支持锁重入机制 锁监控: 监控锁的使用情况 锁性能优化:\n锁缓存: 缓存锁对象，避免重复创建 锁升级: 支持锁升级机制 锁降级: 支持锁降级机制 锁释放: 确保锁的正确释放 10.3.2 限流策略 接口限流:\n令牌桶算法: 使用令牌桶算法限流 滑动窗口: 使用滑动窗口限流 漏桶算法: 使用漏桶算法限流 自适应限流: 根据系统负载自适应限流 用户限流:\nIP限流: 按IP地址限流 用户限流: 按用户ID限流 设备限流: 按设备ID限流 行为限流: 按用户行为限流 11. 监控和告警 11.1 系统监控 11.1.1 性能监控 关键指标:\n响应时间: 接口响应时间监控 吞吐量: 系统吞吐量监控 错误率: 系统错误率监控 资源使用: CPU、内存、磁盘使用率 监控工具:\nPrometheus: 指标收集和存储 Grafana: 指标可视化 AlertManager: 告警管理 Jaeger: 分布式链路追踪 11.1.2 业务监控 业务指标:\n秒杀成功率: 秒杀活动成功率 优惠券使用率: 优惠券使用率 积分使用率: 积分使用率 用户活跃度: 用户活跃度指标 11.2 告警机制 11.2.1 告警规则 系统告警:\n响应时间告警: 响应时间超过阈值 错误率告警: 错误率超过阈值 资源使用告警: 资源使用率超过阈值 服务可用性告警: 服务不可用告警 业务告警:\n库存告警: 库存不足告警 活动异常告警: 活动异常告警 数据异常告警: 数据异常告警 用户异常告警: 用户行为异常告警 11.2.2 告警处理 告警流程:\n告警触发: 监控指标超过阈值 告警发送: 发送告警通知 告警处理: 处理告警问题 告警恢复: 告警恢复通知 12. 测试策略 12.1 单元测试 12.1.1 服务层测试 测试覆盖:\n正常流程测试: 测试正常业务流程 异常流程测试: 测试异常情况处理 边界条件测试: 测试边界条件 并发测试: 测试并发场景 测试工具:\nJUnit: 单元测试框架 Mockito: Mock测试框架 TestContainers: 容器化测试 WireMock: HTTP服务Mock 12.1.2 集成测试 测试场景:\n数据库集成测试: 测试数据库操作 Redis集成测试: 测试Redis操作 消息队列集成测试: 测试消息队列操作 外部服务集成测试: 测试外部服务调用 12.2 性能测试 12.2.1 压力测试 测试工具:\nJMeter: 性能测试工具 Gatling: 高性能测试工具 Artillery: 轻量级测试工具 K6: 现代化测试工具 测试场景:\n秒杀压力测试: 测试秒杀场景性能 优惠券压力测试: 测试优惠券场景性能 积分压力测试: 测试积分场景性能 混合场景测试: 测试混合场景性能 12.2.2 稳定性测试 测试目标:\n长时间运行: 测试系统长时间运行稳定性 内存泄漏: 测试内存泄漏问题 资源使用: 测试资源使用情况 性能衰减: 测试性能衰减情况 13. 部署和运维 13.1 部署策略 13.1.1 容器化部署 Docker配置:\n1 2 3 4 FROM openjdk:17-jre-slim COPY target/sky-server.jar app.jar EXPOSE 8084 ENTRYPOINT [\u0026#34;java\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;/app.jar\u0026#34;] Docker Compose配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 version: \u0026#39;3.8\u0026#39; services: sky-server: build: . ports: - \u0026#34;8084:8084\u0026#34; environment: - SPRING_PROFILES_ACTIVE=prod depends_on: - redis - rabbitmq - mysql redis: image: redis:7-alpine ports: - \u0026#34;6379:6379\u0026#34; rabbitmq: image: rabbitmq:3-management ports: - \u0026#34;5672:5672\u0026#34; - \u0026#34;15672:15672\u0026#34; mysql: image: mysql:8.0 ports: - \u0026#34;3306:3306\u0026#34; environment: - MYSQL_ROOT_PASSWORD=root - MYSQL_DATABASE=sky 13.1.2 微服务部署 服务拆分:\n用户服务: 用户相关功能 订单服务: 订单相关功能 商品服务: 商品相关功能 优惠券服务: 优惠券相关功能 积分服务: 积分相关功能 服务治理:\n服务注册: 使用Nacos进行服务注册 服务发现: 使用Nacos进行服务发现 负载均衡: 使用Ribbon进行负载均衡 熔断降级: 使用Sentinel进行熔断降级 13.2 运维监控 13.2.1 日志管理 日志配置:\n1 2 3 4 5 6 7 8 9 logging: level: com.sky: INFO pattern: console: \u0026#34;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\u0026#34; file: name: logs/sky-server.log max-size: 100MB max-history: 30 日志收集:\nELK Stack: 使用Elasticsearch、Logstash、Kibana Fluentd: 使用Fluentd收集日志 Filebeat: 使用Filebeat收集日志 Logback: 使用Logback记录日志 13.2.2 监控告警 监控指标:\n系统指标: CPU、内存、磁盘、网络 应用指标: 响应时间、吞吐量、错误率 业务指标: 订单量、用户量、收入 基础设施指标: 数据库、Redis、消息队列 告警配置:\n阈值告警: 设置指标阈值告警 趋势告警: 设置趋势变化告警 异常告警: 设置异常情况告警 恢复告警: 设置恢复情况告警 通过以上实现，我们建立了一个完整的分布式锁防超卖系统，确保了秒杀和优惠券功能的线程安全性和数据一致性。\n","date":"2025-01-14T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/hash%E5%92%96%E5%95%A1%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E6%94%B9%E9%80%A0%E6%8C%87%E5%8D%97-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/","title":"Hash咖啡项目后端改造指南 - 第二部分：实体类和分布式锁实现"},{"content":"RabbitMQ 生产者可靠性与确认机制全解析 在分布式系统中，消息队列作为解耦和异步处理的核心组件，其可靠性至关重要。本文将从生产者角度深入解析RabbitMQ的确认机制，包括Confirm机制、Return机制、同步异步模式对比，以及完整的代码实现和最佳实践。\n目录 为什么需要生产者确认机制 RabbitMQ 消息投递链路全景 核心概念详解 生产者确认机制的原理 同步 Confirm 模式 异步 Confirm 模式 Return 机制 publisher-confirm-type 配置 生产者可靠性保障的全链路整合 完整代码实现 最佳实践与总结 为什么需要生产者确认机制 在消息队列的使用过程中，消费者消费确认（Consumer Ack）我们比较熟悉，它保证了消息不会\u0026quot;白白丢失\u0026quot;。\n但往往被忽视的一点是：生产者发送消息到 RabbitMQ Broker 的过程中，也可能丢失消息。常见情况包括：\n消息丢失场景 网络瞬时中断：消息没有到达 Broker Broker 收到消息，但尚未持久化就崩溃 Exchange 路由失败：消息没有进入任何队列 内存不足：Broker 内存溢出导致消息丢失 磁盘故障：持久化消息时磁盘写入失败 问题代码示例（不可靠实现） 1 2 3 4 5 6 7 8 9 10 11 12 13 // ❌ 错误实现：没有确认机制，消息可能丢失 @Service public class UnreliableMessageProducer { @Autowired private RabbitTemplate rabbitTemplate; public void sendMessage(String message) { // 直接发送，不知道是否成功 rabbitTemplate.convertAndSend(\u0026#34;exchange\u0026#34;, \u0026#34;routingKey\u0026#34;, message); System.out.println(\u0026#34;消息已发送\u0026#34;); // 这里可能消息已经丢失了！ } } 可靠实现对比 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // ✅ 正确实现：带确认机制 @Service public class ReliableMessageProducer { @Autowired private RabbitTemplate rabbitTemplate; public void sendMessage(String message) { try { // 开启确认模式 rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -\u0026gt; { if (ack) { System.out.println(\u0026#34;消息投递成功\u0026#34;); } else { System.out.println(\u0026#34;消息投递失败: \u0026#34; + cause); } }); rabbitTemplate.convertAndSend(\u0026#34;exchange\u0026#34;, \u0026#34;routingKey\u0026#34;, message); } catch (Exception e) { System.err.println(\u0026#34;发送消息异常: \u0026#34; + e.getMessage()); } } } 如果没有可靠的确认机制，生产者会认为消息已经成功投递，但实际上消息可能在半路丢了。\n因此，RabbitMQ 提供了 Publisher Confirms 和 Return 机制 来保证生产者侧的可靠性。\nRabbitMQ 消息投递链路全景 让我们从整体链路看一次消息从生产者到消费者的生命周期：\n完整投递链路 1 2 3 4 5 6 生产者 → Channel → Broker → 消息持久化 → Exchange → 路由检查 → Queue → 消费者 ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ deliveryTag 未确认消息Map Confirm机制 持久化结果 路由结果 消息状态 消费结果 ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ 生成唯一ID 记录待确认 处理Ack/Nack 成功→Ack 成功→进入Queue 等待消费 成功→Ack 消息信息 失败→Nack 失败→Return机制 失败→ReturnCallback 失败→Nack 详细流程说明： 1. 生产者发送阶段\n1 2 3 4 生产者 → Channel ├── 生成 deliveryTag（递增计数器） ├── 加入未确认消息Map └── 发送消息到Broker 2. Broker处理阶段\n1 2 3 Broker → 消息持久化 ├── 持久化成功 → 返回Ack → 触发Confirm机制 └── 持久化失败 → 返回Nack → 触发Confirm机制 3. 消息路由阶段\n1 2 3 Exchange → 路由检查 ├── 路由成功 → 消息进入Queue → 等待消费者 └── 路由失败 → 触发Return机制 → 调用ReturnCallback 4. 消费者处理阶段\n1 2 3 消费者 → 处理消息 ├── 消费成功 → 发送Consumer Ack └── 消费失败 → 发送Consumer Nack 关键机制对比表： 机制 触发时机 返回结果 作用范围 处理方式 Confirm机制 消息到达Broker后 Ack/Nack 生产者→Broker 异步回调/同步等待 Return机制 路由失败时 Basic.Return Exchange→Queue ReturnCallback Consumer Ack 消费完成后 Consumer Ack/Nack Queue→消费者 手动确认/自动确认 消息状态流转： 1 2 3 4 5 消息状态: 发送中 → 已持久化 → 已路由 → 已消费 ↓ ↓ ↓ ↓ 确认机制: 无 Confirm Return Consumer Ack ↓ ↓ ↓ ↓ 处理结果: 等待 成功/失败 成功/失败 成功/失败 详细流程说明 生产者调用 channel.basicPublish\n将消息通过 Channel 发送到 Broker 同时，Channel 内部会为该消息生成一个 递增的 deliveryTag 把它放到一个\u0026quot;未确认消息 Map\u0026quot;中（仅在开启 Confirm 模式时） Broker 收到消息并立即持久化\n根据 BasicProperties（包括持久化标志）尝试存储消息 持久化成功 → 准备返回 Ack 持久化失败 → 准备返回 Nack 消息路由处理\n持久化成功后，将消息路由到对应的 Exchange Exchange 进行路由检查： 路由成功 → 消息进入目标 Queue 路由失败 → 触发 Return 机制（如果设置了 mandatory=true） Confirm 机制处理\nBroker 通过 AMQP 协议返回 Confirm 消息帧（包含 deliveryTag、ack/nack、multiple） 生产者的 Channel 收到后，触发内部 Confirm 处理逻辑 Channel 从\u0026quot;未确认 Map\u0026quot;中找到对应 deliveryTag 的消息，移除并触发回调 Return 机制处理（可选）\n如果路由失败且设置了 mandatory=true Broker 返回 Basic.Return 消息帧 生产者通过 ReturnCallback 接收该事件，决定是否重试或丢弃 消费者处理\n消费者从 Queue 获取消息 消费成功 → 发送 Consumer Ack 消费失败 → 发送 Consumer Nack 这一过程确保了 生产者可以明确知道消息的完整投递状态，避免了\u0026quot;黑箱发送\u0026quot;，实现了端到端的消息可靠性保障。\n核心概念详解 1. Broker RabbitMQ 服务器本身就是一个 Broker，负责接收、存储、路由和投递消息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Broker 连接配置 @Configuration public class RabbitMQConfig { @Bean public ConnectionFactory connectionFactory() { CachingConnectionFactory factory = new CachingConnectionFactory(); factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setUsername(\u0026#34;guest\u0026#34;); factory.setPassword(\u0026#34;guest\u0026#34;); factory.setVirtualHost(\u0026#34;/\u0026#34;); // 开启确认模式 factory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED); factory.setPublisherReturns(true); return factory; } } 2. Connection 生产者与 Broker 建立的 TCP 长连接。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Component public class ConnectionManager { @Autowired private ConnectionFactory connectionFactory; private Connection connection; @PostConstruct public void initConnection() { try { connection = connectionFactory.newConnection(); System.out.println(\u0026#34;连接建立成功\u0026#34;); } catch (Exception e) { System.err.println(\u0026#34;连接建立失败: \u0026#34; + e.getMessage()); } } @PreDestroy public void closeConnection() { if (connection != null \u0026amp;\u0026amp; connection.isOpen()) { try { connection.close(); System.out.println(\u0026#34;连接已关闭\u0026#34;); } catch (Exception e) { System.err.println(\u0026#34;关闭连接异常: \u0026#34; + e.getMessage()); } } } } 3. Channel 在 Connection 上的逻辑通道。\n消息的发送、确认都通过 Channel 完成 ConfirmListener 绑定在 Channel 上 deliveryTag 也是以 Channel 为作用域生成的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class ChannelManager { @Autowired private ConnectionFactory connectionFactory; private Channel channel; public Channel getChannel() throws IOException { if (channel == null || !channel.isOpen()) { Connection connection = connectionFactory.newConnection(); channel = connection.createChannel(); // 开启确认模式 channel.confirmSelect(); } return channel; } } 4. Exchange 消息路由器。生产者只能把消息投递到 Exchange，由 Exchange 根据类型（Direct/Topic/Fanout/Headers）和 Binding 规则路由到 Queue。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Component public class ExchangeConfig { @Bean public DirectExchange directExchange() { return new DirectExchange(\u0026#34;direct.exchange\u0026#34;, true, false); } @Bean public TopicExchange topicExchange() { return new TopicExchange(\u0026#34;topic.exchange\u0026#34;, true, false); } @Bean public FanoutExchange fanoutExchange() { return new FanoutExchange(\u0026#34;fanout.exchange\u0026#34;, true, false); } } 5. Queue 消息的存储容器，等待消费者消费。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component public class QueueConfig { @Bean public Queue reliableQueue() { return QueueBuilder.durable(\u0026#34;reliable.queue\u0026#34;) .withArgument(\u0026#34;x-message-ttl\u0026#34;, 60000) // 消息TTL .withArgument(\u0026#34;x-max-length\u0026#34;, 1000) // 队列最大长度 .build(); } @Bean public Queue deadLetterQueue() { return QueueBuilder.durable(\u0026#34;dead.letter.queue\u0026#34;).build(); } } 6. Binding Exchange 与 Queue 的绑定关系，决定消息的流向。\n1 2 3 4 5 6 7 8 9 10 11 @Component public class BindingConfig { @Bean public Binding reliableBinding() { return BindingBuilder .bind(reliableQueue()) .to(directExchange()) .with(\u0026#34;reliable.key\u0026#34;); } } 7. Basic.Publish AMQP 协议中的消息发送命令。调用 channel.basicPublish 就是向 Broker 发送 Basic.Publish 指令，附带消息体和属性。\n生产者确认机制的原理 deliveryTag 每个 Channel 内部会维护一个 递增的计数器 每调用一次 basicPublish，这个计数器加 1，得到一个 deliveryTag deliveryTag 作为消息的\u0026quot;唯一序号\u0026quot;，用于后续 Ack/Nack 对应 1 2 3 4 5 6 7 8 9 10 11 12 13 // deliveryTag 生成示例 public class DeliveryTagGenerator { private final AtomicLong deliveryTagCounter = new AtomicLong(0); public long generateDeliveryTag() { return deliveryTagCounter.incrementAndGet(); } public void reset() { deliveryTagCounter.set(0); } } 未确认消息 Map Channel 内部保存一个 有序 Map，key 是 deliveryTag，value 是消息信息 只有在开启 Confirm 模式后，这个 Map 才会启用 Ack/Nack 到来时，Channel 会查 Map 来找到需要确认的消息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 未确认消息管理 public class UnconfirmedMessageManager { private final Map\u0026lt;Long, UnconfirmedMessage\u0026gt; unconfirmedMessages = new ConcurrentHashMap\u0026lt;\u0026gt;(); public void addUnconfirmedMessage(long deliveryTag, UnconfirmedMessage message) { unconfirmedMessages.put(deliveryTag, message); } public UnconfirmedMessage removeUnconfirmedMessage(long deliveryTag) { return unconfirmedMessages.remove(deliveryTag); } public void removeMultipleMessages(long deliveryTag) { unconfirmedMessages.entrySet().removeIf(entry -\u0026gt; entry.getKey() \u0026lt;= deliveryTag); } public int getUnconfirmedCount() { return unconfirmedMessages.size(); } } @Data @AllArgsConstructor public class UnconfirmedMessage { private String exchange; private String routingKey; private byte[] body; private long timestamp; } multiple 标志位 Ack/Nack 消息中带有 multiple 布尔值 false：只确认当前 deliveryTag true：确认 小于等于当前 deliveryTag 的所有消息 这是一种批量确认机制，可以减少网络交互。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // multiple 标志位处理 public class MultipleConfirmHandler { public void handleConfirm(long deliveryTag, boolean multiple, boolean ack) { if (multiple) { // 批量确认：确认所有小于等于 deliveryTag 的消息 handleMultipleConfirm(deliveryTag, ack); } else { // 单个确认：只确认当前 deliveryTag handleSingleConfirm(deliveryTag, ack); } } private void handleMultipleConfirm(long deliveryTag, boolean ack) { // 处理批量确认逻辑 System.out.println(\u0026#34;批量确认 deliveryTag: \u0026#34; + deliveryTag + \u0026#34;, ack: \u0026#34; + ack); } private void handleSingleConfirm(long deliveryTag, boolean ack) { // 处理单个确认逻辑 System.out.println(\u0026#34;单个确认 deliveryTag: \u0026#34; + deliveryTag + \u0026#34;, ack: \u0026#34; + ack); } } Ack/Nack 触发时机 Ack：消息持久化成功，或投递到队列成功 Nack：存储失败、Broker 内部异常 同步 Confirm 模式 实现方式 调用 channel.confirmSelect() 开启 Confirm 模式 每次 basicPublish 之后调用 channel.waitForConfirms() 阻塞等待 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @Service public class SynchronousConfirmProducer { @Autowired private ConnectionFactory connectionFactory; public void sendMessageWithSyncConfirm(String exchange, String routingKey, String message) { Connection connection = null; Channel channel = null; try { // 1. 建立连接和通道 connection = connectionFactory.newConnection(); channel = connection.createChannel(); // 2. 开启确认模式 channel.confirmSelect(); // 3. 发送消息 channel.basicPublish(exchange, routingKey, null, message.getBytes()); // 4. 同步等待确认 boolean confirmed = channel.waitForConfirms(5000); // 5秒超时 if (confirmed) { System.out.println(\u0026#34;消息投递成功: \u0026#34; + message); } else { System.out.println(\u0026#34;消息投递失败: \u0026#34; + message); } } catch (Exception e) { System.err.println(\u0026#34;发送消息异常: \u0026#34; + e.getMessage()); } finally { // 5. 关闭资源 closeResources(channel, connection); } } public void sendMultipleMessagesWithSyncConfirm(String exchange, String routingKey, List\u0026lt;String\u0026gt; messages) { Connection connection = null; Channel channel = null; try { connection = connectionFactory.newConnection(); channel = connection.createChannel(); channel.confirmSelect(); // 批量发送消息 for (String message : messages) { channel.basicPublish(exchange, routingKey, null, message.getBytes()); } // 批量等待确认 boolean confirmed = channel.waitForConfirms(10000); // 10秒超时 if (confirmed) { System.out.println(\u0026#34;批量消息投递成功，数量: \u0026#34; + messages.size()); } else { System.out.println(\u0026#34;批量消息投递失败\u0026#34;); } } catch (Exception e) { System.err.println(\u0026#34;批量发送消息异常: \u0026#34; + e.getMessage()); } finally { closeResources(channel, connection); } } private void closeResources(Channel channel, Connection connection) { try { if (channel != null \u0026amp;\u0026amp; channel.isOpen()) { channel.close(); } if (connection != null \u0026amp;\u0026amp; connection.isOpen()) { connection.close(); } } catch (Exception e) { System.err.println(\u0026#34;关闭资源异常: \u0026#34; + e.getMessage()); } } } 特点 优点：简单易懂，实时知道结果 缺点：性能差，因为每条消息都要阻塞等待 适用场景：低吞吐、强一致场景 异步 Confirm 模式 实现方式 调用 channel.confirmSelect() 开启 Confirm 模式 注册 ConfirmListener 调用 basicPublish 时不阻塞，依赖异步回调处理 Ack/Nack 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @Service public class AsynchronousConfirmProducer { @Autowired private ConnectionFactory connectionFactory; private final Map\u0026lt;Long, UnconfirmedMessage\u0026gt; unconfirmedMessages = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final AtomicLong deliveryTagCounter = new AtomicLong(0); public void sendMessageWithAsyncConfirm(String exchange, String routingKey, String message) { Connection connection = null; Channel channel = null; try { connection = connectionFactory.newConnection(); channel = connection.createChannel(); channel.confirmSelect(); // 注册异步确认监听器 channel.addConfirmListener( (deliveryTag, multiple) -\u0026gt; { // ack 回调 handleAck(deliveryTag, multiple); }, (deliveryTag, multiple) -\u0026gt; { // nack 回调 handleNack(deliveryTag, multiple); } ); // 异步发送消息 long deliveryTag = deliveryTagCounter.incrementAndGet(); channel.basicPublish(exchange, routingKey, null, message.getBytes()); // 记录未确认消息 unconfirmedMessages.put(deliveryTag, new UnconfirmedMessage( exchange, routingKey, message.getBytes(), System.currentTimeMillis() )); System.out.println(\u0026#34;消息已发送，等待确认: \u0026#34; + message); } catch (Exception e) { System.err.println(\u0026#34;发送消息异常: \u0026#34; + e.getMessage()); } } private void handleAck(long deliveryTag, boolean multiple) { if (multiple) { // 批量确认 unconfirmedMessages.entrySet().removeIf(entry -\u0026gt; entry.getKey() \u0026lt;= deliveryTag); System.out.println(\u0026#34;批量ACK，deliveryTag: \u0026#34; + deliveryTag); } else { // 单个确认 UnconfirmedMessage message = unconfirmedMessages.remove(deliveryTag); if (message != null) { System.out.println(\u0026#34;消息确认成功，deliveryTag: \u0026#34; + deliveryTag + \u0026#34;, message: \u0026#34; + new String(message.getBody())); } } } private void handleNack(long deliveryTag, boolean multiple) { if (multiple) { // 批量拒绝 unconfirmedMessages.entrySet().removeIf(entry -\u0026gt; entry.getKey() \u0026lt;= deliveryTag); System.out.println(\u0026#34;批量NACK，deliveryTag: \u0026#34; + deliveryTag); } else { // 单个拒绝 UnconfirmedMessage message = unconfirmedMessages.remove(deliveryTag); if (message != null) { System.out.println(\u0026#34;消息确认失败，deliveryTag: \u0026#34; + deliveryTag + \u0026#34;, message: \u0026#34; + new String(message.getBody())); // 这里可以实现重试逻辑 retryMessage(message); } } } private void retryMessage(UnconfirmedMessage message) { // 实现重试逻辑 System.out.println(\u0026#34;重试消息: \u0026#34; + new String(message.getBody())); } public void sendMultipleMessagesWithAsyncConfirm(String exchange, String routingKey, List\u0026lt;String\u0026gt; messages) { Connection connection = null; Channel channel = null; try { connection = connectionFactory.newConnection(); channel = connection.createChannel(); channel.confirmSelect(); // 注册确认监听器 channel.addConfirmListener( (deliveryTag, multiple) -\u0026gt; handleAck(deliveryTag, multiple), (deliveryTag, multiple) -\u0026gt; handleNack(deliveryTag, multiple) ); // 批量发送消息 for (String message : messages) { long deliveryTag = deliveryTagCounter.incrementAndGet(); channel.basicPublish(exchange, routingKey, null, message.getBytes()); unconfirmedMessages.put(deliveryTag, new UnconfirmedMessage( exchange, routingKey, message.getBytes(), System.currentTimeMillis() )); } System.out.println(\u0026#34;批量消息已发送，数量: \u0026#34; + messages.size()); } catch (Exception e) { System.err.println(\u0026#34;批量发送消息异常: \u0026#34; + e.getMessage()); } } } 异步的原理 发送消息时：消息立即放入未确认 Map Broker 在后台异步返回 Confirm 帧 Channel 内部的 IO 线程解析 Confirm 帧，找到 deliveryTag 对应的消息，从 Map 移除，并触发回调 与同步的对比 特性 同步 Confirm 异步 Confirm 性能 低（阻塞等待） 高（非阻塞） 吞吐量 低 高 实时性 实时知道结果 通过回调异步处理 复杂度 简单 相对复杂 适用场景 低并发、强一致 高并发、高吞吐 Return 机制 背景 即使消息到达了 Broker，如果 Exchange 无法将消息路由到任何队列，该消息就会被丢弃。\n为避免无声丢失，可以开启 Return 机制。\nMandatory 标志 1 2 // mandatory 参数说明 channel.basicPublish(exchange, routingKey, mandatory, props, body); mandatory=false：路由失败时，Broker 丢弃消息 mandatory=true：路由失败时，Broker 通过 Basic.Return 返回消息给生产者 ReturnCallback 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Service public class ReturnCallbackProducer { @Autowired private ConnectionFactory connectionFactory; public void sendMessageWithReturnCallback(String exchange, String routingKey, String message) { Connection connection = null; Channel channel = null; try { connection = connectionFactory.newConnection(); channel = connection.createChannel(); // 注册 Return 监听器 channel.addReturnListener((replyCode, replyText, exchangeName, routingKeyName, properties, body) -\u0026gt; { System.out.println(\u0026#34;消息无法路由，被退回:\u0026#34;); System.out.println(\u0026#34; replyCode: \u0026#34; + replyCode); System.out.println(\u0026#34; replyText: \u0026#34; + replyText); System.out.println(\u0026#34; exchange: \u0026#34; + exchangeName); System.out.println(\u0026#34; routingKey: \u0026#34; + routingKeyName); System.out.println(\u0026#34; message: \u0026#34; + new String(body)); // 处理退回的消息 handleReturnedMessage(replyCode, replyText, exchangeName, routingKeyName, body); }); // 发送消息，设置 mandatory=true channel.basicPublish(exchange, routingKey, true, null, message.getBytes()); System.out.println(\u0026#34;消息已发送，等待路由结果: \u0026#34; + message); } catch (Exception e) { System.err.println(\u0026#34;发送消息异常: \u0026#34; + e.getMessage()); } } private void handleReturnedMessage(int replyCode, String replyText, String exchange, String routingKey, byte[] body) { // 根据不同的错误码处理退回消息 switch (replyCode) { case 312: // NO_ROUTE System.out.println(\u0026#34;没有找到匹配的队列，消息被退回\u0026#34;); // 可以实现重试或记录日志 break; case 313: // NO_CONSUMERS System.out.println(\u0026#34;没有消费者，消息被退回\u0026#34;); break; default: System.out.println(\u0026#34;未知错误，消息被退回: \u0026#34; + replyCode); } } } 与 Confirm 的区别 机制 作用 触发时机 Confirm 确认消息是否进入 Broker 消息到达 Broker 后 Return 确认消息是否被路由到队列 消息无法路由到队列时 组合使用 完整覆盖生产者可靠性 两者结合，才能完整覆盖 publisher-confirm-type 配置 在 Spring AMQP 中，常见配置是：\n1 2 3 4 spring: rabbitmq: publisher-confirm-type: correlated publisher-returns: true 类型说明 类型 说明 使用场景 none 关闭 confirm 性能优先，可靠性要求不高 simple 同步阻塞等待确认 低并发，强一致性要求 correlated 异步回调确认（推荐） 高并发，高吞吐量 Spring AMQP 配置类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @Configuration @EnableRabbit public class RabbitMQConfig { @Bean public CachingConnectionFactory connectionFactory() { CachingConnectionFactory factory = new CachingConnectionFactory(); factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setUsername(\u0026#34;guest\u0026#34;); factory.setPassword(\u0026#34;guest\u0026#34;); factory.setVirtualHost(\u0026#34;/\u0026#34;); // 开启确认模式 factory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED); factory.setPublisherReturns(true); return factory; } @Bean public RabbitTemplate rabbitTemplate(CachingConnectionFactory connectionFactory) { RabbitTemplate template = new RabbitTemplate(connectionFactory); // 设置确认回调 template.setConfirmCallback((correlationData, ack, cause) -\u0026gt; { if (ack) { System.out.println(\u0026#34;消息投递成功: \u0026#34; + correlationData); } else { System.out.println(\u0026#34;消息投递失败: \u0026#34; + cause); } }); // 设置返回回调 template.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -\u0026gt; { System.out.println(\u0026#34;消息被退回:\u0026#34;); System.out.println(\u0026#34; replyCode: \u0026#34; + replyCode); System.out.println(\u0026#34; replyText: \u0026#34; + replyText); System.out.println(\u0026#34; exchange: \u0026#34; + exchange); System.out.println(\u0026#34; routingKey: \u0026#34; + routingKey); System.out.println(\u0026#34; message: \u0026#34; + new String(message.getBody())); }); return template; } } 与异步 Confirm 的关系 correlated 实际上就是使用 RabbitMQ 的 异步 ConfirmListener；\nSpring 封装了 ConfirmCallback 接口，把 deliveryTag 与消息关联起来，便于开发。\n生产者可靠性保障的全链路整合 完整的可靠性链路通常需要：\n1. Confirm + Return 组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Service public class ReliableMessageProducer { @Autowired private RabbitTemplate rabbitTemplate; public void sendReliableMessage(String exchange, String routingKey, String message) { try { // 设置消息属性 MessageProperties properties = new MessageProperties(); properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); // 持久化 properties.setMessageId(UUID.randomUUID().toString()); properties.setTimestamp(new Date()); Message messageObj = new Message(message.getBytes(), properties); // 发送消息 rabbitTemplate.convertAndSend(exchange, routingKey, messageObj); System.out.println(\u0026#34;可靠消息已发送: \u0026#34; + message); } catch (Exception e) { System.err.println(\u0026#34;发送可靠消息异常: \u0026#34; + e.getMessage()); // 实现重试逻辑 retryMessage(exchange, routingKey, message); } } private void retryMessage(String exchange, String routingKey, String message) { // 实现重试逻辑 System.out.println(\u0026#34;重试发送消息: \u0026#34; + message); } } 2. 幂等性与消息去重 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service public class IdempotentMessageProducer { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Autowired private RabbitTemplate rabbitTemplate; public void sendIdempotentMessage(String exchange, String routingKey, String message, String messageId) { try { // 检查消息是否已发送 String key = \u0026#34;message:\u0026#34; + messageId; if (redisTemplate.hasKey(key)) { System.out.println(\u0026#34;消息已发送，跳过重复发送: \u0026#34; + messageId); return; } // 发送消息 rabbitTemplate.convertAndSend(exchange, routingKey, message); // 记录消息ID，设置过期时间 redisTemplate.opsForValue().set(key, \u0026#34;sent\u0026#34;, Duration.ofHours(24)); System.out.println(\u0026#34;幂等消息已发送: \u0026#34; + messageId); } catch (Exception e) { System.err.println(\u0026#34;发送幂等消息异常: \u0026#34; + e.getMessage()); } } } 3. 消息持久化与磁盘写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component public class PersistentMessageConfig { @Bean public DirectExchange persistentExchange() { return new DirectExchange(\u0026#34;persistent.exchange\u0026#34;, true, false); } @Bean public Queue persistentQueue() { return QueueBuilder.durable(\u0026#34;persistent.queue\u0026#34;) .withArgument(\u0026#34;x-message-ttl\u0026#34;, 60000) .build(); } @Bean public Binding persistentBinding() { return BindingBuilder .bind(persistentQueue()) .to(persistentExchange()) .with(\u0026#34;persistent.key\u0026#34;); } } 4. 应用层补偿机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Service public class CompensatingMessageProducer { @Autowired private RabbitTemplate rabbitTemplate; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; private final Map\u0026lt;String, UnconfirmedMessage\u0026gt; unconfirmedMessages = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Scheduled(fixedRate = 30000) // 30秒检查一次 public void checkUnconfirmedMessages() { long currentTime = System.currentTimeMillis(); unconfirmedMessages.entrySet().removeIf(entry -\u0026gt; { UnconfirmedMessage message = entry.getValue(); if (currentTime - message.getTimestamp() \u0026gt; 60000) { // 1分钟超时 System.out.println(\u0026#34;消息超时未确认，准备重发: \u0026#34; + entry.getKey()); retryMessage(message); return true; } return false; }); } private void retryMessage(UnconfirmedMessage message) { try { rabbitTemplate.convertAndSend( message.getExchange(), message.getRoutingKey(), new String(message.getBody()) ); System.out.println(\u0026#34;消息重发成功: \u0026#34; + new String(message.getBody())); } catch (Exception e) { System.err.println(\u0026#34;消息重发失败: \u0026#34; + e.getMessage()); } } } 完整代码实现 项目结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 rabbitmq-reliability/ ├── src/main/java/com/reliability/ │ ├── config/ │ │ ├── RabbitMQConfig.java │ │ └── MessageConfig.java │ ├── producer/ │ │ ├── ReliableMessageProducer.java │ │ ├── AsyncConfirmProducer.java │ │ └── SyncConfirmProducer.java │ ├── consumer/ │ │ └── ReliableMessageConsumer.java │ ├── entity/ │ │ └── UnconfirmedMessage.java │ ├── service/ │ │ └── MessageReliabilityService.java │ └── util/ │ └── MessageUtils.java 核心配置类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @Configuration @EnableRabbit @Slf4j public class RabbitMQConfig { @Bean public CachingConnectionFactory connectionFactory() { CachingConnectionFactory factory = new CachingConnectionFactory(); factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setUsername(\u0026#34;guest\u0026#34;); factory.setPassword(\u0026#34;guest\u0026#34;); factory.setVirtualHost(\u0026#34;/\u0026#34;); // 连接池配置 factory.setChannelCacheSize(50); factory.setChannelCheckoutTimeout(10000); // 开启确认模式 factory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED); factory.setPublisherReturns(true); return factory; } @Bean public RabbitTemplate rabbitTemplate(CachingConnectionFactory connectionFactory) { RabbitTemplate template = new RabbitTemplate(connectionFactory); // 设置确认回调 template.setConfirmCallback((correlationData, ack, cause) -\u0026gt; { if (ack) { log.info(\u0026#34;消息投递成功: {}\u0026#34;, correlationData); } else { log.error(\u0026#34;消息投递失败: {}, cause: {}\u0026#34;, correlationData, cause); } }); // 设置返回回调 template.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -\u0026gt; { log.warn(\u0026#34;消息被退回: replyCode={}, replyText={}, exchange={}, routingKey={}\u0026#34;, replyCode, replyText, exchange, routingKey); }); return template; } // 交换机配置 @Bean public DirectExchange reliableExchange() { return new DirectExchange(\u0026#34;reliable.exchange\u0026#34;, true, false); } @Bean public Queue reliableQueue() { return QueueBuilder.durable(\u0026#34;reliable.queue\u0026#34;) .withArgument(\u0026#34;x-message-ttl\u0026#34;, 300000) // 5分钟TTL .withArgument(\u0026#34;x-max-length\u0026#34;, 10000) // 最大长度 .build(); } @Bean public Binding reliableBinding() { return BindingBuilder .bind(reliableQueue()) .to(reliableExchange()) .with(\u0026#34;reliable.key\u0026#34;); } } 可靠消息生产者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @Service @Slf4j public class ReliableMessageProducer { @Autowired private RabbitTemplate rabbitTemplate; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; private final Map\u0026lt;String, UnconfirmedMessage\u0026gt; unconfirmedMessages = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 发送可靠消息 */ public void sendReliableMessage(String message, String messageId) { try { // 1. 检查消息是否已发送（幂等性） if (isMessageAlreadySent(messageId)) { log.warn(\u0026#34;消息已发送，跳过重复发送: {}\u0026#34;, messageId); return; } // 2. 构建消息 MessageProperties properties = new MessageProperties(); properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); properties.setMessageId(messageId); properties.setTimestamp(new Date()); properties.setContentType(\u0026#34;application/json\u0026#34;); Message messageObj = new Message(message.getBytes(), properties); // 3. 记录未确认消息 UnconfirmedMessage unconfirmedMessage = new UnconfirmedMessage( \u0026#34;reliable.exchange\u0026#34;, \u0026#34;reliable.key\u0026#34;, message.getBytes(), System.currentTimeMillis() ); unconfirmedMessages.put(messageId, unconfirmedMessage); // 4. 发送消息 rabbitTemplate.convertAndSend(\u0026#34;reliable.exchange\u0026#34;, \u0026#34;reliable.key\u0026#34;, messageObj); // 5. 记录消息ID到Redis recordMessageId(messageId); log.info(\u0026#34;可靠消息已发送: {}\u0026#34;, messageId); } catch (Exception e) { log.error(\u0026#34;发送可靠消息异常: {}\u0026#34;, e.getMessage(), e); // 实现重试逻辑 retryMessage(message, messageId); } } /** * 批量发送可靠消息 */ public void sendBatchReliableMessages(List\u0026lt;String\u0026gt; messages) { for (int i = 0; i \u0026lt; messages.size(); i++) { String messageId = \u0026#34;batch_\u0026#34; + System.currentTimeMillis() + \u0026#34;_\u0026#34; + i; sendReliableMessage(messages.get(i), messageId); } } /** * 检查消息是否已发送 */ private boolean isMessageAlreadySent(String messageId) { String key = \u0026#34;message:\u0026#34; + messageId; return redisTemplate.hasKey(key); } /** * 记录消息ID */ private void recordMessageId(String messageId) { String key = \u0026#34;message:\u0026#34; + messageId; redisTemplate.opsForValue().set(key, \u0026#34;sent\u0026#34;, Duration.ofHours(24)); } /** * 重试消息 */ private void retryMessage(String message, String messageId) { try { Thread.sleep(1000); // 等待1秒 sendReliableMessage(message, messageId + \u0026#34;_retry\u0026#34;); log.info(\u0026#34;消息重试成功: {}\u0026#34;, messageId); } catch (Exception e) { log.error(\u0026#34;消息重试失败: {}\u0026#34;, e.getMessage(), e); } } /** * 获取未确认消息数量 */ public int getUnconfirmedCount() { return unconfirmedMessages.size(); } /** * 清理已确认消息 */ public void removeConfirmedMessage(String messageId) { unconfirmedMessages.remove(messageId); } } 消息消费者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @Component @Slf4j public class ReliableMessageConsumer { @Autowired private ReliableMessageProducer messageProducer; @RabbitListener(queues = \u0026#34;reliable.queue\u0026#34;) public void handleReliableMessage(Message message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) { try { String messageId = message.getMessageProperties().getMessageId(); String messageBody = new String(message.getBody()); log.info(\u0026#34;收到可靠消息: messageId={}, body={}\u0026#34;, messageId, messageBody); // 处理业务逻辑 processMessage(messageBody); // 手动确认消息 channel.basicAck(deliveryTag, false); // 从生产者中移除已确认消息 messageProducer.removeConfirmedMessage(messageId); log.info(\u0026#34;消息处理完成: {}\u0026#34;, messageId); } catch (Exception e) { log.error(\u0026#34;处理消息异常: {}\u0026#34;, e.getMessage(), e); try { // 拒绝消息，不重新入队 channel.basicNack(deliveryTag, false, false); } catch (IOException ioException) { log.error(\u0026#34;拒绝消息异常: {}\u0026#34;, ioException.getMessage(), ioException); } } } /** * 处理业务逻辑 */ private void processMessage(String messageBody) { // 模拟业务处理 try { Thread.sleep(100); log.info(\u0026#34;业务处理完成: {}\u0026#34;, messageBody); } catch (InterruptedException e) { Thread.currentThread().interrupt(); log.error(\u0026#34;业务处理被中断: {}\u0026#34;, e.getMessage(), e); } } } 消息可靠性服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @Service @Slf4j public class MessageReliabilityService { @Autowired private ReliableMessageProducer messageProducer; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; /** * 检查未确认消息 */ @Scheduled(fixedRate = 30000) // 30秒检查一次 public void checkUnconfirmedMessages() { int unconfirmedCount = messageProducer.getUnconfirmedCount(); if (unconfirmedCount \u0026gt; 0) { log.warn(\u0026#34;当前有 {} 条未确认消息\u0026#34;, unconfirmedCount); } } /** * 清理过期的消息记录 */ @Scheduled(fixedRate = 3600000) // 1小时清理一次 public void cleanupExpiredMessages() { try { Set\u0026lt;String\u0026gt; keys = redisTemplate.keys(\u0026#34;message:*\u0026#34;); if (keys != null \u0026amp;\u0026amp; !keys.isEmpty()) { redisTemplate.delete(keys); log.info(\u0026#34;清理过期消息记录: {} 条\u0026#34;, keys.size()); } } catch (Exception e) { log.error(\u0026#34;清理过期消息记录异常: {}\u0026#34;, e.getMessage(), e); } } /** * 获取消息统计信息 */ public Map\u0026lt;String, Object\u0026gt; getMessageStatistics() { Map\u0026lt;String, Object\u0026gt; stats = new HashMap\u0026lt;\u0026gt;(); stats.put(\u0026#34;unconfirmedCount\u0026#34;, messageProducer.getUnconfirmedCount()); stats.put(\u0026#34;timestamp\u0026#34;, System.currentTimeMillis()); return stats; } } 最佳实践与总结 1. 性能优化建议 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 连接池配置优化 @Configuration public class PerformanceConfig { @Bean public CachingConnectionFactory optimizedConnectionFactory() { CachingConnectionFactory factory = new CachingConnectionFactory(); // 连接池配置 factory.setChannelCacheSize(100); // 增加通道缓存 factory.setChannelCheckoutTimeout(5000); // 减少超时时间 // 确认模式配置 factory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED); factory.setPublisherReturns(true); return factory; } } 2. 监控和告警 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Component @Slf4j public class MessageMonitor { @Autowired private ReliableMessageProducer messageProducer; private final AtomicLong successCount = new AtomicLong(0); private final AtomicLong failureCount = new AtomicLong(0); @EventListener public void handleMessageSuccess(MessageSuccessEvent event) { successCount.incrementAndGet(); log.info(\u0026#34;消息发送成功，总数: {}\u0026#34;, successCount.get()); } @EventListener public void handleMessageFailure(MessageFailureEvent event) { failureCount.incrementAndGet(); log.error(\u0026#34;消息发送失败，总数: {}\u0026#34;, failureCount.get()); } @Scheduled(fixedRate = 60000) // 每分钟统计一次 public void logStatistics() { long success = successCount.get(); long failure = failureCount.get(); long total = success + failure; if (total \u0026gt; 0) { double successRate = (double) success / total * 100; log.info(\u0026#34;消息发送统计 - 成功: {}, 失败: {}, 成功率: {:.2f}%\u0026#34;, success, failure, successRate); } } } 3. 总结 Confirm 机制解决了\u0026quot;消息是否到达 Broker\u0026quot;的问题 同步模式：简单但低效，适合低并发场景 异步模式：高效且常用，适合高并发场景 Return 机制解决了\u0026quot;消息是否路由到队列\u0026quot;的问题 与 Confirm 机制结合使用 确保消息完整投递到目标队列 deliveryTag + multiple 构成了 Confirm 的核心逻辑 deliveryTag：消息唯一标识 multiple：批量确认机制 未确认消息Map：管理待确认消息 Spring AMQP 的 publisher-confirm-type=correlated 就是异步 Confirm 的封装 简化了异步确认的使用 提供了统一的回调接口 生产环境中，通常会 Confirm + Return + 消息持久化 + 应用层补偿 组合使用 Confirm机制：确保消息到达Broker Return机制：确保消息路由到队列 消息持久化：确保消息不丢失 应用层补偿：处理异常情况 幂等性保证：避免重复处理 通过本文的详细分析和完整代码实现，相信你已经对RabbitMQ生产者确认机制有了深入的理解。在实际项目中，要根据具体的业务需求和性能要求来选择合适的确认模式，并配合其他可靠性机制来构建真正可靠的消息投递系统。\n本文档详细介绍了RabbitMQ生产者确认机制的原理和实现，包含了完整的代码示例和最佳实践，帮助开发者构建可靠的消息投递系统。\n","date":"2025-01-14T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/rabbitmq-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%B8%8E%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/","title":"RabbitMQ 生产者可靠性与确认机制全解析"}]