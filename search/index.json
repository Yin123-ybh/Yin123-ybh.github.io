[{"content":"基于 Session 的短信登录完整解析 在现代 Web 应用中，短信验证码登录 是一种非常常见的无密码认证方式。它的好处是简单、安全，用户只需要输入手机号和验证码即可登录，而不用记复杂的密码。\n很多初学者在实现时会有疑惑：验证码存哪？怎么比对？登录状态如何保持？ 这篇文章将通过推导的方式，逐步解释清楚，并给出完整的代码示例。\n一、为什么需要 Session 要理解短信登录，必须先搞清楚 Session 的概念。\nHTTP 协议的一个最大特点是：无状态。\n这意味着每一次请求，服务器都不会记得你是谁。\n但是在实际应用里，我们需要：\n登录之后，保持登录状态 购物车内容能够一直保存 验证码发送后，能够正确地校验 这时候就需要 Session。\n1.1 Session 的类比 你可以把 Session 想象成服务器给用户开的一间小储物柜：\n当用户第一次访问时，服务器（tomcat）分配一个储物柜（Session），并生成一个唯一编号（Session ID） 服务器把这个编号写在一张小纸条上（Cookie），交给浏览器（客户端）保存 以后浏览器每次访问时，都会带上这张小纸条 服务器根据纸条上的编号，就能找到对应的储物柜，从里面取出属于该用户的数据 1.2 Session vs Cookie 特性 Cookie（小纸条） Session（储物柜） 存储位置 浏览器端 服务器端 安全性 较低（容易被篡改） 较高（由服务器维护） 容量 4KB 左右 取决于服务器内存 生命周期 可设置长时间保存 默认随浏览器关闭或超时清除 二、短信登录的推导过程 现在我们把 Session 的原理放到 短信验证码登录 的场景中，来一步步推导。\n2.1 用户提交手机号 用户在前端页面输入手机号 前端把手机号发送给后端 2.2 服务器生成验证码 后端生成一个 6 位随机数（例如 123456） 把这个验证码保存到 Session 储物柜 里 同时调用短信服务商的 API，把验证码发送到用户手机 此时，Session 中保存的是： key = \u0026ldquo;SMS_CODE_手机号\u0026rdquo; value = \u0026ldquo;123456\u0026rdquo;\n2.3 用户输入验证码登录 用户收到验证码，在页面输入 浏览器在发起请求时，会自动带上 Session ID 的小纸条（Cookie） 后端根据 Session ID 找到储物柜，从中取出验证码 比对用户输入的验证码与 Session 中保存的验证码 一致 ✅ → 登录成功 不一致 ❌ → 登录失败 三、代码实现示例（Spring Boot） 接下来用 Java + Spring Boot 来实现一个最简化的 基于 Session 的短信登录。\n3.1 发送验证码接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @RestController @RequestMapping(\u0026#34;/auth\u0026#34;) public class SmsLoginController { @PostMapping(\u0026#34;/sendCode\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; sendCode(@RequestParam String phone, HttpSession session) { // 生成 6 位验证码 String code = String.valueOf((int)((Math.random() * 9 + 1) * 100000)); // 模拟发送短信（真实情况需接入短信服务商 API） System.out.println(\u0026#34;向手机号 \u0026#34; + phone + \u0026#34; 发送验证码：\u0026#34; + code); // 保存到 session session.setAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone, code); session.setAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone, System.currentTimeMillis()); return ResponseEntity.ok(\u0026#34;验证码已发送\u0026#34;); } } 说明： 验证码保存在 Session 中，不存前端 建议同时保存验证码生成时间，方便后续判断是否过期\n3.2 验证登录接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @PostMapping(\u0026#34;/login\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; login(@RequestParam String phone, @RequestParam String code, HttpSession session) { String sessionCode = (String) session.getAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone); Long codeTime = (Long) session.getAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone); if (sessionCode == null) { return ResponseEntity.status(400).body(\u0026#34;验证码未发送或已过期\u0026#34;); } // 验证是否过期（5分钟有效） if (System.currentTimeMillis() - codeTime \u0026gt; 5 * 60 * 1000) { session.removeAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone); session.removeAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone); return ResponseEntity.status(400).body(\u0026#34;验证码已过期\u0026#34;); } if (!sessionCode.equals(code)) { return ResponseEntity.status(400).body(\u0026#34;验证码错误\u0026#34;); } // 登录成功，写入用户登录状态 session.setAttribute(\u0026#34;LOGIN_USER\u0026#34;, phone); // 清理验证码 session.removeAttribute(\u0026#34;SMS_CODE_\u0026#34; + phone); session.removeAttribute(\u0026#34;SMS_CODE_TIME_\u0026#34; + phone); return ResponseEntity.ok(\u0026#34;登录成功\u0026#34;); } 说明： 核心逻辑在 后端比对，前端只负责收集输入 验证码过期机制必须有，防止重复使用\n3.3 获取当前登录用户接口 1 2 3 4 5 6 7 8 @GetMapping(\u0026#34;/me\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; getUser(HttpSession session) { String phone = (String) session.getAttribute(\u0026#34;LOGIN_USER\u0026#34;); if (phone == null) { return ResponseEntity.status(401).body(\u0026#34;未登录\u0026#34;); } return ResponseEntity.ok(\u0026#34;当前登录用户：\u0026#34; + phone); } 四、关键点总结 1.Session 是储物柜，Cookie 是储物柜的取件凭证证 验证码存放在 Session（服务器端），不存浏览器 浏览器只保留 Session ID（Cookie） 2.比对逻辑必须在后端完成 前端只负责收集和提交手机号、验证码 服务器根据 Session 找到验证码并比对，决定是否登录 3.安全性措施 验证码要有过期时间（一般 5 分钟） 验证码要有发送频率限制，防止被恶意刷 五、流程回顾 让我们回顾整个短信登录的过程： 1.用户输入手机号 2.服务器生成验证码，存到 Session，并通过短信发送 3.用户收到验证码，输入到前端页面 4.浏览器请求时带上 Cookie（Session ID） 5.服务器用 Session ID 找到储物柜，取出验证码进行比对 一致 → 登录成功； 不一致/过期 → 登录失败 6.扩展思考 在实际生产环境中，Session 可能存放在 Redis 里，以便支持分布式部署。\n另外，也可以替代 Session，用 JWT（JSON Web Token） 实现无状态的登录。 但核心思想是一致的：\n验证码必须在后端保存和比对 前端只负责展示和输入 7.结语 通过上面的推导，我们把“短信登录”这个常见需求，完整地拆解成了 业务流程 + Session 原理 + 实现代码。\n如果你刚开始学习后端开发，希望你能从这篇文章中真正理解：\n为什么要用 Session 短信验证码应该存放在哪里 验证逻辑为什么要在后端 这样，不管是做一个小 demo，还是将来应对生产级的项目，你都能举一反三。\n","date":"2025-08-26T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/%E5%9F%BA%E4%BA%8E-session-%E7%9A%84%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E5%AE%8C%E6%95%B4%E8%A7%A3%E6%9E%90/","title":"基于 Session 的短信登录完整解析"},{"content":"秒杀活动功能完善指南 - 第一部分 目录 项目概述 数据库设计 后端核心功能实现 项目概述 功能目标 实现高并发的秒杀活动系统 防止超卖和重复参与 支持分布式部署 提供用户友好的界面 技术栈 后端: Spring Boot + MyBatis + Redis + Redisson 前端: Vue.js + Element UI 数据库: MySQL 缓存: Redis 分布式锁: Redisson 数据库设计 1. 秒杀参与记录表 1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TABLE seckill_participant ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;主键ID\u0026#39;, activity_id BIGINT NOT NULL COMMENT \u0026#39;秒杀活动ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, quantity INT NOT NULL COMMENT \u0026#39;参与数量\u0026#39;, status TINYINT(1) DEFAULT 0 COMMENT \u0026#39;状态：0-待处理，1-成功，2-失败\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (id), UNIQUE KEY uk_user_activity (user_id, activity_id), KEY idx_activity_id (activity_id), KEY idx_user_id (user_id) ) COMMENT=\u0026#39;秒杀参与记录表\u0026#39;; 2. 秒杀订单表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE seckill_order ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;主键ID\u0026#39;, activity_id BIGINT NOT NULL COMMENT \u0026#39;秒杀活动ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, dish_id BIGINT NOT NULL COMMENT \u0026#39;商品ID\u0026#39;, quantity INT NOT NULL COMMENT \u0026#39;购买数量\u0026#39;, seckill_price DECIMAL(10,2) NOT NULL COMMENT \u0026#39;秒杀价格\u0026#39;, total_amount DECIMAL(10,2) NOT NULL COMMENT \u0026#39;总金额\u0026#39;, status TINYINT(1) DEFAULT 0 COMMENT \u0026#39;订单状态：0-待支付，1-已支付，2-已取消\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (id), KEY idx_activity_id (activity_id), KEY idx_user_id (user_id) ) COMMENT=\u0026#39;秒杀订单表\u0026#39;; 3. 库存扣减记录表 1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TABLE seckill_stock_log ( id BIGINT AUTO_INCREMENT COMMENT \u0026#39;主键ID\u0026#39;, activity_id BIGINT NOT NULL COMMENT \u0026#39;秒杀活动ID\u0026#39;, user_id BIGINT NOT NULL COMMENT \u0026#39;用户ID\u0026#39;, quantity INT NOT NULL COMMENT \u0026#39;扣减数量\u0026#39;, before_stock INT NOT NULL COMMENT \u0026#39;扣减前库存\u0026#39;, after_stock INT NOT NULL COMMENT \u0026#39;扣减后库存\u0026#39;, status TINYINT(1) DEFAULT 1 COMMENT \u0026#39;状态：1-成功，0-失败\u0026#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, PRIMARY KEY (id), KEY idx_activity_id (activity_id), KEY idx_user_id (user_id) ) COMMENT=\u0026#39;库存扣减记录表\u0026#39;; 后端核心功能实现 1. 创建实体类 1.1 秒杀参与记录实体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 文件路径: sky-pojo/src/main/java/com/sky/entity/SeckillParticipant.java package com.sky.entity; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.time.LocalDateTime; @Data @Builder @NoArgsConstructor @AllArgsConstructor public class SeckillParticipant implements Serializable { private static final long serialVersionUID = 1L; private Long id; private Long activityId; private Long userId; private Integer quantity; private Integer status; private LocalDateTime createTime; private LocalDateTime updateTime; } 1.2 秒杀订单实体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 文件路径: sky-pojo/src/main/java/com/sky/entity/SeckillOrder.java package com.sky.entity; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.math.BigDecimal; import java.time.LocalDateTime; @Data @Builder @NoArgsConstructor @AllArgsConstructor public class SeckillOrder implements Serializable { private static final long serialVersionUID = 1L; private Long id; private Long activityId; private Long userId; private Long dishId; private Integer quantity; private BigDecimal seckillPrice; private BigDecimal totalAmount; private Integer status; private LocalDateTime createTime; private LocalDateTime updateTime; } 2. 创建DTO类 2.1 秒杀参与DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 文件路径: sky-pojo/src/main/java/com/sky/dto/SeckillParticipateDTO.java package com.sky.dto; import lombok.Data; import java.io.Serializable; @Data public class SeckillParticipateDTO implements Serializable { private static final long serialVersionUID = 1L; private Long activityId; private Long userId; private Integer quantity; } 3. 创建Mapper接口 3.1 秒杀参与记录Mapper 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 文件路径: sky-server/src/main/java/com/sky/mapper/SeckillParticipantMapper.java package com.sky.mapper; import com.sky.entity.SeckillParticipant; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; @Mapper public interface SeckillParticipantMapper { void insert(SeckillParticipant participant); SeckillParticipant getByUserAndActivity(@Param(\u0026#34;userId\u0026#34;) Long userId, @Param(\u0026#34;activityId\u0026#34;) Long activityId); void updateStatus(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;status\u0026#34;) Integer status); } 3.2 秒杀订单Mapper 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 文件路径: sky-server/src/main/java/com/sky/mapper/SeckillOrderMapper.java package com.sky.mapper; import com.sky.entity.SeckillOrder; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; @Mapper public interface SeckillOrderMapper { void insert(SeckillOrder order); SeckillOrder getById(@Param(\u0026#34;id\u0026#34;) Long id); void updateStatus(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;status\u0026#34;) Integer status); } 4. 创建Mapper XML文件 4.1 秒杀参与记录Mapper XML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!-- 文件路径: sky-server/src/main/resources/mapper/SeckillParticipantMapper.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.SeckillParticipantMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; INSERT INTO seckill_participant (activity_id, user_id, quantity, status, create_time, update_time) VALUES (#{activityId}, #{userId}, #{quantity}, #{status}, #{createTime}, #{updateTime}) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;getByUserAndActivity\u0026#34; resultType=\u0026#34;com.sky.entity.SeckillParticipant\u0026#34;\u0026gt; SELECT * FROM seckill_participant WHERE user_id = #{userId} AND activity_id = #{activityId} \u0026lt;/select\u0026gt; \u0026lt;update id=\u0026#34;updateStatus\u0026#34;\u0026gt; UPDATE seckill_participant SET status = #{status}, update_time = NOW() WHERE id = #{id} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; 4.2 秒杀订单Mapper XML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!-- 文件路径: sky-server/src/main/resources/mapper/SeckillOrderMapper.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.SeckillOrderMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; INSERT INTO seckill_order (activity_id, user_id, dish_id, quantity, seckill_price, total_amount, status, create_time, update_time) VALUES (#{activityId}, #{userId}, #{dishId}, #{quantity}, #{seckillPrice}, #{totalAmount}, #{status}, #{createTime}, #{updateTime}) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;getById\u0026#34; resultType=\u0026#34;com.sky.entity.SeckillOrder\u0026#34;\u0026gt; SELECT * FROM seckill_order WHERE id = #{id} \u0026lt;/select\u0026gt; \u0026lt;update id=\u0026#34;updateStatus\u0026#34;\u0026gt; UPDATE seckill_order SET status = #{status}, update_time = NOW() WHERE id = #{id} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; 5. 创建Lua脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 -- 文件路径: sky-server/src/main/resources/seckill_participate.lua -- 秒杀参与Lua脚本 -- KEYS[1] = seckill:stock:{activityId} -- KEYS[2] = seckill:participants:{activityId} -- ARGV[1] = userId -- ARGV[2] = quantity -- ARGV[3] = perUserLimit -- 检查用户是否已参与 local isParticipated = redis.call(\u0026#39;SISMEMBER\u0026#39;, KEYS[2], ARGV[1]) if isParticipated == 1 then return {0, \u0026#39;用户已参与该活动\u0026#39;} end -- 检查库存是否充足 local stock = redis.call(\u0026#39;GET\u0026#39;, KEYS[1]) if not stock then return {0, \u0026#39;活动不存在\u0026#39;} end stock = tonumber(stock) local quantity = tonumber(ARGV[2]) local perUserLimit = tonumber(ARGV[3]) if stock \u0026lt; quantity then return {0, \u0026#39;库存不足\u0026#39;} end if quantity \u0026gt; perUserLimit then return {0, \u0026#39;超过限购数量\u0026#39;} end -- 扣减库存 local newStock = redis.call(\u0026#39;DECRBY\u0026#39;, KEYS[1], quantity) if newStock \u0026lt; 0 then -- 回滚库存 redis.call(\u0026#39;INCRBY\u0026#39;, KEYS[1], quantity) return {0, \u0026#39;库存不足\u0026#39;} end -- 记录用户参与 redis.call(\u0026#39;SADD\u0026#39;, KEYS[2], ARGV[1]) -- 设置过期时间（活动结束后清理） redis.call(\u0026#39;EXPIRE\u0026#39;, KEYS[2], 86400) return {1, \u0026#39;参与成功\u0026#39;, newStock} 6. 增强SeckillActivityService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 // 在 SeckillActivityServiceImpl.java 中添加以下方法 @Autowired private RedisTemplate redisTemplate; @Autowired private RedissonClient redissonClient; @Autowired private SeckillParticipantMapper seckillParticipantMapper; @Autowired private SeckillOrderMapper seckillOrderMapper; @Value(\u0026#34;${sky.redis.seckill.prefix:seckill:}\u0026#34;) private String seckillPrefix; /** * 参与秒杀活动 */ @Override public String participateSeckill(Long activityId, Long userId, Integer quantity) { // 1. 获取活动信息 SeckillActivity activity = getById(activityId); if (activity == null) { return \u0026#34;活动不存在\u0026#34;; } // 2. 检查活动状态 if (activity.getStatus() != 1) { return \u0026#34;活动已禁用\u0026#34;; } LocalDateTime now = LocalDateTime.now(); if (now.isBefore(activity.getStartTime())) { return \u0026#34;活动未开始\u0026#34;; } if (now.isAfter(activity.getEndTime())) { return \u0026#34;活动已结束\u0026#34;; } // 3. 使用分布式锁防止重复参与 String lockKey = seckillPrefix + \u0026#34;lock:\u0026#34; + activityId; RLock lock = redissonClient.getLock(lockKey); try { if (lock.tryLock(10, 30, TimeUnit.SECONDS)) { // 4. 执行Lua脚本 String stockKey = seckillPrefix + \u0026#34;stock:\u0026#34; + activityId; String participantsKey = seckillPrefix + \u0026#34;participants:\u0026#34; + activityId; DefaultRedisScript\u0026lt;List\u0026gt; script = new DefaultRedisScript\u0026lt;\u0026gt;(); script.setScriptSource(new ResourceScriptSource(new ClassPathResource(\u0026#34;seckill_participate.lua\u0026#34;))); script.setResultType(List.class); List\u0026lt;String\u0026gt; keys = Arrays.asList(stockKey, participantsKey); List\u0026lt;Object\u0026gt; args = Arrays.asList(userId.toString(), quantity.toString(), activity.getPerUserLimit().toString()); List result = redisTemplate.execute(script, keys, args.toArray()); if (result != null \u0026amp;\u0026amp; result.size() \u0026gt; 0) { Integer success = (Integer) result.get(0); if (success == 1) { // 5. 记录参与记录 SeckillParticipant participant = SeckillParticipant.builder() .activityId(activityId) .userId(userId) .quantity(quantity) .status(1) .createTime(now) .updateTime(now) .build(); seckillParticipantMapper.insert(participant); // 6. 异步处理订单 processSeckillOrderAsync(activity, userId, quantity); return \u0026#34;参与成功\u0026#34;; } else { return (String) result.get(1); } } return \u0026#34;参与失败\u0026#34;; } else { return \u0026#34;系统繁忙，请稍后重试\u0026#34;; } } catch (Exception e) { log.error(\u0026#34;参与秒杀活动异常\u0026#34;, e); return \u0026#34;参与失败，请重试\u0026#34;; } finally { if (lock.isHeldByCurrentThread()) { lock.unlock(); } } } /** * 异步处理秒杀订单 */ @Async public void processSeckillOrderAsync(SeckillActivity activity, Long userId, Integer quantity) { try { // 创建秒杀订单 SeckillOrder order = SeckillOrder.builder() .activityId(activity.getId()) .userId(userId) .dishId(activity.getDishId()) .quantity(quantity) .seckillPrice(activity.getSeckillPrice()) .totalAmount(activity.getSeckillPrice().multiply(new BigDecimal(quantity))) .status(0) .createTime(LocalDateTime.now()) .updateTime(LocalDateTime.now()) .build(); seckillOrderMapper.insert(order); // 更新数据库库存 updateDatabaseStock(activity.getId(), quantity); log.info(\u0026#34;秒杀订单创建成功：orderId={}, userId={}, activityId={}\u0026#34;, order.getId(), userId, activity.getId()); } catch (Exception e) { log.error(\u0026#34;处理秒杀订单异常\u0026#34;, e); } } /** * 更新数据库库存 */ @Async public void updateDatabaseStock(Long activityId, Integer quantity) { try { seckillActivityMapper.reduceStock(activityId, quantity); seckillActivityMapper.increaseSoldCount(activityId, quantity); } catch (Exception e) { log.error(\u0026#34;更新数据库库存异常\u0026#34;, e); } } 7. 创建用户端控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 文件路径: sky-server/src/main/java/com/sky/controller/user/SeckillActivityController.java package com.sky.controller.user; import com.sky.entity.SeckillActivity; import com.sky.result.Result; import com.sky.service.SeckillActivityService; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(\u0026#34;/user/seckill/activity\u0026#34;) @Api(tags = \u0026#34;用户端秒杀活动\u0026#34;) @Slf4j public class SeckillActivityController { @Autowired private SeckillActivityService seckillActivityService; @GetMapping(\u0026#34;/current\u0026#34;) @ApiOperation(\u0026#34;获取当前进行中的秒杀活动\u0026#34;) public Result\u0026lt;List\u0026lt;SeckillActivity\u0026gt;\u0026gt; getCurrentActivities() { log.info(\u0026#34;获取当前进行中的秒杀活动\u0026#34;); List\u0026lt;SeckillActivity\u0026gt; activities = seckillActivityService.getCurrentActivities(); return Result.success(activities); } @GetMapping(\u0026#34;/{id}\u0026#34;) @ApiOperation(\u0026#34;根据id查询秒杀活动详情\u0026#34;) public Result\u0026lt;SeckillActivity\u0026gt; getById(@PathVariable Long id) { log.info(\u0026#34;根据id查询秒杀活动详情：{}\u0026#34;, id); SeckillActivity seckillActivity = seckillActivityService.getById(id); return Result.success(seckillActivity); } @PostMapping(\u0026#34;/participate/{id}\u0026#34;) @ApiOperation(\u0026#34;参与秒杀活动\u0026#34;) public Result\u0026lt;String\u0026gt; participateSeckill(@PathVariable Long id, @RequestParam Integer quantity) { log.info(\u0026#34;用户参与秒杀活动：id={}, quantity={}\u0026#34;, id, quantity); // 这里需要从JWT中获取用户ID，暂时使用固定值 Long userId = 1L; // 实际项目中从JWT中获取 String result = seckillActivityService.participateSeckill(id, userId, quantity); return Result.success(result); } } 总结 第一部分涵盖了秒杀活动功能的核心后端实现，包括：\n数据库设计 - 完整的表结构和索引设计 实体类创建 - 秒杀参与记录和订单实体 数据访问层 - Mapper接口和XML配置 核心业务逻辑 - 分布式锁、Redis缓存、Lua脚本 API接口 - 用户端控制器 这些是构建高并发秒杀系统的基础，下一部分将介绍前端界面开发和微信小程序集成。\n继续阅读：秒杀活动功能完善指南 - 第二部分\n","date":"0001-01-01T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://Yin123-ybh.github.io/p/","title":""}]