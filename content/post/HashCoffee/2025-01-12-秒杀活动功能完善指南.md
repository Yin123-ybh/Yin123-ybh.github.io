---
title: "秒杀活动功能完善指南 - 从零到高并发"
date: 2025-01-12
draft: false
tags: ["Java", "Spring Boot", "Redis", "高并发", "秒杀系统"]
categories: ["Web开发"]
description: "详细介绍如何从零开始构建一个高并发的秒杀活动系统，包括防超卖、分布式锁、Redis缓存等核心技术实现。"
---

# 秒杀活动功能完善指南

## 项目概述

### 功能目标
- 实现高并发的秒杀活动系统
- 防止超卖和重复参与
- 支持分布式部署
- 提供用户友好的界面

### 技术栈
- **后端**: Spring Boot + MyBatis + Redis + Redisson
- **前端**: Vue.js + Element UI
- **数据库**: MySQL
- **缓存**: Redis
- **分布式锁**: Redisson

## 数据库设计

### 1. 秒杀参与记录表

```sql
CREATE TABLE seckill_participant (
    id BIGINT AUTO_INCREMENT COMMENT '主键ID',
    activity_id BIGINT NOT NULL COMMENT '秒杀活动ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    quantity INT NOT NULL COMMENT '参与数量',
    status TINYINT(1) DEFAULT 0 COMMENT '状态：0-待处理，1-成功，2-失败',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (id),
    UNIQUE KEY uk_user_activity (user_id, activity_id),
    KEY idx_activity_id (activity_id),
    KEY idx_user_id (user_id)
) COMMENT='秒杀参与记录表';
```

### 2. 秒杀订单表

```sql
CREATE TABLE seckill_order (
    id BIGINT AUTO_INCREMENT COMMENT '主键ID',
    activity_id BIGINT NOT NULL COMMENT '秒杀活动ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    dish_id BIGINT NOT NULL COMMENT '商品ID',
    quantity INT NOT NULL COMMENT '购买数量',
    seckill_price DECIMAL(10,2) NOT NULL COMMENT '秒杀价格',
    total_amount DECIMAL(10,2) NOT NULL COMMENT '总金额',
    status TINYINT(1) DEFAULT 0 COMMENT '订单状态：0-待支付，1-已支付，2-已取消',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (id),
    KEY idx_activity_id (activity_id),
    KEY idx_user_id (user_id)
) COMMENT='秒杀订单表';
```

## 后端核心功能实现

### 1. 创建实体类

#### 秒杀参与记录实体

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SeckillParticipant implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private Long id;
    private Long activityId;
    private Long userId;
    private Integer quantity;
    private Integer status;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}
```

### 2. 核心业务逻辑

#### 秒杀参与核心方法

```java
@Override
public String participateSeckill(Long activityId, Long userId, Integer quantity) {
    // 1. 获取活动信息
    SeckillActivity activity = getById(activityId);
    if (activity == null) {
        return "活动不存在";
    }
    
    // 2. 检查活动状态
    if (activity.getStatus() != 1) {
        return "活动已禁用";
    }
    
    LocalDateTime now = LocalDateTime.now();
    if (now.isBefore(activity.getStartTime())) {
        return "活动未开始";
    }
    if (now.isAfter(activity.getEndTime())) {
        return "活动已结束";
    }
    
    // 3. 使用分布式锁防止重复参与
    String lockKey = seckillPrefix + "lock:" + activityId;
    RLock lock = redissonClient.getLock(lockKey);
    
    try {
        if (lock.tryLock(10, 30, TimeUnit.SECONDS)) {
            // 4. 执行Lua脚本
            String stockKey = seckillPrefix + "stock:" + activityId;
            String participantsKey = seckillPrefix + "participants:" + activityId;
            
            DefaultRedisScript<List> script = new DefaultRedisScript<>();
            script.setScriptSource(new ResourceScriptSource(new ClassPathResource("seckill_participate.lua")));
            script.setResultType(List.class);
            
            List<String> keys = Arrays.asList(stockKey, participantsKey);
            List<Object> args = Arrays.asList(userId.toString(), quantity.toString(), activity.getPerUserLimit().toString());
            
            List result = redisTemplate.execute(script, keys, args.toArray());
            
            if (result != null && result.size() > 0) {
                Integer success = (Integer) result.get(0);
                if (success == 1) {
                    // 5. 记录参与记录
                    SeckillParticipant participant = SeckillParticipant.builder()
                            .activityId(activityId)
                            .userId(userId)
                            .quantity(quantity)
                            .status(1)
                            .createTime(now)
                            .updateTime(now)
                            .build();
                    seckillParticipantMapper.insert(participant);
                    
                    // 6. 异步处理订单
                    processSeckillOrderAsync(activity, userId, quantity);
                    
                    return "参与成功";
                } else {
                    return (String) result.get(1);
                }
            }
            
            return "参与失败";
        } else {
            return "系统繁忙，请稍后重试";
        }
    } catch (Exception e) {
        log.error("参与秒杀活动异常", e);
        return "参与失败，请重试";
    } finally {
        if (lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
}
```

### 3. Lua脚本防超卖

```lua
-- 秒杀参与Lua脚本
-- KEYS[1] = seckill:stock:{activityId}
-- KEYS[2] = seckill:participants:{activityId}
-- ARGV[1] = userId
-- ARGV[2] = quantity
-- ARGV[3] = perUserLimit

-- 检查用户是否已参与
local isParticipated = redis.call('SISMEMBER', KEYS[2], ARGV[1])
if isParticipated == 1 then
    return {0, '用户已参与该活动'}
end

-- 检查库存是否充足
local stock = redis.call('GET', KEYS[1])
if not stock then
    return {0, '活动不存在'}
end

stock = tonumber(stock)
local quantity = tonumber(ARGV[2])
local perUserLimit = tonumber(ARGV[3])

if stock < quantity then
    return {0, '库存不足'}
end

if quantity > perUserLimit then
    return {0, '超过限购数量'}
end

-- 扣减库存
local newStock = redis.call('DECRBY', KEYS[1], quantity)
if newStock < 0 then
    -- 回滚库存
    redis.call('INCRBY', KEYS[1], quantity)
    return {0, '库存不足'}
end

-- 记录用户参与
redis.call('SADD', KEYS[2], ARGV[1])

-- 设置过期时间（活动结束后清理）
redis.call('EXPIRE', KEYS[2], 86400)

return {1, '参与成功', newStock}
```

## 前端界面开发

### 1. 秒杀活动页面

```vue
<template>
  <div class="seckill-container">
    <div class="seckill-header">
      <h2>限时秒杀</h2>
      <p>抢购火爆商品，限时特价</p>
    </div>
    
    <div class="seckill-content">
      <div v-for="activity in activities" :key="activity.id" class="seckill-item">
        <div class="product-info">
          <img :src="activity.dishImage" :alt="activity.dishName" class="product-image">
          <div class="product-details">
            <h3>{{ activity.dishName }}</h3>
            <p class="product-desc">{{ activity.description }}</p>
            <div class="price-info">
              <span class="original-price">¥{{ activity.originalPrice }}</span>
              <span class="seckill-price">¥{{ activity.seckillPrice }}</span>
            </div>
          </div>
        </div>
        
        <div class="seckill-info">
          <div class="stock-info">
            <span>库存：{{ activity.stock - activity.soldCount }}/{{ activity.stock }}</span>
            <div class="progress-bar">
              <div class="progress" :style="{ width: getStockPercent(activity) + '%' }"></div>
            </div>
          </div>
          
          <div class="time-info">
            <div v-if="getActivityStatus(activity) === 'not-started'" class="countdown">
              <span>距离开始：</span>
              <countdown :end-time="activity.startTime" @finish="onCountdownFinish" />
            </div>
            <div v-else-if="getActivityStatus(activity) === 'ended'" class="ended">
              活动已结束
            </div>
            <div v-else class="countdown">
              <span>距离结束：</span>
              <countdown :end-time="activity.endTime" @finish="onCountdownFinish" />
            </div>
          </div>
          
          <div class="action-area">
            <el-button 
              v-if="getActivityStatus(activity) === 'active'"
              type="danger" 
              size="large"
              :disabled="!canParticipate(activity)"
              @click="participateSeckill(activity)"
            >
              立即抢购
            </el-button>
            <el-button v-else disabled size="large">
              {{ getButtonText(activity) }}
            </el-button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
```

### 2. 倒计时组件

```vue
<template>
  <span class="countdown">
    {{ formattedTime }}
  </span>
</template>

<script>
export default {
  name: 'Countdown',
  props: {
    endTime: {
      type: String,
      required: true
    }
  },
  data() {
    return {
      timeLeft: 0,
      timer: null
    }
  },
  computed: {
    formattedTime() {
      const hours = Math.floor(this.timeLeft / 3600)
      const minutes = Math.floor((this.timeLeft % 3600) / 60)
      const seconds = this.timeLeft % 60
      
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
    }
  },
  mounted() {
    this.startCountdown()
  },
  beforeDestroy() {
    this.clearTimer()
  },
  methods: {
    startCountdown() {
      this.updateTimeLeft()
      this.timer = setInterval(() => {
        this.updateTimeLeft()
      }, 1000)
    },
    
    updateTimeLeft() {
      const now = new Date().getTime()
      const end = new Date(this.endTime).getTime()
      this.timeLeft = Math.max(0, Math.floor((end - now) / 1000))
      
      if (this.timeLeft <= 0) {
        this.clearTimer()
        this.$emit('finish')
      }
    },
    
    clearTimer() {
      if (this.timer) {
        clearInterval(this.timer)
        this.timer = null
      }
    }
  }
}
</script>
```

## 微信小程序集成

### 秒杀活动页面

```vue
<template>
  <view class="seckill-container">
    <view class="seckill-header">
      <text class="title">限时秒杀</text>
      <text class="subtitle">抢购火爆商品，限时特价</text>
    </view>
    
    <view class="seckill-list">
      <view v-for="activity in activities" :key="activity.id" class="seckill-item">
        <image :src="activity.dishImage" class="product-image" />
        <view class="product-info">
          <text class="product-name">{{ activity.dishName }}</text>
          <text class="product-desc">{{ activity.description }}</text>
          <view class="price-info">
            <text class="original-price">¥{{ activity.originalPrice }}</text>
            <text class="seckill-price">¥{{ activity.seckillPrice }}</text>
          </view>
        </view>
        
        <view class="seckill-action">
          <view class="stock-info">
            <text class="stock-text">库存：{{ activity.stock - activity.soldCount }}/{{ activity.stock }}</text>
            <view class="progress-bar">
              <view class="progress" :style="{ width: getStockPercent(activity) + '%' }"></view>
            </view>
          </view>
          
          <view class="time-info">
            <text v-if="getActivityStatus(activity) === 'not-started'" class="countdown">
              距离开始：{{ getCountdown(activity.startTime) }}
            </text>
            <text v-else-if="getActivityStatus(activity) === 'ended'" class="ended">
              活动已结束
            </text>
            <text v-else class="countdown">
              距离结束：{{ getCountdown(activity.endTime) }}
            </text>
          </view>
          
          <button 
            v-if="getActivityStatus(activity) === 'active'"
            class="seckill-btn"
            :disabled="!canParticipate(activity)"
            @click="participateSeckill(activity)"
          >
            立即抢购
          </button>
          <button v-else class="seckill-btn disabled">
            {{ getButtonText(activity) }}
          </button>
        </view>
      </view>
    </view>
  </view>
</template>
```

## 关键技术点

### 1. 防超卖机制
- **Redis分布式锁**: 防止重复参与
- **Lua脚本**: 原子性操作库存扣减
- **MySQL原子更新**: 保证数据一致性

### 2. 缓存策略
- **活动信息缓存**: 减少数据库查询
- **库存信息缓存**: 提高并发性能
- **用户参与记录**: 防止重复参与

### 3. 并发控制
- **分布式锁**: 控制并发访问
- **异步处理**: 提高响应速度
- **限流机制**: 保护系统稳定

## 性能优化建议

### 1. 缓存优化
- 合理设置缓存过期时间
- 使用缓存预热
- 避免缓存穿透

### 2. 数据库优化
- 添加必要索引
- 优化SQL查询
- 使用连接池

### 3. 系统优化
- 使用异步处理
- 合理设置线程池
- 监控系统资源

## 总结

这个秒杀活动系统涵盖了高并发场景下的核心技术：

1. **分布式锁** - 解决并发问题
2. **Redis缓存** - 提高系统性能
3. **Lua脚本** - 保证原子性操作
4. **异步处理** - 提升用户体验
5. **前后端分离** - 支持多端访问

通过这个完整的实现，你可以掌握高并发秒杀系统的核心技术和设计思路。记住，学习编程最好的方式就是动手实践！

---

*本文基于 Spring Boot + Redis + Vue.js 技术栈，详细介绍了秒杀活动系统的完整实现过程。*
